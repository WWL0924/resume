(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/lupine.web/src/jsx.ts
  var init_jsx = __esm({
    "node_modules/lupine.web/src/jsx.ts"() {
    }
  });

  // node_modules/lupine.web/src/core/export-lupine.ts
  var _lupineJs, bindRenderPageFunctions, setRenderPageProps, getRenderPageProps, bindRouter;
  var init_export_lupine = __esm({
    "node_modules/lupine.web/src/core/export-lupine.ts"() {
      init_src2();
      _lupineJs = {};
      bindRenderPageFunctions = (calls) => {
        _lupineJs.renderPageFunctions = calls || {};
      };
      setRenderPageProps = (props) => {
        _lupineJs.renderPageProps = props;
      };
      getRenderPageProps = () => {
        return _lupineJs.renderPageProps;
      };
      bindRouter = (router) => {
        _lupineJs.router = router;
        initializeApp();
      };
    }
  });

  // node_modules/lupine.web/src/core/bind-links.ts
  function bindLinks(el) {
    const links = el.getElementsByTagName("a");
    for (var i = 0, l = links.length; i < l; i++) {
      let originalHref = links[i].getAttribute("href");
      if (!originalHref || originalHref.startsWith("javascript:")) continue;
      if (originalHref.startsWith("#")) {
        links[i].onclick = () => {
          var _a;
          const id = decodeURIComponent(originalHref.substring(1));
          (_a = document.getElementById(id)) == null ? void 0 : _a.scrollIntoView(true);
          return false;
        };
        continue;
      }
      let href = new URL(links[i].href, document.baseURI).href;
      if (links[i].target !== "_blank" && href.startsWith(document.location.origin)) {
        href = href.substring(document.location.origin.length);
        links[i].onclick = () => {
          _lupineJs.initializePage(href);
          return false;
        };
      }
    }
  }
  var init_bind_links = __esm({
    "node_modules/lupine.web/src/core/bind-links.ts"() {
      init_export_lupine();
    }
  });

  // node_modules/lupine.web/src/core/replace-innerhtml.ts
  var replaceInnerhtml, callUnload;
  var init_replace_innerhtml = __esm({
    "node_modules/lupine.web/src/core/replace-innerhtml.ts"() {
      replaceInnerhtml = async (el, newHtml) => {
        var _a;
        const firstDom = el.firstChild;
        if (firstDom && firstDom.tagName === "STYLE") {
          (_a = firstDom.parentNode) == null ? void 0 : _a.removeChild(firstDom);
        }
        await callUnload(el);
        el.innerHTML = newHtml;
        if (firstDom && firstDom.tagName === "STYLE") {
          el.insertBefore(firstDom, el.firstChild);
        }
      };
      callUnload = async (el) => {
        const promises = [];
        el.querySelectorAll("[data-ref]").forEach((child) => {
          if (child._lj && child._lj.onUnload) {
            promises.push(child._lj.onUnload());
          }
        });
        await Promise.all(promises);
      };
    }
  });

  // node_modules/lupine.web/src/lib/logger.ts
  var ConsoleColors, Logger;
  var init_logger = __esm({
    "node_modules/lupine.web/src/lib/logger.ts"() {
      ConsoleColors = {
        Red: "#f44336",
        Pink: "#e81e63",
        Purple: "#9c27b0",
        DeepPurple: "#673ab7",
        Indigo: "#3f51b5",
        Blue: "#2196f3",
        LightBlue: "#03a9f4",
        Cyan: "#00bcd4",
        Teal: "#009688",
        Green: "#4caf50",
        LightGreen: "#8bc34a",
        Lime: "#cddc39",
        DarkYellow: "#bfa40e",
        Amber: "#ffc107",
        Orange: "#ff9800",
        DeepOrange: "#ff5722",
        Silver: "#c0c0c0",
        Gray: "#808080",
        Black: "#000000"
      };
      Logger = class _Logger {
        static enabled = true;
        namespace = "";
        color = "";
        constructor(namespace, color) {
          this.namespace = namespace ? `[${namespace}] ` : "";
          if (color) {
            this.color = "color:" + color;
          }
        }
        static setEnabled(enabled) {
          enabled && !_Logger.enabled && console.log(`Logger is enabled.`);
          _Logger.enabled = enabled;
        }
        log(message, ...data) {
          _Logger.enabled && console.log(`%c${this.timestamp()} ${this.namespace}${message}`, this.color, ...data);
        }
        timestamp(date) {
          return (date || /* @__PURE__ */ new Date()).toJSON().substring(11, 23);
        }
        warn(message, ...data) {
          console.warn(`%c${this.timestamp()} ${this.namespace}${message}`, this.color, ...data);
        }
        error(message, ...data) {
          console.error(`%c${this.timestamp()} ${this.namespace}${message}`, this.color, ...data);
        }
      };
    }
  });

  // node_modules/lupine.web/src/lib/unique-id.ts
  function uniqueIdGenerator(preKey) {
    let count = 0;
    const baseTime = Math.round(Date.now() / 1e3);
    let lastKey = "";
    return function() {
      const key = Math.round(Date.now() / 1e3 - baseTime).toString(36);
      if (key !== lastKey) {
        count = 0;
        lastKey = key;
      } else {
        count++;
      }
      return `${preKey}${lastKey}${count.toString(36)}`;
    };
  }
  var init_unique_id = __esm({
    "node_modules/lupine.web/src/lib/unique-id.ts"() {
    }
  });

  // node_modules/lupine.web/src/lib/cookie.ts
  var setCookie, getCookie, clearCookie, cookie;
  var init_cookie = __esm({
    "node_modules/lupine.web/src/lib/cookie.ts"() {
      setCookie = (name, value, expireDays = 365, path, domain, secure) => {
        const expires = new Date((/* @__PURE__ */ new Date()).getTime() + expireDays * 24 * 36e5);
        document.cookie = name + "=" + escape(value) + ";expires=" + expires.toUTCString() + ";path=" + (path ? path : "/") + (domain ? ";domain=" + domain : "") + (secure ? ";secure" : "");
      };
      getCookie = (key) => {
        const cookies = document.cookie.split(";");
        for (let i = 0; i < cookies.length; i++) {
          const c = cookies[i].trim();
          if (c.substring(0, key.length + 1) == key + "=") {
            return unescape(c.substring(key.length + 1));
          }
        }
        return null;
      };
      clearCookie = (name, path, domain, secure) => {
        document.cookie = name + "=;expires=Fri, 02-Jan-1970 00:00:00 GMT;path=" + (path ? path : "/") + (domain ? ";domain=" + domain : "") + (secure ? ";secure" : "");
      };
      cookie = { set: setCookie, get: getCookie, clear: clearCookie };
    }
  });

  // node_modules/lupine.web/src/lib/debug-watch.ts
  var flag, debugWatch;
  var init_debug_watch = __esm({
    "node_modules/lupine.web/src/lib/debug-watch.ts"() {
      flag = 0;
      debugWatch = (port) => {
        console.log("Creating debug-watch socket");
        const protocol = location.protocol === "https:" ? "wss:" : "ws:";
        const socket = new WebSocket(`${protocol}//${location.host}/debug/client`);
        window.addEventListener("beforeunload", () => {
          socket.close();
        });
        socket.onopen = () => {
          socket.send(JSON.stringify({ message: "get-flag" }));
        };
        socket.onmessage = (message) => {
          try {
            const jsonData = JSON.parse(message.data);
            console.log("Debug socket message:", jsonData);
            if (jsonData && jsonData.flag) {
              if (!flag) {
                flag = jsonData.flag;
              } else if (flag !== jsonData.flag) {
                document.location.reload();
              }
            }
          } catch {
          }
        };
        socket.onclose = () => {
          console.log("Debug socket close.");
          setTimeout(() => {
            debugWatch(port);
          }, 3e3);
        };
      };
    }
  });

  // node_modules/lupine.web/src/lib/is-frontend.ts
  var isFrontEnd2;
  var init_is_frontend = __esm({
    "node_modules/lupine.web/src/lib/is-frontend.ts"() {
      isFrontEnd2 = () => {
        return typeof window === "object" && typeof document === "object";
      };
    }
  });

  // node_modules/lupine.web/src/lib/web-config.ts
  var bindWebConfigApi, WebConfig;
  var init_web_config = __esm({
    "node_modules/lupine.web/src/lib/web-config.ts"() {
      init_src();
      bindWebConfigApi = (webConfigApi) => {
        WebConfig.webConfigApi = webConfigApi;
      };
      WebConfig = class _WebConfig {
        static webConfigApi = "";
        static initialized = false;
        static cfg = {};
        // called from generatePage (SSR)
        static initFromData(cfg) {
          this.initialized = true;
          this.cfg = cfg;
        }
        static async init(force) {
          var _a, _b;
          if (this.initialized && !force) {
            return;
          }
          this.initialized = true;
          if (typeof document === "object" && !force) {
            const json = (_a = document.querySelector("#web-setting")) == null ? void 0 : _a.textContent;
            if (json) {
              this.cfg = JSON.parse(json);
              return;
            }
          }
          if (!this.webConfigApi) {
            console.error("WebConfig webConfigApi is not set");
            return;
          }
          const url = getRenderPageProps().renderPageFunctions.baseUrl(this.webConfigApi);
          const data = await getRenderPageProps().renderPageFunctions.fetchData(url);
          if (data && data.json && data.json.status === "ok") {
            this.cfg = data.json.result;
          } else {
            console.error(((_b = data == null ? void 0 : data.json) == null ? void 0 : _b.message) || "Failed to get web config");
          }
        }
        static async get(key, defaultValue) {
          await _WebConfig.init();
          const v = _WebConfig.cfg[key];
          if (typeof v === "undefined") {
            return defaultValue;
          }
          if (typeof defaultValue === "number") {
            return Number.parseInt(v);
          }
          if (typeof defaultValue === "boolean") {
            return v.toLocaleLowerCase() === "true" || v === "1";
          }
          if (typeof defaultValue === "object") {
            if (typeof v === "object") {
              return v;
            }
            try {
              return JSON.parse(v);
            } catch (error) {
              console.error(`WebConfig JSON.parse error: `, error);
            }
            return defaultValue;
          }
          return v || defaultValue;
        }
      };
    }
  });

  // node_modules/lupine.web/src/lib/web-env.ts
  function webEnv(key, defaultValue) {
    var _a;
    if (!_webEnvInitialized) {
      const json = (_a = document.querySelector("#web-env")) == null ? void 0 : _a.textContent;
      if (json) {
        _webEnvInitialized = true;
        initWebEnv(JSON.parse(json));
      }
    }
    !_webEnvInitialized && console.warn("webEnv has not been initialized yet!");
    if (typeof _webEnv[key] === "undefined") {
      return defaultValue;
    }
    if (typeof defaultValue === "number") {
      return Number.parseInt(_webEnv[key]);
    }
    if (typeof defaultValue === "boolean") {
      return _webEnv[key].toLocaleLowerCase() === "true" || _webEnv[key] === "1";
    }
    if (typeof defaultValue === "object") {
      if (typeof _webEnv[key] === "object") {
        return _webEnv[key];
      }
      try {
        return JSON.parse(_webEnv[key]);
      } catch (error) {
        console.error(`webEnv JSON.parse error: `, error);
      }
      return defaultValue;
    }
    return _webEnv[key] || defaultValue;
  }
  function initWebEnv(webEnv2) {
    Object.assign(_webEnv, webEnv2);
    _webEnvInitialized = true;
  }
  var _webEnv, _webEnvInitialized;
  var init_web_env = __esm({
    "node_modules/lupine.web/src/lib/web-env.ts"() {
      _webEnv = {};
      _webEnvInitialized = false;
    }
  });

  // node_modules/lupine.web/src/lib/index.ts
  var init_lib = __esm({
    "node_modules/lupine.web/src/lib/index.ts"() {
      init_cookie();
      init_debug_watch();
      init_is_frontend();
      init_logger();
      init_unique_id();
      init_web_config();
      init_web_env();
    }
  });

  // node_modules/lupine.web/src/core/server-cookie.ts
  var getEitherCookie, _serverCookies, getServerCookie, initServerCookies;
  var init_server_cookie = __esm({
    "node_modules/lupine.web/src/core/server-cookie.ts"() {
      init_cookie();
      init_is_frontend();
      getEitherCookie = (name) => {
        if (!isFrontEnd2()) {
          return getServerCookie(name);
        } else {
          return getCookie(name);
        }
      };
      getServerCookie = (name) => {
        return _serverCookies && _serverCookies.get(name, "");
      };
      initServerCookies = (serverCookies) => {
        return _serverCookies = serverCookies;
      };
    }
  });

  // node_modules/lupine.web/src/core/use-request-context.ts
  var defaultLang, defaultTheme, appData, _contextGetter, bindRequestContext, getRequestContext;
  var init_use_request_context = __esm({
    "node_modules/lupine.web/src/core/use-request-context.ts"() {
      defaultLang = "en";
      defaultTheme = "light";
      appData = {
        defaultPageTitle: "",
        defaultLang,
        langs: {},
        defaultTheme,
        themes: {},
        appGlobalStyles: /* @__PURE__ */ new Map()
        // setDataEvent: null,
      };
      bindRequestContext = (getter) => {
        _contextGetter = getter;
      };
      getRequestContext = () => {
        let ctx;
        if (!_contextGetter || !(ctx = _contextGetter())) {
          throw new Error("Request context is not initialized");
        }
        return ctx;
      };
    }
  });

  // node_modules/lupine.web/src/core/bind-theme.ts
  var themeCookieName, updateThemeEventName, themeAttributeName, bindTheme, getCurrentTheme, updateTheme;
  var init_bind_theme = __esm({
    "node_modules/lupine.web/src/core/bind-theme.ts"() {
      init_cookie();
      init_is_frontend();
      init_server_cookie();
      init_use_request_context();
      themeCookieName = "theme";
      updateThemeEventName = "updateTheme";
      themeAttributeName = "data-theme";
      bindTheme = (defaultTheme2, themes) => {
        appData.defaultTheme = defaultTheme2;
        appData.themes = themes;
      };
      getCurrentTheme = () => {
        let themeName = getEitherCookie(themeCookieName);
        if (!themeName || !appData.themes[themeName]) {
          themeName = appData.defaultTheme;
          if (isFrontEnd2() && getRequestContext().themeName && getRequestContext().themeName !== appData.defaultTheme) {
            setCookie(themeCookieName, getRequestContext().themeName);
          }
        }
        return { themeName, themes: appData.themes };
      };
      updateTheme = (themeName) => {
        getRequestContext().themeName = themeName;
        if (!isFrontEnd2()) {
          return;
        }
        setCookie(themeCookieName, themeName);
        document.documentElement.setAttribute(themeAttributeName, themeName);
        const allIframe = document.querySelectorAll("iframe");
        for (let i = 0; i < allIframe.length; i++) {
          if (allIframe[i].contentWindow && allIframe[i].contentWindow.top === window) {
            allIframe[i].contentWindow.document.documentElement.setAttribute(themeAttributeName, themeName);
          }
        }
        const event = new CustomEvent(updateThemeEventName, { detail: themeName });
        window.dispatchEvent(event);
      };
    }
  });

  // node_modules/lupine.web/src/core/camel-to-hyphens.ts
  var camelToHyphens;
  var init_camel_to_hyphens = __esm({
    "node_modules/lupine.web/src/core/camel-to-hyphens.ts"() {
      camelToHyphens = function(name) {
        return name.replace(/[A-Z]/g, (m) => "-" + m.toLowerCase());
      };
    }
  });

  // node_modules/lupine.web/src/core/page-loaded-event.ts
  var _pageLoadedEvents, callPageLoadedEvent, bindPageLoadedEvent;
  var init_page_loaded_event = __esm({
    "node_modules/lupine.web/src/core/page-loaded-event.ts"() {
      _pageLoadedEvents = [];
      callPageLoadedEvent = () => {
        _pageLoadedEvents.forEach((i) => {
          try {
            i();
          } catch (e) {
            console.error(e);
          }
        });
      };
      bindPageLoadedEvent = (fn) => {
        if (typeof document === "undefined") {
          throw new Error("bindPageLoadedEvent can only be called in the browser");
        }
        _pageLoadedEvents.push(fn);
      };
    }
  });

  // node_modules/lupine.web/src/core/bind-styles.ts
  var wrapCss, processStyleValue, updateOneBlock, processStyleSub, processStyle, updateStyles, updateCssDom, globalStyleUniqueId, getGlobalStylesId, bindAppGlobalStyle, bindGlobalStyle, generateThemeStyles, generateAllGlobalStyles;
  var init_bind_styles = __esm({
    "node_modules/lupine.web/src/core/bind-styles.ts"() {
      init_lib();
      init_bind_theme();
      init_camel_to_hyphens();
      init_page_loaded_event();
      init_use_request_context();
      wrapCss = (className, cssText, mediaQuery) => {
        let cssTextWrap = className ? `${className}{${cssText}}` : cssText;
        if (mediaQuery) {
          cssTextWrap = `${mediaQuery}{${cssTextWrap}}`;
        }
        return cssTextWrap;
      };
      processStyleValue = (style) => {
        return Object.keys(style).map((key) => key.trim()).map((key) => {
          const noOutput = style[key] != null && typeof style[key] === "object" || typeof style[key] === "undefined" || style[key] === "";
          return noOutput ? "" : `${camelToHyphens(key)}:${style[key]};`;
        }).join("");
      };
      updateOneBlock = (css2, cssTemp, className, mediaQuery) => {
        if (cssTemp.length > 0) {
          const cssText = wrapCss(className, cssTemp.join(""), mediaQuery);
          css2.push(cssText);
          cssTemp.length = 0;
        }
      };
      processStyleSub = (topUniqueClassName, classSelector, style, mediaQuery) => {
        const outClassName = classSelector.split(",").map((key0) => key0.trim()).map((key0) => {
          return (key0.startsWith("&") ? `${classSelector}${key0.substring(1)}` : key0).replace(/&/g, topUniqueClassName);
        }).join(",");
        const css2 = [];
        const cssTemp = [];
        for (let i in style) {
          const value = style[i];
          if (value === null || typeof value !== "object") {
            if (value !== "" && typeof value !== "undefined") {
              if (!classSelector) {
                console.warn(`No className is defined for: ${camelToHyphens(i)}:${value};`);
              }
              cssTemp.push(`${camelToHyphens(i)}:${value};`);
            }
          } else {
            updateOneBlock(css2, cssTemp, outClassName, mediaQuery);
            if (i.startsWith("@keyframes")) {
              const cssText = Object.keys(value).map((stageKey) => stageKey + "{" + processStyleValue(value[stageKey]) + "}").join("");
              css2.push(`${i}{${cssText}}`);
            } else if (i.startsWith("@media")) {
              const ret = processStyleSub(topUniqueClassName, classSelector, value, i);
              css2.push(...ret);
            } else {
              const newClassSelector = !classSelector ? i : classSelector.split(",").map((key0) => key0.trim()).map((key0) => {
                return i.split(",").map((key) => key.trim()).map((key) => {
                  const newKey = key.startsWith("&") ? key0 + key.substring(1) : key0 + " " + key;
                  return newKey.replace(/&/g, topUniqueClassName);
                }).join(",");
              }).join(",");
              const ret = processStyleSub(topUniqueClassName, newClassSelector, value, mediaQuery);
              css2.push(...ret);
            }
          }
        }
        updateOneBlock(css2, cssTemp, outClassName, mediaQuery);
        return css2;
      };
      processStyle = (topUniqueClassName, style) => {
        return processStyleSub(topUniqueClassName, topUniqueClassName ? `.${topUniqueClassName}` : "", style);
      };
      updateStyles = (topUniqueClassName, style) => {
        const el = topUniqueClassName && document.querySelector(`.${topUniqueClassName}`);
        if (el) {
          const cssText = processStyle(topUniqueClassName, style).join("");
          if (el.firstChild && el.firstChild.nodeName === "STYLE") {
            el.firstChild.innerHTML = cssText;
          } else {
            const style2 = document.createElement("style");
            style2.innerHTML = cssText;
            el.prepend(style2);
          }
        } else {
          console.warn(`Can't find "${topUniqueClassName}" to update styles.`);
        }
      };
      updateCssDom = (uniqueStyleId, cssText, cssDom) => {
        if (!cssDom) {
          cssDom = document.createElement("style");
          cssDom.id = `sty-${uniqueStyleId}`;
          document.head.appendChild(cssDom);
        }
        cssDom.innerText = cssText;
      };
      globalStyleUniqueId = /* @__PURE__ */ uniqueIdGenerator("g");
      getGlobalStylesId = (style) => {
        if (!getRequestContext().globalStyleIds.has(style)) {
          const id = globalStyleUniqueId();
          getRequestContext().globalStyleIds.set(style, id);
        }
        return getRequestContext().globalStyleIds.get(style);
      };
      bindAppGlobalStyle = (topUniqueClassName, style, forceUpdate = false, noTopClassName = false) => {
        if (typeof document !== "undefined") {
          let cssDom = document.getElementById(`sty-${topUniqueClassName}`);
          if (forceUpdate || !cssDom) {
            updateCssDom(topUniqueClassName, processStyle(noTopClassName ? "" : topUniqueClassName, style).join(""), cssDom);
          }
        } else {
          const _globalStyle = appData.appGlobalStyles;
          if (!_globalStyle.has(topUniqueClassName) || forceUpdate) {
            _globalStyle.set(topUniqueClassName, { topUniqueClassName, noTopClassName, style });
          }
        }
      };
      bindGlobalStyle = (topUniqueClassName, style, forceUpdate = false, noTopClassName = false) => {
        if (typeof document !== "undefined") {
          let cssDom = document.getElementById(`sty-${topUniqueClassName}`);
          if (forceUpdate || !cssDom) {
            updateCssDom(topUniqueClassName, processStyle(noTopClassName ? "" : topUniqueClassName, style).join(""), cssDom);
          }
        } else {
          const _globalStyle = getRequestContext().globalStyles;
          if (!_globalStyle.has(topUniqueClassName) || forceUpdate) {
            _globalStyle.set(topUniqueClassName, { topUniqueClassName, noTopClassName, style });
          }
        }
      };
      generateThemeStyles = () => {
        const currentTheme = getCurrentTheme();
        const themeCss = [];
        for (let themeName in currentTheme.themes) {
          themeCss.push(
            ...processStyle("", {
              [`[data-theme="${themeName}" i]`]: currentTheme.themes[themeName]
            })
          );
        }
        return themeCss.join("\n");
      };
      if (typeof document !== "undefined") {
        bindPageLoadedEvent(() => {
          const uniqueStyleId = themeCookieName;
          let cssDom = document.getElementById(`sty-${uniqueStyleId}`);
          if (!cssDom) {
            updateCssDom(uniqueStyleId, generateThemeStyles(), cssDom);
          }
        });
      }
      generateAllGlobalStyles = () => {
        const result = [];
        result.push(`<style id="sty-${themeCookieName}">${generateThemeStyles()}</style>`);
        for (let [uniqueStyleId, { topUniqueClassName, noTopClassName, style }] of appData.appGlobalStyles) {
          const cssText = processStyle(noTopClassName ? "" : topUniqueClassName, style).join("");
          result.push(`<style id="sty-${uniqueStyleId}">${cssText}</style>`);
        }
        for (let [uniqueStyleId, { topUniqueClassName, noTopClassName, style }] of getRequestContext().globalStyles) {
          const cssText = processStyle(noTopClassName ? "" : topUniqueClassName, style).join("");
          result.push(`<style id="sty-${uniqueStyleId}">${cssText}</style>`);
        }
        return result.join("");
      };
    }
  });

  // node_modules/lupine.web/src/core/render-component.ts
  function renderAttribute(type, props, jsxNodes, uniqueClassName, globalCssId) {
    const html2 = [];
    for (let i in props) {
      if (i === "ref") {
        if (props[i]) {
          props[i].id = genUniqueId(props);
          html2.push("data-ref");
        }
      } else if (!["children", "key", "_result", "_html", "_id"].includes(i)) {
        if (i === "style") {
          if (typeof props[i] === "object") {
            let attrs = `${i}="`;
            for (let j in props[i]) {
              attrs += `${camelToHyphens(j)}:${props[i][j]};`;
            }
            attrs += `"`;
            html2.push(attrs);
          } else {
            html2.push(`${i}="${props[i]}"`);
          }
        } else if (i === "css") {
          genUniqueId(props);
        } else if (i[0] === "o" && i[1] === "n") {
          genUniqueId(props);
        } else if (i === "defaultChecked") {
          if (props[i] === true || props[i] === "checked") {
            html2.push(`checked="true"`);
          }
        } else if (i === "readonly" || i === "disabled" || i === "selected" || i === "checked") {
          if (props[i] !== void 0 && props[i] !== false && props[i] !== "false") {
            html2.push(`${i}="${props[i]}"`);
          }
        } else if (i === "class" || i === "className") {
          let classNameList = props[i].split(" ").filter((item) => item && item !== "");
          if ((props["css"] || props["ref"]) && !classNameList.includes(props._id)) {
            classNameList.unshift(props._id);
          }
          if (props["ref"] && props["ref"].globalCssId && !classNameList.includes(props["ref"].globalCssId)) {
            classNameList.unshift(props["ref"].globalCssId);
          }
          if (globalCssId && uniqueClassName) {
            classNameList = classNameList.flatMap((item) => {
              if (item.includes("&")) {
                return [item.replace(/&/g, globalCssId), item.replace(/&/g, uniqueClassName)];
              }
              return [item];
            });
          } else if (globalCssId) {
            classNameList = classNameList.map((item) => item.replace(/&/g, globalCssId));
          } else if (uniqueClassName) {
            classNameList = classNameList.map((item) => item.replace(/&/g, uniqueClassName));
          }
          html2.push(`class="${classNameList.join(" ")}"`);
        } else if (i !== "dangerouslySetInnerHTML") {
          html2.push(`${i}="${props[i]}"`);
        }
      }
    }
    if (props._id) {
      html2.push(props._id);
    }
    return html2.join(" ");
  }
  async function renderChildrenAsync(html2, children, uniqueClassName, globalCssId) {
    if (typeof children === "string") {
      html2.push(children);
    } else if (children === false || children === null || typeof children === "undefined") {
    } else if (typeof children === "number" || typeof children === "boolean") {
      html2.push(children.toString());
    } else if (Array.isArray(children)) {
      for (const item of children) {
        await renderChildrenAsync(html2, item, uniqueClassName, globalCssId);
      }
    } else if (children.type && children.props) {
      await renderComponentAsync(children.type, children.props, uniqueClassName, globalCssId);
      html2.push(...children.props._html);
      children.props._html.length = 0;
    } else {
      logger.warn("Unexpected", children);
    }
  }
  var logger, domUniqueId, selfClosingTags, genUniqueId, _yieldCounter, YIELD_THRESHOLD, renderComponentAsync;
  var init_render_component = __esm({
    "node_modules/lupine.web/src/core/render-component.ts"() {
      init_logger();
      init_unique_id();
      init_bind_styles();
      init_camel_to_hyphens();
      logger = new Logger("render-components");
      domUniqueId = uniqueIdGenerator("l");
      selfClosingTags = [
        "area",
        "base",
        "br",
        "col",
        "embed",
        "hr",
        "img",
        "input",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ];
      genUniqueId = (props) => {
        if (!props._id) {
          props._id = domUniqueId();
        }
        return props._id;
      };
      _yieldCounter = 0;
      YIELD_THRESHOLD = 50;
      renderComponentAsync = async (type, props, uniqueClassName, globalCssId) => {
        _yieldCounter++;
        if (_yieldCounter >= YIELD_THRESHOLD) {
          _yieldCounter = 0;
          await new Promise((resolve) => {
            setTimeout(resolve, 0);
          });
        }
        if (Array.isArray(props)) {
          const jsxNodes = { type: "Fragment", props: { children: props } };
          await renderComponentAsync(jsxNodes.type, jsxNodes.props, uniqueClassName, globalCssId);
          return;
        }
        props._html = [];
        if (typeof type === "function") {
          props._result = type.call(null, props);
          if (props._result && typeof props._result.then === "function") {
            props._result = await props._result;
          }
          if (props._result === null || props._result === void 0 || props._result === false) {
            props._result = { type: "Fragment", props };
          }
          if (typeof props._result.type === "function") {
            await renderComponentAsync(props._result.type, props._result.props, uniqueClassName, globalCssId);
            if (props._result.props._html) {
              props._html.push(...props._result.props._html);
              props._result.props._html.length = 0;
            }
            return;
          }
        }
        const newType = props._result && props._result.type || type;
        const newProps = props._result && props._result.props || props;
        if (typeof newType === "string") {
          if (newProps._id) {
          }
          let newUniqueClassName = uniqueClassName;
          if (newProps["css"] || newProps["ref"]) {
            newUniqueClassName = genUniqueId(newProps);
            if (!newProps["class"] && !newProps["className"]) newProps["class"] = newUniqueClassName;
          }
          let newGlobalCssId = globalCssId;
          if (newProps["ref"] && newProps["ref"].globalCssId) newGlobalCssId = newProps["ref"].globalCssId;
          const attrs = renderAttribute(newType, newProps, { type, props }, newUniqueClassName, newGlobalCssId);
          if (selfClosingTags.includes(newType.toLowerCase())) {
            if (newType !== "Fragment" || newProps.ref) {
              props._html.push(`<${newType}${attrs ? " " : ""}${attrs} />`);
            }
          } else {
            if (newType !== "Fragment" || newProps.ref) {
              props._html.push(`<${newType}${attrs ? " " : ""}${attrs}>`);
            }
            if (newProps["css"]) {
              const cssText = processStyle(newUniqueClassName, newProps["css"]).join("");
              props._html.push(`<style id="sty-${newUniqueClassName}">${cssText}</style>`);
            }
            if (newProps.children || newProps.children === 0) {
              await renderChildrenAsync(props._html, newProps.children, newUniqueClassName, newGlobalCssId);
            } else if (newProps["dangerouslySetInnerHTML"]) {
              props._html.push(newProps["dangerouslySetInnerHTML"]);
            }
            if (newType !== "Fragment" || newProps.ref) {
              props._html.push(`</${newType}>`);
            }
          }
        } else if (newType.name === "Fragment") {
          await renderChildrenAsync(props._html, newProps.children, uniqueClassName, globalCssId);
        } else {
          logger.warn("Unknown type: ", type, props, newType, newProps);
        }
      };
    }
  });

  // node_modules/lupine.web/src/core/mount-component.ts
  var mountInnerComponent, mountOuterComponent, mountSiblingComponent;
  var init_mount_component = __esm({
    "node_modules/lupine.web/src/core/mount-component.ts"() {
      init_bind_attributes();
      init_bind_links();
      init_replace_innerhtml();
      init_render_component();
      mountInnerComponent = async (selector, jsxNodes) => {
        await renderComponentAsync(jsxNodes.type, jsxNodes.props);
        const el = selector && (typeof selector === "string" ? document.querySelector(selector) : selector);
        if (el) {
          await replaceInnerhtml(el, jsxNodes.props._html.join(""));
          bindAttributes(el, jsxNodes.type, jsxNodes.props);
          bindLinks(el);
        }
      };
      mountOuterComponent = async (selector, jsxNodes) => {
        var _a;
        await renderComponentAsync(jsxNodes.type, jsxNodes.props);
        let el = selector && (typeof selector === "string" ? document.querySelector(selector) : selector);
        if (el) {
          const template = document.createElement("template");
          await replaceInnerhtml(template, jsxNodes.props._html.join(""));
          template.content.children.length > 1 && console.error("renderComponent should only have one element: ", template.content.children.length);
          const newEl = template.content.firstChild;
          await callUnload(el);
          (_a = el.parentNode) == null ? void 0 : _a.replaceChild(newEl, el);
          bindAttributes(newEl, jsxNodes.type, jsxNodes.props);
          bindLinks(newEl);
        }
      };
      mountSiblingComponent = async (selector, jsxNodes, position = "after") => {
        var _a, _b;
        await renderComponentAsync(jsxNodes.type, jsxNodes.props);
        let el = selector && (typeof selector === "string" ? document.querySelector(selector) : selector);
        if (el) {
          const template = document.createElement("template");
          await replaceInnerhtml(template, jsxNodes.props._html.join(""));
          template.content.children.length > 1 && console.error("renderComponent should only have one element: ", template.content.children.length);
          const newEl = template.content.firstChild;
          await callUnload(el);
          if (el.nextSibling || position === "before") {
            (_a = el.parentNode) == null ? void 0 : _a.insertBefore(newEl, position === "after" ? el.nextSibling : el);
          } else {
            (_b = el.parentNode) == null ? void 0 : _b.appendChild(newEl);
          }
          bindAttributes(newEl, jsxNodes.type, jsxNodes.props);
          bindLinks(newEl);
        }
      };
    }
  });

  // node_modules/lupine.web/src/core/bind-ref.ts
  var bindRef;
  var init_bind_ref = __esm({
    "node_modules/lupine.web/src/core/bind-ref.ts"() {
      init_mount_component();
      init_replace_innerhtml();
      bindRef = (type, newProps, el) => {
        const id = newProps._id;
        el._lj = el._lj || {};
        el._lj.ref = newProps["ref"];
        newProps["ref"].current = el;
        if (newProps["ref"].onLoad) {
          const defer = Promise.prototype.then.bind(Promise.resolve());
          defer(() => newProps["ref"].onLoad(el));
        }
        if (newProps["ref"].onUnload) {
          el._lj.onUnload = async () => {
            await newProps["ref"].onUnload(el);
          };
        }
        newProps["ref"].$ = (selector) => {
          if (selector.startsWith("&")) {
            return el.querySelector(`.${id}${selector.substring(1).replace(/&/g, id)}`);
          }
          return el.querySelector(`.${id} ${selector.replace(/&/g, id)}`);
        };
        newProps["ref"].$all = (selector) => {
          if (selector.startsWith("&")) {
            return el.querySelectorAll(`.${id}${selector.substring(1).replace(/&/g, id)}`);
          }
          return el.querySelectorAll(`.${id} ${selector.replace(/&/g, id)}`);
        };
        newProps["ref"].mountInnerComponent = async (content) => {
          if (typeof content === "object" && content.type && content.props) {
            await mountInnerComponent(el, content);
          } else {
            await replaceInnerhtml(el, content);
          }
        };
        newProps["ref"].mountOuterComponent = async (content) => {
          await mountOuterComponent(el, content);
        };
      };
    }
  });

  // node_modules/lupine.web/src/core/bind-attributes.ts
  var bindAttributesChildren, bindAttributes;
  var init_bind_attributes = __esm({
    "node_modules/lupine.web/src/core/bind-attributes.ts"() {
      init_bind_ref();
      bindAttributesChildren = (topEl, children) => {
        for (let i = 0; i < children.length; i++) {
          const item = children[i];
          if (item && item.type && item.props) {
            bindAttributes(topEl, item.type, item.props);
          } else if (item && Array.isArray(item)) {
            bindAttributesChildren(topEl, item);
          } else if (typeof item !== "undefined" && item !== null && typeof item !== "string" && typeof item !== "number" && typeof item !== "boolean") {
            console.warn(`Unexpected children:`, item);
          }
        }
      };
      bindAttributes = (topEl, type, props) => {
        const newProps = props._result && props._result.props || props;
        if (newProps._id) {
          let el = topEl.querySelector(`[${newProps._id}]`);
          if (!el && topEl.getAttribute(newProps._id) === "") {
            el = topEl;
          }
          if (el) {
            for (let i in newProps) {
              if (i === "ref") {
                bindRef(type, newProps, el);
              } else if (i[0] === "o" && i[1] === "n") {
                let name = i;
                if (name.toLowerCase() in el) name = name.toLowerCase().slice(2);
                else name = name.slice(2);
                el.addEventListener(name, newProps[i]);
              }
            }
          }
        }
        if (newProps.children && Array.isArray(newProps.children)) {
          bindAttributesChildren(topEl, newProps.children);
        } else if (newProps._result && newProps._result.type !== "Fragment" && newProps._result.props) {
          bindAttributes(topEl, newProps._result.type, newProps._result.props);
        } else if (newProps.children && newProps.children.type && newProps.children.props) {
          bindAttributes(topEl, newProps.children.type, newProps.children.props);
        } else if (!newProps.children || typeof newProps.children === "string" || typeof newProps.children === "number" || typeof newProps.children === "boolean") {
        } else {
          console.warn(`Unexpected children:`, newProps.children, type, props);
        }
      };
    }
  });

  // node_modules/lupine.web/src/core/bind-lang.ts
  var langCookieName, updateLangEventName, bindLang, getCurrentLang, updateLang;
  var init_bind_lang = __esm({
    "node_modules/lupine.web/src/core/bind-lang.ts"() {
      init_cookie();
      init_is_frontend();
      init_server_cookie();
      init_use_request_context();
      langCookieName = "lang";
      updateLangEventName = "updateLang";
      bindLang = (defaultLang2, langs) => {
        appData.defaultLang = defaultLang2;
        appData.langs = langs;
      };
      getCurrentLang = () => {
        let langName = getEitherCookie(langCookieName);
        if (!langName || !appData.langs[langName]) {
          langName = getRequestContext().langName || appData.defaultLang;
          if (isFrontEnd2() && getRequestContext().langName && getRequestContext().langName !== appData.defaultLang) {
            setCookie(langCookieName, getRequestContext().langName);
          }
        }
        return { langName, langs: appData.langs };
      };
      updateLang = (langName) => {
        getRequestContext().langName = langName;
        if (!isFrontEnd2()) {
          return;
        }
        setCookie(langCookieName, langName);
        const event = new CustomEvent(updateLangEventName, { detail: langName });
        window.dispatchEvent(event);
      };
    }
  });

  // node_modules/lupine.web/src/core/bind-meta.tsx
  var setPageTitle, getPageTitle, setDefaultPageTitle, addMetaDataTags, getMetaDataTags, getMetaDataObject;
  var init_bind_meta = __esm({
    "node_modules/lupine.web/src/core/bind-meta.tsx"() {
      init_use_request_context();
      setPageTitle = (title) => {
        getRequestContext().pageTitle = title;
      };
      getPageTitle = () => {
        return getRequestContext().pageTitle || appData.defaultPageTitle;
      };
      setDefaultPageTitle = (title) => {
        appData.defaultPageTitle = title;
      };
      addMetaDataTags = (key, value) => {
        const _metaData = getRequestContext().metaData;
        if (typeof value === "undefined") {
          delete _metaData[key];
        } else {
          _metaData[key] = value;
        }
      };
      getMetaDataTags = () => {
        return Object.values(getMetaDataObject()).join("\n");
      };
      getMetaDataObject = () => {
        return getRequestContext().metaData;
      };
    }
  });

  // node_modules/lupine.web/src/core/page-router.ts
  var PageRouter;
  var init_page_router = __esm({
    "node_modules/lupine.web/src/core/page-router.ts"() {
      init_is_frontend();
      init_mount_component();
      init_logger();
      PageRouter = class _PageRouter {
        logger = new Logger("page-router");
        routerData = [];
        filter;
        framePage;
        subDir = "";
        // if the filter returns null (passed filter), the router will continue.
        // it works in the same way as in use method
        setFilter(filter) {
          this.filter = filter;
        }
        // if the script is under a sub-dir (without last /), then findRoute needs to remove it from the url
        setSubDir(subDir) {
          this.subDir = subDir;
        }
        setFramePage(framePage) {
          this.framePage = framePage;
        }
        // the path should start with / and end without /, and it can be
        //    /aaa/:bbb/ccc/:ddd (ccc is a fixed section)
        //    /aaa/:bbb/ccc/?ddd/?eee (from ddd, all sections are optional)
        //    /aaa/:?bbb/ccc/ (from bbb, all sections are optional)
        storeRouter(path, handler) {
          let fixedPath;
          if (path === "*" || path === "" || path === "/*") {
            fixedPath = "*";
          } else {
            fixedPath = path;
            if (!fixedPath.startsWith("/")) {
              fixedPath = "/" + fixedPath;
            }
            if (fixedPath.endsWith("/") && fixedPath.length > 1) {
              fixedPath = fixedPath.substring(0, fixedPath.length - 1);
            }
          }
          let parameterLength = 0;
          let parameterVariables = [];
          const ind = fixedPath.indexOf("/:");
          if (ind >= 0) {
            parameterVariables = fixedPath.substring(ind + 1).split("/");
            fixedPath = fixedPath.substring(0, ind);
            const optionInd = parameterVariables.findIndex((item) => item.startsWith("?"));
            parameterLength = optionInd >= 0 ? optionInd : parameterVariables.length;
          }
          this.routerData.push({
            path: fixedPath,
            handler,
            parameterVariables,
            parameterLength
          });
        }
        use(path, ...handler) {
          this.storeRouter(path, handler);
        }
        async callHandle(handle, path, props) {
          try {
            const vNode = await handle(props);
            return vNode;
          } catch (e) {
            this.logger.error(`Processed path: ${path}, error: ${e.message}`);
            console.error(e.stack);
          }
          return null;
        }
        async findRoute(url, props, renderPartPage) {
          for (let i = 0, routerList; routerList = this.routerData[i]; i++) {
            if (routerList.path === "*" || url === routerList.path || url.startsWith(routerList.path + "/")) {
              const parameters = {};
              let meet = true;
              if (routerList.parameterVariables.length > 0) {
                meet = false;
                let newUrl = url.substring(routerList.path.length + 1);
                if (newUrl.endsWith("/")) {
                  newUrl = newUrl.substring(0, newUrl.length - 1);
                }
                const restPath = newUrl.split("/");
                if (restPath.length >= routerList.parameterLength && restPath.length <= routerList.parameterVariables.length) {
                  meet = true;
                  for (const [index, item] of routerList.parameterVariables.entries()) {
                    if (!item.startsWith(":") && !item.startsWith("?") && item !== restPath[index]) {
                      meet = false;
                      break;
                    } else if ((item.startsWith(":") || item.startsWith("?")) && index < restPath.length) {
                      parameters[item.replace(/[:?]/g, "")] = restPath[index];
                    }
                  }
                  props.urlParameters = parameters;
                }
              }
              if (meet) {
                for (let j = 0, router; router = routerList.handler[j]; j++) {
                  if (router instanceof _PageRouter) {
                    const nextPath = routerList.path === "*" || url === "/" && routerList.path === "/" ? url : url.substring(routerList.path.length);
                    const vNode = await router.handleRoute(nextPath, props, renderPartPage);
                    if (vNode) {
                      return vNode;
                    }
                  } else {
                    const dom = await this.callHandle(router, url, props);
                    if (dom) {
                      return dom;
                    }
                  }
                }
                return null;
              }
            }
          }
          return null;
        }
        async handleRoute(url, props, renderPartPage) {
          if (url.startsWith(this.subDir)) {
            url = url.substring(this.subDir.length);
          }
          let vNode = null;
          if (this.filter) {
            vNode = await this.callHandle(this.filter, url, props);
          }
          if (!vNode) {
            vNode = await this.findRoute(url, props, renderPartPage);
          }
          if (vNode && this.framePage) {
            const selector = "." + this.framePage.placeholderClassname;
            if (renderPartPage && isFrontEnd2() && document.querySelector(selector)) {
              await mountInnerComponent(selector, vNode);
              return null;
            } else {
              return this.framePage.component(this.framePage.placeholderClassname, vNode);
            }
          }
          return vNode;
        }
      };
    }
  });

  // node_modules/lupine.web/src/core/initialize.ts
  var logger2, renderTargetPage, generatePage, _initSaved, initializePage2, initializeApp;
  var init_initialize = __esm({
    "node_modules/lupine.web/src/core/initialize.ts"() {
      init_logger();
      init_bind_styles();
      init_bind_theme();
      init_mount_component();
      init_render_component();
      init_page_router();
      init_page_loaded_event();
      init_server_cookie();
      init_bind_meta();
      init_web_env();
      init_export_lupine();
      init_is_frontend();
      init_web_config();
      init_use_request_context();
      logger2 = new Logger("initialize");
      renderTargetPage = async (props, renderPartPage) => {
        if (_lupineJs.router instanceof PageRouter) {
          return _lupineJs.router.handleRoute(props.url, props, renderPartPage);
        }
        return await _lupineJs.router(props);
      };
      generatePage = async (props, toClientDelivery) => {
        setRenderPageProps(props);
        bindRequestContext(() => toClientDelivery.getRequestContext());
        initWebEnv(toClientDelivery.getWebEnv());
        WebConfig.initFromData(toClientDelivery.getWebSetting());
        initServerCookies(toClientDelivery.getServerCookie());
        callPageLoadedEvent();
        const jsxNodes = await renderTargetPage(props, false);
        if (!jsxNodes || !jsxNodes.props) {
          return {
            content: `Unexpected url: ${props.url}`,
            title: "",
            metaData: "",
            globalCss: "",
            themeName: getCurrentTheme().themeName
          };
        }
        await renderComponentAsync(jsxNodes.type, jsxNodes.props);
        const currentTheme = getCurrentTheme();
        const cssText = generateAllGlobalStyles();
        const content = jsxNodes.props._html.join("");
        return {
          content,
          title: getPageTitle(),
          metaData: getMetaDataTags(),
          globalCss: cssText,
          themeName: currentTheme.themeName
        };
      };
      _lupineJs.generatePage = generatePage;
      _initSaved = {
        pageInitialized: false,
        appInitialized: false
      };
      initializePage2 = async (newUrl) => {
        const defaultContext = {
          pageTitle: "",
          metaData: {},
          themeName: "",
          langName: "",
          globalStyles: /* @__PURE__ */ new Map(),
          globalStyleIds: /* @__PURE__ */ new Map(),
          coreData: {},
          // for core development
          devData: {}
          // for secondary development
        };
        bindRequestContext(() => defaultContext);
        const currentPageInitialized = _initSaved.pageInitialized;
        _initSaved.pageInitialized = true;
        logger2.log("initializePage: ", newUrl);
        if (newUrl) {
          window.history.pushState({ urlPath: newUrl }, "", newUrl);
        }
        const splitUrl = newUrl ? newUrl.split("?") : [];
        const url = splitUrl[0] || document.location.pathname;
        const queryString = splitUrl[1] || document.location.search;
        const props = {
          url,
          // urlSections: url.split('/').filter((i) => !!i),
          query: Object.fromEntries(new URLSearchParams(queryString)),
          // new URLSearchParams(queryString),
          urlParameters: {},
          renderPageFunctions: _lupineJs.renderPageFunctions
        };
        setRenderPageProps(props);
        !currentPageInitialized && callPageLoadedEvent();
        const jsxNodes = await renderTargetPage(props, currentPageInitialized);
        if (jsxNodes === null) return;
        if (!jsxNodes || !jsxNodes.props) {
          document.querySelector(".lupine-root").innerHTML = `Error happened or unexpected url: ${url}`;
          return;
        }
        await mountInnerComponent(".lupine-root", jsxNodes);
        updateTheme(getCurrentTheme().themeName);
        document.title = getPageTitle();
        const metaData = getMetaDataObject();
      };
      _lupineJs.initializePage = initializePage2;
      initializeApp = () => {
        if (isFrontEnd2()) {
          if (_initSaved.appInitialized) return;
          _initSaved.appInitialized = true;
          addEventListener("popstate", (event) => {
            initializePage2();
          });
          addEventListener("load", (event) => {
            let redirect = new URLSearchParams(window.location.search).get("redirect");
            if (!redirect) {
              redirect = new URLSearchParams(window.location.hash.substring(1)).get("redirect");
            }
            initializePage2(redirect || void 0);
          });
        }
        if (typeof globalThis !== "undefined") {
          const gThis = globalThis;
          if (gThis._lupineJs === null) {
            gThis._lupineJs = () => {
              return _lupineJs;
            };
          }
        }
      };
    }
  });

  // node_modules/lupine.web/src/core/index.ts
  var init_core = __esm({
    "node_modules/lupine.web/src/core/index.ts"() {
      init_bind_attributes();
      init_bind_lang();
      init_bind_links();
      init_bind_meta();
      init_bind_ref();
      init_bind_styles();
      init_bind_theme();
      init_export_lupine();
      init_camel_to_hyphens();
      init_mount_component();
      init_page_loaded_event();
      init_page_router();
      init_render_component();
      init_replace_innerhtml();
      init_server_cookie();
      init_use_request_context();
      init_initialize();
    }
  });

  // node_modules/lupine.web/src/models/json-props.ts
  var init_json_props = __esm({
    "node_modules/lupine.web/src/models/json-props.ts"() {
    }
  });

  // node_modules/lupine.web/src/models/simple-storage-props.ts
  var init_simple_storage_props = __esm({
    "node_modules/lupine.web/src/models/simple-storage-props.ts"() {
    }
  });

  // node_modules/lupine.web/src/models/theme-props.ts
  var init_theme_props = __esm({
    "node_modules/lupine.web/src/models/theme-props.ts"() {
    }
  });

  // node_modules/lupine.web/src/models/to-client-delivery-props.ts
  var init_to_client_delivery_props = __esm({
    "node_modules/lupine.web/src/models/to-client-delivery-props.ts"() {
    }
  });

  // node_modules/lupine.web/src/models/use-request-context-props.ts
  var init_use_request_context_props = __esm({
    "node_modules/lupine.web/src/models/use-request-context-props.ts"() {
    }
  });

  // node_modules/lupine.web/src/models/index.ts
  var init_models = __esm({
    "node_modules/lupine.web/src/models/index.ts"() {
      init_json_props();
      init_simple_storage_props();
      init_theme_props();
      init_to_client_delivery_props();
      init_use_request_context_props();
    }
  });

  // node_modules/lupine.web/src/styles/css-styles.ts
  var init_css_styles = __esm({
    "node_modules/lupine.web/src/styles/css-styles.ts"() {
    }
  });

  // node_modules/lupine.web/src/styles/index.ts
  var init_styles = __esm({
    "node_modules/lupine.web/src/styles/index.ts"() {
      init_css_styles();
    }
  });

  // node_modules/lupine.web/src/index.ts
  var init_src = __esm({
    "node_modules/lupine.web/src/index.ts"() {
      init_jsx();
      init_core();
      init_lib();
      init_models();
      init_styles();
    }
  });

  // node_modules/lupine.components/src/lib/back-action-helper.ts
  var backActionUniqueId, BackActionHelper, backActionHelper;
  var init_back_action_helper = __esm({
    "node_modules/lupine.components/src/lib/back-action-helper.ts"() {
      init_src();
      backActionUniqueId = uniqueIdGenerator("bb-");
      BackActionHelper = class {
        backFn;
        genBackActionId() {
          return backActionUniqueId();
        }
        getAllBackActionButtons() {
          const nodes = document.querySelectorAll('[data-back-action^="bb-"]');
          const buttons = Array.from(nodes).map((el) => {
            const act = el.getAttribute("data-back-action") || "";
            return { el, ind: act.substring(3) };
          }).filter(Boolean).sort((a, b) => b.ind.localeCompare(a.ind)).map((item) => item.el);
          return buttons;
        }
        clear() {
          this.backFn = void 0;
        }
        attach(back) {
          this.backFn = back;
        }
        async processBackAction() {
          if (this.backFn) {
            try {
              await this.backFn();
              this.clear();
              return true;
            } catch (e) {
              console.error("back button back failed", e);
            }
            return false;
          }
          const buttons = this.getAllBackActionButtons();
          if (buttons.length) {
            const button = buttons[0];
            button.dispatchEvent(new Event("click"));
            return true;
          }
          return false;
        }
      };
      backActionHelper = /* @__PURE__ */ new BackActionHelper();
    }
  });

  // node_modules/lupine.components/src/lib/base62.ts
  var Base62;
  var init_base62 = __esm({
    "node_modules/lupine.components/src/lib/base62.ts"() {
      Base62 = class _Base62 {
        static ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        static BASE = 62;
        static toString(num) {
          if (num === 0) return _Base62.ALPHABET[0];
          let result = "";
          while (num > 0) {
            const rem = num % _Base62.BASE;
            result = _Base62.ALPHABET[rem] + result;
            num = Math.floor(num / _Base62.BASE);
          }
          return result;
        }
        static fromString(str2) {
          let result = 0;
          for (let i = 0; i < str2.length; i++) {
            result = result * _Base62.BASE + _Base62.ALPHABET.indexOf(str2[i]);
          }
          return result;
        }
      };
    }
  });

  // node_modules/lupine.components/src/lib/blob-utils.ts
  var blobToBase64, blobFromBase64, base64ToUrl;
  var init_blob_utils = __esm({
    "node_modules/lupine.components/src/lib/blob-utils.ts"() {
      blobToBase64 = (blob, removeMeta) => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => resolve(removeMeta ? reader.result.split(",")[1] : reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      };
      blobFromBase64 = (base64) => {
        const [header, base64Data] = base64.split(",");
        const mimeMatch = header.match(/data:(.*);base64/);
        const mimeType = mimeMatch ? mimeMatch[1] : "application/octet-stream";
        const byteCharacters = atob(base64Data);
        const byteNumbers = Array.from(byteCharacters).map((c) => c.charCodeAt(0));
        const byteArray = new Uint8Array(byteNumbers);
        return new Blob([byteArray], { type: mimeType });
      };
      base64ToUrl = (base64) => {
        const blob = blobFromBase64(base64);
        return URL.createObjectURL(blob);
      };
    }
  });

  // node_modules/lupine.components/src/lib/calculate-text-width.ts
  function calculateTextWidth(text, font) {
    let canvas = calculateTextWidthSaved.canvas || (calculateTextWidthSaved.canvas = document.createElement("canvas"));
    let context = canvas.getContext("2d");
    context.font = font;
    let metrics = context.measureText(text);
    return metrics.width;
  }
  var calculateTextWidthSaved;
  var init_calculate_text_width = __esm({
    "node_modules/lupine.components/src/lib/calculate-text-width.ts"() {
      calculateTextWidthSaved = { canvas: null };
    }
  });

  // node_modules/lupine.components/src/lib/date-utils.ts
  var DateUtils, DiffDate;
  var init_date_utils = __esm({
    "node_modules/lupine.components/src/lib/date-utils.ts"() {
      DateUtils = class _DateUtils {
        /*
         * returns the number of milliseconds elapsed since January 1, 1970 00:00:00 UTC.
         */
        static now() {
          return Date.now();
        }
        // Date time string format: YYYY-MM-DDTHH:mm:ss.sssZ
        // The string that you want to parse into a Date should match this format or a portion of this format.
        // The T character separates the date from the time portion of the string. The Z character is the UTC offset representation.
        static toDate(str2) {
          return new Date(Date.parse(str2));
        }
        static clone(dt) {
          return new Date(dt.valueOf());
        }
        static isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
        static daysInMonth(year, month) {
          return month === 1 ? _DateUtils.isLeapYear(year) ? 29 : 28 : 31 - month % 7 % 2;
        }
        static createDate(year, monthIndex, date, hours, minutes, seconds, ms) {
          const dt = new Date(year, monthIndex, date, hours, minutes, seconds, ms);
          return dt;
        }
        // It returns the number of milliseconds since January 1, 1970, 00:00:00 UTC instead of local (regardless of which time zone you are in).
        static createUTCDate(year, monthIndex, date, hours, minutes, seconds, ms) {
          const dt = new Date(Date.UTC.apply(null, [year, monthIndex, date, hours, minutes, seconds, ms]));
          return dt;
        }
        static set(dt, year, monthIndex, date, hours, minutes, seconds, ms) {
          if (!dt) {
            dt = new Date(_DateUtils.now());
          }
          if (typeof year === "number") {
            dt.setFullYear(year);
          }
          if (typeof monthIndex === "number") {
            dt.setMonth(monthIndex);
          }
          if (typeof date === "number") {
            dt.setDate(date);
          }
          if (typeof hours === "number") {
            dt.setHours(hours);
          }
          if (typeof minutes === "number") {
            dt.setMinutes(minutes);
          }
          if (typeof seconds === "number") {
            dt.setSeconds(seconds);
          }
          if (typeof ms === "number") {
            dt.setMilliseconds(ms);
          }
          return dt;
        }
        static add(dt, year, monthCount, date, hours, minutes, seconds, ms) {
          if (!dt) {
            dt = new Date(_DateUtils.now());
          }
          if (typeof year === "number") {
            dt.setFullYear(dt.getFullYear() + year);
          }
          if (typeof monthCount === "number") {
            dt.setMonth(dt.getMonth() + monthCount);
          }
          if (typeof date === "number") {
            dt.setDate(dt.getDate() + date);
          }
          if (typeof hours === "number") {
            dt.setHours(dt.getHours() + hours);
          }
          if (typeof minutes === "number") {
            dt.setMinutes(dt.getMinutes() + minutes);
          }
          if (typeof seconds === "number") {
            dt.setSeconds(dt.getSeconds() + seconds);
          }
          if (typeof ms === "number") {
            dt.setMilliseconds(dt.getMilliseconds() + ms);
          }
          return dt;
        }
        // returns a difference object from two dates
        static diff(endDate, startDate) {
          const startYear = startDate.getFullYear();
          let yearDiff = endDate.getFullYear() - startYear;
          let monthDiff = endDate.getMonth() - startDate.getMonth();
          if (monthDiff < 0) {
            yearDiff--;
            monthDiff += 12;
          }
          let dayDiff = endDate.getDate() - startDate.getDate();
          if (dayDiff < 0) {
            if (monthDiff > 0) {
              monthDiff--;
            } else {
              yearDiff--;
              monthDiff = 11;
            }
            dayDiff += _DateUtils.daysInMonth(startYear, startDate.getMonth());
          }
          const msTotal = endDate.valueOf() - startDate.valueOf();
          const secondTotal = Math.floor(msTotal / 1e3);
          const hourDiff = Math.floor(secondTotal / (60 * 60)) % 24;
          const minuteDiff = Math.floor(secondTotal / 60) % 60;
          const secondDiff = secondTotal % 60;
          const msDiff = msTotal % 1e3;
          return new DiffDate(yearDiff, monthDiff, dayDiff, hourDiff, minuteDiff, secondDiff, msDiff);
        }
        // returns a time difference string from two dates
        static diffString(endDate, startDate, printMS = false) {
          const diff = _DateUtils.diff(endDate, startDate);
          let ret = "";
          if (diff.years !== 0) {
            ret = ret + diff.years + " years(s), ";
          }
          if (diff.years !== 0 || diff.months !== 0) {
            ret = ret + diff.months + " month(s), ";
          }
          if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0) {
            ret = ret + diff.days + " day(s), ";
          }
          if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0 || diff.hours !== 0) {
            ret = ret + diff.hours + " hour(s), ";
          }
          if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0 || diff.hours !== 0 || diff.minutes !== 0) {
            ret = ret + diff.minutes + " minute(s), ";
          }
          if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0 || diff.hours !== 0 || diff.minutes !== 0 || diff.seconds !== 0 || !printMS) {
            ret = ret + diff.seconds + " second(s)";
            if (printMS) {
              ret += ", ";
            }
          }
          if (printMS) {
            ret = ret + diff.milliseconds + " ms";
          }
          return ret;
        }
        // returns a YYYYMMDD format string
        static toYMD(dt, separator) {
          separator = typeof separator === "undefined" ? "-" : separator;
          return dt.getFullYear() + separator + ("0" + (dt.getMonth() + 1)).toString().slice(-2) + separator + ("0" + dt.getDate()).toString().slice(-2);
        }
        static toYmdHms(dt, separator) {
          separator = typeof separator === "undefined" ? "-" : separator;
          return dt.getFullYear() + separator + ("0" + (dt.getMonth() + 1)).toString().slice(-2) + separator + ("0" + dt.getDate()).toString().slice(-2) + " " + ("0" + dt.getHours()).toString().slice(-2) + ":" + ("0" + dt.getMinutes()).toString().slice(-2) + ":" + ("0" + dt.getSeconds()).toString().slice(-2);
        }
        static toJSONString(dt) {
          return dt.toJSON();
        }
        static showJSONString(dt, separator = "-") {
          return _DateUtils.toYmdHms(_DateUtils.toDate(dt), separator);
        }
        static fromJSONString(dt) {
          return _DateUtils.toDate(dt);
        }
        static clearTime(dt) {
          dt.setHours(0);
          dt.setMinutes(0);
          dt.setSeconds(0);
          dt.setMilliseconds(0);
          return dt;
        }
        static clearUTCTime(dt) {
          dt.setUTCHours(0);
          dt.setUTCMinutes(0);
          dt.setUTCSeconds(0);
          dt.setUTCMilliseconds(0);
          return dt;
        }
        static format(dt, fmt) {
          if (!fmt) {
            fmt = "YYYY-MM-DD";
          }
          if (!dt) {
            dt = /* @__PURE__ */ new Date();
          }
          const parts = {
            YYYY: dt.getFullYear().toString(),
            YY: ("00" + (dt.getFullYear() - 100)).toString().slice(-2),
            MM: ("0" + (dt.getMonth() + 1)).toString().slice(-2),
            M: (dt.getMonth() + 1).toString(),
            DD: ("0" + dt.getDate()).toString().slice(-2),
            D: dt.getDate().toString(),
            hh: ("0" + dt.getHours()).toString().slice(-2),
            h: dt.getHours().toString(),
            mm: ("0" + dt.getMinutes()).toString().slice(-2),
            ss: ("0" + dt.getSeconds()).toString().slice(-2),
            SSS: ("00" + dt.getMilliseconds()).toString().slice(-3),
            S: Math.floor(dt.getMilliseconds() / 100).toString().slice(-1)
          };
          const array = fmt.match(/(\[[^\[]*\])|(\\)?(YYYY|YY|MM?|DD?|hh?|mm?|ss?|SSS|S|.)/g);
          for (let i = 0, length = array.length; i < length; i++) {
            if (parts[array[i]]) {
              array[i] = parts[array[i]];
            }
          }
          const ret = array.join("");
          return ret;
        }
      };
      DiffDate = class {
        years;
        months;
        days;
        hours;
        minutes;
        seconds;
        milliseconds;
        constructor(years, months, days, hours, minutes, seconds, milliseconds) {
          this.years = years;
          this.months = months;
          this.days = days;
          this.hours = hours;
          this.minutes = minutes;
          this.seconds = seconds;
          this.milliseconds = milliseconds;
        }
      };
    }
  });

  // node_modules/lupine.components/src/lib/deep-merge.ts
  var needMerge, deepMerge, cloneJson;
  var init_deep_merge = __esm({
    "node_modules/lupine.components/src/lib/deep-merge.ts"() {
      needMerge = (item) => {
        return item && typeof item === "object" && !Array.isArray(item);
      };
      deepMerge = (target, ...sources) => {
        if (!sources.length) return target;
        const source = sources.shift();
        if (needMerge(target) && needMerge(source)) {
          for (const key in source) {
            if (needMerge(source[key])) {
              if (!target[key]) Object.assign(target, { [key]: {} });
              deepMerge(target[key], source[key]);
            } else {
              Object.assign(target, { [key]: source[key] });
            }
          }
        }
        return deepMerge(target, ...sources);
      };
      cloneJson = (json) => {
        return JSON.parse(JSON.stringify(json));
      };
    }
  });

  // node_modules/lupine.components/src/lib/disable-console.ts
  var disableConsole;
  var init_disable_console = __esm({
    "node_modules/lupine.components/src/lib/disable-console.ts"() {
      disableConsole = (skipFlagKey = "skip_console_protection") => {
        try {
          if (localStorage.getItem(skipFlagKey) === "1") return;
          var c = window.console;
          if (!c) return;
          var voidFn = function() {
          };
          ["log", "warn", "info", "error", "debug", "table", "trace"].forEach((k) => {
            c[k] = voidFn;
          });
        } catch (e) {
        }
      };
    }
  });

  // node_modules/lupine.components/src/lib/disable-debug.ts
  var disableDebug;
  var init_disable_debug = __esm({
    "node_modules/lupine.components/src/lib/disable-debug.ts"() {
      disableDebug = (skipFlagKey = "skip_debug_protection", debugInterval = 2e3) => {
        try {
          if (localStorage.getItem(skipFlagKey) === "1") return;
          setInterval(() => {
            debugger;
          }, debugInterval);
        } catch (e) {
        }
      };
    }
  });

  // node_modules/lupine.components/src/lib/document-ready.ts
  var DocumentReady;
  var init_document_ready = __esm({
    "node_modules/lupine.components/src/lib/document-ready.ts"() {
      DocumentReady = class {
        constructor() {
        }
        // code is from https://code.jquery.com/jquery-1.12.4.js
        // for document only (not for elements)
        ready(fn) {
          if (document.readyState === "complete") {
            setTimeout(fn, 0);
          } else {
            const completed = function() {
              if (document.readyState === "complete") {
                document.removeEventListener("DOMContentLoaded", completed);
                window.removeEventListener("load", completed);
                setTimeout(fn, 0);
              }
            };
            document.addEventListener("DOMContentLoaded", completed);
            window.addEventListener("load", completed);
          }
        }
        readyPromise() {
          return new Promise((resolve, reject) => {
            this.ready(() => {
              resolve();
            });
          });
        }
      };
    }
  });

  // node_modules/lupine.components/src/lib/dom-utils.ts
  var DomUtils;
  var init_dom_utils = __esm({
    "node_modules/lupine.components/src/lib/dom-utils.ts"() {
      DomUtils = class {
        static getValue(cssSelector) {
          var _a;
          return (_a = document.querySelector(cssSelector)) == null ? void 0 : _a.value;
        }
        static setValue(cssSelector, value) {
          const dom = document.querySelector(cssSelector);
          if (dom) dom.value = value;
        }
        static getChecked(cssSelector) {
          var _a;
          return (_a = document.querySelector(cssSelector)) == null ? void 0 : _a.checked;
        }
        static setChecked(cssSelector, checked) {
          const dom = document.querySelector(cssSelector);
          if (dom) dom.checked = checked;
        }
        static joinValues(values, joinChar = " ") {
          return values.filter(Boolean).join(joinChar);
        }
        static byId(id) {
          return document.querySelector(`#${id}`);
        }
        static bySelector(selector) {
          return document.querySelector(selector);
        }
      };
    }
  });

  // node_modules/lupine.components/src/lib/download-file.ts
  var _saveChunkSize, setDownloadChunkSize, getDownloadChunkSize, downloadFileChunk, downloadFile;
  var init_download_file = __esm({
    "node_modules/lupine.components/src/lib/download-file.ts"() {
      init_src2();
      init_src();
      _saveChunkSize = {
        downloadSize: 1024 * 200
      };
      setDownloadChunkSize = (chunkSize) => {
        _saveChunkSize.downloadSize = chunkSize;
      };
      getDownloadChunkSize = () => {
        return _saveChunkSize.downloadSize;
      };
      downloadFileChunk = async (downloadUrl, rangeStart, rangeLength, retryCount = 3, retryMessage = "") => {
        let url = downloadUrl + (downloadUrl.indexOf("?") === -1 ? "?" : "");
        url += `&start=${rangeStart.toString()}`;
        url += `&length=${rangeLength.toString()}`;
        let tryCount = 0;
        while (tryCount < retryCount) {
          try {
            const rawData = await getRenderPageProps().renderPageFunctions.fetchData(
              url,
              void 0,
              true,
              true
            );
            const fileSize = rawData.headers.get("file-size");
            const partSize = rawData.headers.get("part-size");
            if (!fileSize || !partSize) {
              console.log(`downloadFileChunk error`, rawData);
              return null;
            }
            return {
              fileSize: parseInt(fileSize, 10),
              partSize: parseInt(partSize, 10),
              arrayBuffer: await rawData.arrayBuffer()
            };
          } catch (error) {
            console.log(`downloadFileChunk error, try: ${tryCount}`, error);
          }
          tryCount++;
          if (retryMessage) {
            NotificationMessage.sendMessage(
              retryMessage.replace("${tryCount}", tryCount.toString()),
              "var(--warning-bg-color)" /* Warning */
            );
          }
        }
        return null;
      };
      downloadFile = async (downloadUrl, processResponse, chunkSize = 0, retryCount = 3, retryMessage = "Downloading failed, try: ${tryCount}") => {
        if (chunkSize < 1) {
          chunkSize = _saveChunkSize.downloadSize;
        }
        let downloadSize = 0;
        let expectedFileSize = null;
        while (true) {
          const start = downloadSize;
          const length = chunkSize;
          const downloadResult = await downloadFileChunk(downloadUrl, start, length, retryCount, retryMessage);
          if (!downloadResult) {
            return false;
          }
          if (expectedFileSize === null) {
            expectedFileSize = downloadResult.fileSize;
          }
          downloadSize += downloadResult.partSize;
          const result = processResponse(downloadResult);
          if (result !== void 0) {
            return result;
          }
          if (downloadSize >= expectedFileSize) {
            break;
          }
        }
        return true;
      };
    }
  });

  // node_modules/lupine.components/src/lib/download-link.ts
  var downloadLink;
  var init_download_link = __esm({
    "node_modules/lupine.components/src/lib/download-link.ts"() {
      downloadLink = (link2, filename) => {
        const dom = document.createElement("a");
        dom.setAttribute("href", link2);
        dom.setAttribute("download", filename || "true");
        dom.style.display = "none";
        document.body.appendChild(dom);
        dom.click();
        setTimeout(() => {
          document.body.removeChild(dom);
        }, 3e3);
        return dom;
      };
    }
  });

  // node_modules/lupine.components/src/lib/download-stream.ts
  var downloadStream;
  var init_download_stream = __esm({
    "node_modules/lupine.components/src/lib/download-stream.ts"() {
      downloadStream = (blob, filename) => {
        const blobUrl = URL.createObjectURL(blob);
        const dom = document.createElement("a");
        dom.setAttribute("href", blobUrl);
        dom.setAttribute("download", filename || "true");
        dom.style.display = "none";
        document.body.appendChild(dom);
        dom.click();
        setTimeout(() => {
          document.body.removeChild(dom);
          URL.revokeObjectURL(blobUrl);
        }, 3e3);
        return dom;
      };
    }
  });

  // node_modules/lupine.components/src/lib/drag-util.ts
  var createDragUtil;
  var init_drag_util = __esm({
    "node_modules/lupine.components/src/lib/drag-util.ts"() {
      createDragUtil = () => {
        let isDragging = false;
        let initialX = 0;
        let initialY = 0;
        let draggingDom = null;
        let onMoveCallback = () => {
        };
        let onMoveEndCallback = () => {
        };
        let onScaleCallback = () => {
        };
        let isZooming = false;
        let initialDistance = 0;
        const getDistance = (t1, t2) => {
          const dx = t2.clientX - t1.clientX;
          const dy = t2.clientY - t1.clientY;
          return Math.sqrt(dx * dx + dy * dy);
        };
        const onMoveEnd = () => {
          onMoveEndCallback();
          isDragging = false;
          isZooming = false;
          draggingDom = null;
        };
        return {
          setOnMoveCallback: (callback) => {
            onMoveCallback = callback;
          },
          setOnMoveEndCallback: (callback) => {
            onMoveEndCallback = callback;
          },
          setOnScaleCallback: (callback) => {
            onScaleCallback = callback;
          },
          getDistance,
          getDraggingDom: () => draggingDom,
          onMouseDown: (event) => {
            event.preventDefault();
            if (event.buttons !== 1) {
              isDragging = false;
              draggingDom = null;
              return;
            }
            isDragging = true;
            isZooming = false;
            draggingDom = event.currentTarget;
            initialX = event.clientX;
            initialY = event.clientY;
          },
          onMouseMove: (event) => {
            if (event.buttons === 0 && isDragging) {
              onMoveEnd();
            }
            if (event.buttons === 0 || !draggingDom) {
              isDragging = false;
              draggingDom = null;
              return;
            }
            onMoveCallback(event.clientX, event.clientY, event.clientX - initialX, event.clientY - initialY);
          },
          onMouseUp: onMoveEnd,
          onTouchStart: (event) => {
            if (event.touches.length === 1) {
              isDragging = true;
              isZooming = false;
              draggingDom = event.currentTarget;
              initialX = event.touches[0].clientX;
              initialY = event.touches[0].clientY;
            } else if (event.touches.length === 2) {
              initialDistance = getDistance(event.touches[0], event.touches[1]);
              isDragging = false;
              isZooming = true;
            } else {
              isDragging = false;
              draggingDom = null;
            }
          },
          onTouchMove: (event) => {
            if (isZooming) {
              if (event.touches.length === 2) {
                event.preventDefault();
                const newDistance = getDistance(event.touches[0], event.touches[1]);
                const delta = newDistance / initialDistance;
                onScaleCallback(delta);
              } else {
                onMoveEnd();
              }
              return;
            }
            if (event.touches.length === 0 && isDragging) {
              onMoveEnd();
            }
            if (event.touches.length === 0 || !draggingDom) {
              isDragging = false;
              draggingDom = null;
              return;
            }
            onMoveCallback(
              event.touches[0].clientX,
              event.touches[0].clientY,
              event.touches[0].clientX - initialX,
              event.touches[0].clientY - initialY
            );
          },
          onTouchEnd: onMoveEnd
        };
      };
    }
  });

  // node_modules/lupine.components/src/lib/dynamical-load.ts
  var DynamicalLoad;
  var init_dynamical_load = __esm({
    "node_modules/lupine.components/src/lib/dynamical-load.ts"() {
      DynamicalLoad = class {
        static loadScript(url, idForReplace, removeOnLoaded = false) {
          return new Promise((resolve, reject) => {
            if (this.existScript(url, idForReplace)) {
              resolve(url);
              return;
            }
            const scriptDom = document.createElement("script");
            scriptDom.src = url;
            if (idForReplace) {
              scriptDom.id = idForReplace;
            }
            scriptDom.onload = () => {
              resolve(url);
              if (removeOnLoaded) {
                scriptDom.remove();
              }
            };
            scriptDom.onerror = () => {
              reject(new Error("Failed to load module script with URL " + url));
              if (removeOnLoaded) {
                scriptDom.remove();
              }
            };
            const head = document.getElementsByTagName("head")[0];
            head ? head.appendChild(scriptDom) : document.documentElement.appendChild(scriptDom);
          });
        }
        // TODO: more accuracy
        static existScript(url, id) {
          if (id) {
            const scriptDom = document.getElementById(id);
            if (scriptDom && scriptDom.tagName === "SCRIPT") {
              const src = scriptDom.src.split("?")[0];
              if (src.substring(src.length - url.length) === url) {
                return true;
              }
            }
          }
          const scripts = document.scripts;
          for (let i = 0; i < scripts.length; i++) {
            const src = scripts[i].src.split("?")[0];
            if (src.substring(src.length - url.length) === url) {
              return true;
            }
          }
        }
        static loadCss(url, idForReplace) {
          return new Promise((resolve, reject) => {
            if (this.existCss(url, idForReplace)) {
              resolve(url);
              return;
            }
            if (idForReplace) {
              const sheet = document.getElementById(idForReplace);
              if (sheet && sheet.tagName === "LINK") {
                sheet.parentNode.removeChild(sheet);
              }
            }
            const linkDom = document.createElement("link");
            linkDom.rel = "stylesheet";
            linkDom.type = "text/css";
            linkDom.href = url;
            linkDom.media = "all";
            if (idForReplace) {
              linkDom.id = idForReplace;
            }
            linkDom.onload = () => {
              resolve(url);
            };
            linkDom.onerror = () => {
              reject(new Error("Failed to load css with URL " + url));
            };
            document.getElementsByTagName("head")[0].appendChild(linkDom);
          });
        }
        // TODO: more accuracy
        static existCss(url, id) {
          if (id) {
            const linkDom = document.getElementById(id);
            if (linkDom && linkDom.tagName === "LINK") {
              const href = linkDom.href.split("?")[0];
              if (href.substring(href.length - url.length) === url) {
                return true;
              }
            }
          }
          const styles = document.styleSheets;
          for (let i = 0; i < styles.length; i++) {
            const linkDom = styles[i];
            const href = linkDom.href.split("?")[0];
            if (href.substring(href.length - url.length) === url) {
              return true;
            }
          }
        }
        // removeCss(url: string, id?: string) {
        //     if (id) {
        //         const sheet = document.getElementById(id);
        //         if (sheet && sheet instanceof HTMLElement) {
        //             const href = (<any>sheet).href;
        //             if (href.substring(href.length - url.length) === url) {
        //                 (<any>sheet).disabled = true;
        //                 sheet.parentNode.removeChild(sheet);
        //                 return;
        //             }
        //         }
        //     }
        //     const styles = document.styleSheets;
        //     for (const i = 0; i < styles.length; i++) {
        //         const sheet = styles[i] as any;
        //         if (sheet.href.substring(sheet.href.length - url.length) === url) {
        //             sheet.disabled = true;
        //             sheet.ownerNode.parentNode.removeChild(sheet.ownerNode);
        //             return;
        //         }
        //     }
        // }
      };
    }
  });

  // node_modules/lupine.components/src/lib/encode-html.ts
  var htmlEscapes, encodeHtml, htmlUnescapes, decodeHtml;
  var init_encode_html = __esm({
    "node_modules/lupine.components/src/lib/encode-html.ts"() {
      htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "'": "&#39;",
        '"': "&quot;"
      };
      encodeHtml = (str2) => {
        return str2.replace(/[&<>'"]/g, (tag2) => htmlEscapes[tag2]);
      };
      htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&#39;": "'",
        "&quot;": '"'
      };
      decodeHtml = (str2) => {
        return str2.replace(/&(?:amp|lt|gt|quot|#39);/g, (tag2) => htmlUnescapes[tag2]);
      };
    }
  });

  // node_modules/lupine.components/src/lib/find-parent-tag.ts
  var findParentTag;
  var init_find_parent_tag = __esm({
    "node_modules/lupine.components/src/lib/find-parent-tag.ts"() {
      findParentTag = (dom, tag2) => {
        const tagUpper = tag2.toUpperCase();
        let parent = dom.parentElement;
        while (parent && parent.tagName !== tagUpper && parent.tagName !== "BODY") {
          parent = parent.parentElement;
        }
        return parent;
      };
    }
  });

  // node_modules/lupine.components/src/lib/format-bytes.ts
  var formatBytes;
  var init_format_bytes = __esm({
    "node_modules/lupine.components/src/lib/format-bytes.ts"() {
      formatBytes = (bytes, decimals = 2) => {
        if (!+bytes) return "0 Bytes";
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ["Bytes", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
      };
    }
  });

  // node_modules/lupine.components/src/lib/lite-dom.ts
  var LiteDom;
  var init_lite_dom = __esm({
    "node_modules/lupine.components/src/lib/lite-dom.ts"() {
      LiteDom = class _LiteDom {
        node;
        static queryOne(selector, docRoot) {
          if (!selector) {
            return null;
          }
          if (selector instanceof _LiteDom) {
            return selector;
          }
          if (selector instanceof Element) {
            return new _LiteDom(selector);
          }
          const el = (docRoot || document).querySelector(selector);
          return el ? new _LiteDom(el) : null;
        }
        static queryAll(selector, docRoot) {
          if (!selector) {
            return [];
          }
          if (selector instanceof _LiteDom) {
            return [selector];
          }
          if (selector instanceof Element) {
            return [new _LiteDom(selector)];
          }
          const el = (docRoot || document).querySelectorAll(selector);
          const ret = [];
          for (let i in el) {
            ret.push(new _LiteDom(el[i]));
          }
          return ret;
        }
        static createElement(html2, docRoot) {
          const dom = (docRoot || document).createElement(html2);
          const domLib = new _LiteDom(dom);
          return domLib;
        }
        constructor(selector, docRoot) {
          if (selector instanceof _LiteDom) {
            this.node = selector.node;
          } else if (selector instanceof Element) {
            this.node = selector;
          } else {
            const el = selector && (docRoot || document).querySelector(selector);
            if (el) {
              this.node = el;
            } else {
              throw new TypeError("Element is not defined for a new LibDom");
            }
          }
        }
        getElement() {
          return this.node;
        }
        // query children and set value or innerHTML
        $(selector, value) {
          const dom = _LiteDom.queryOne(selector, this.node);
          if (dom && typeof value !== "undefined") {
            if ("checked" in dom.node) {
              dom.node.checked = !!value;
            } else if ("value" in dom.node) {
              dom.node.value = value;
            } else if ("innerHTML" in dom.node) {
              dom.node.innerHTML = "" + value;
            }
          }
          return dom;
        }
        // query children
        query(selector) {
          return _LiteDom.queryOne(selector, this.node);
        }
        // query children
        queryAll(selector) {
          return _LiteDom.queryAll(selector, this.node);
        }
        on(eventName, eventHandler) {
          this.node.addEventListener(eventName, eventHandler, false);
          return this;
        }
        off(eventName, eventHandler) {
          this.node.removeEventListener(eventName, eventHandler, false);
          return this;
        }
        fire(event) {
          this.node.dispatchEvent(event);
          return this;
        }
        isCheckbox() {
          return this.tagName === "INPUT" && this.node.type === "checkbox";
        }
        isRadio() {
          return this.tagName === "INPUT" && this.node.type === "radio";
        }
        val(value) {
          if (typeof value === "undefined") {
            return this.node.value;
          }
          "value" in this.node && (this.node.value = value);
          return this;
        }
        checked(value) {
          if (typeof value === "undefined") {
            return this.node.checked;
          }
          "checked" in this.node && (this.node.checked = !!value);
          return this;
        }
        selectedIndex(value) {
          if (typeof value === "undefined") {
            return this.node.selectedIndex;
          }
          "selectedIndex" in this.node && (this.node.selectedIndex = value);
          return this;
        }
        html(value) {
          if (typeof value === "undefined") {
            return this.node.innerHTML;
          }
          "innerHTML" in this.node && (this.node.innerHTML = value);
          return this;
        }
        /*
            element.style.backgroundColor = 'blue' // works
            element.style['backgroundColor'] = 'blue' // works
            element.style['background-color'] = 'blue' // does not work
        
            element.style.setProperty('background-color','blue') // works
            element.style.setProperty('backgroundColor','blue') // does not work
          */
        css(propertyName, value) {
          if (typeof value === "undefined") {
            return this.node instanceof HTMLElement && this.node.style.getPropertyValue(propertyName);
          }
          if (this.node instanceof HTMLElement) {
            if (value === null) {
              this.node.style.removeProperty(propertyName);
            } else {
              this.node.style.setProperty(propertyName, value);
            }
          }
          return this;
        }
        attribute(attributeName, value) {
          if (typeof value === "undefined") {
            return this.node.getAttribute(attributeName);
          }
          if (value === null) {
            this.node.removeAttribute(attributeName);
          } else {
            this.node.setAttribute(attributeName, value);
          }
          return this;
        }
        class(addClass, removeClass) {
          if (!addClass && !removeClass) {
            return this.node.className;
          }
          const classList = this.node.classList;
          if (addClass) {
            addClass instanceof Array ? classList.add(...addClass) : classList.add(addClass);
          }
          if (removeClass) {
            removeClass instanceof Array ? classList.remove(...removeClass) : classList.remove(removeClass);
          }
          return this;
        }
        appendChild(child) {
          const dom = child instanceof _LiteDom ? child.getElement() : child;
          dom && this.node.appendChild(dom);
          return this;
        }
        removeChild(child) {
          const dom = child instanceof _LiteDom ? child.getElement() : child;
          dom && this.node.removeChild(dom);
          return this;
        }
        removeSelf() {
          this.node.remove();
          return this;
        }
        get children() {
          if (!this.node.children) {
            return [];
          }
          const ret = [];
          for (let i = 0; i < this.node.children.length; i++) {
            ret.push(new _LiteDom(this.node.children[i]));
          }
          return ret;
        }
        // originally returns the HTML-uppercased qualified name.
        get tagName() {
          return this.node.tagName.toUpperCase();
        }
      };
    }
  });

  // node_modules/lupine.components/src/lib/message-hub.ts
  var MessageHubData, MessageHub;
  var init_message_hub = __esm({
    "node_modules/lupine.components/src/lib/message-hub.ts"() {
      MessageHubData = class {
        constructor(actionId, message, extraData) {
          this.actionId = actionId;
          this.message = message;
          this.extraData = extraData;
        }
      };
      MessageHub = class {
        constructor(passLastMsgWhenSubscribe = false) {
          this.passLastMsgWhenSubscribe = passLastMsgWhenSubscribe;
        }
        subscriptions = {};
        subscriptionValues = {};
        lastId = 0;
        // * for listening to all events
        subscribe(targetType, fn, recessiveLassMsg = true) {
          const id = this.lastId++;
          if (!this.subscriptions[targetType]) {
            this.subscriptions[targetType] = {};
          }
          this.subscriptions[targetType][id] = fn;
          if (recessiveLassMsg && this.passLastMsgWhenSubscribe && this.subscriptionValues[targetType]) {
            this.notify(fn, this.subscriptionValues[targetType]);
          }
          return () => {
            delete this.subscriptions[targetType][id];
            var needDestroy = true;
            for (var key in this.subscriptions[targetType]) {
              needDestroy = false;
              break;
            }
            if (needDestroy) {
              delete this.subscriptions[targetType];
            }
          };
        }
        send(targetType, arg) {
          if (targetType === "*") {
            for (var groupKey in this.subscriptions) {
              for (var key in this.subscriptions[groupKey]) {
                this.notify(this.subscriptions[groupKey][key], arg);
              }
            }
            return;
          }
          if (this.passLastMsgWhenSubscribe) {
            this.subscriptionValues[targetType] = arg;
          }
          if (this.subscriptions[targetType]) {
            for (var key in this.subscriptions[targetType]) {
              this.notify(this.subscriptions[targetType][key], arg);
            }
          }
          if (this.subscriptions["*"]) {
            for (var key in this.subscriptions["*"]) {
              this.notify(this.subscriptions["*"][key], arg);
            }
          }
        }
        hasListener(targetType) {
          if (targetType === "*") {
            for (var groupKey in this.subscriptions) {
              return true;
            }
          } else {
            for (var groupKey in this.subscriptions[targetType]) {
              return true;
            }
          }
          return false;
        }
        notify(fn, arg) {
          setTimeout(() => {
            fn(arg);
          }, 0);
        }
      };
    }
  });

  // node_modules/lupine.components/src/lib/observable.ts
  var Subscription, Observable, Subject;
  var init_observable = __esm({
    "node_modules/lupine.components/src/lib/observable.ts"() {
      Subscription = class {
        _unsubscribe;
        constructor(unsubscribe) {
          this._unsubscribe = unsubscribe;
        }
        unsubscribe() {
          if (this._unsubscribe) {
            this._unsubscribe();
          }
        }
      };
      Observable = class {
        constructor() {
        }
        subscribe(next, error, complete) {
          throw new Error("subscribe is not implemented");
        }
      };
      Subject = class extends Observable {
        observers = [];
        isStopped = false;
        _hasError = false;
        passLastMsgWhenSubscribe;
        lastSaved = {};
        constructor(passLastMsgWhenSubscribe = false) {
          super();
          this.passLastMsgWhenSubscribe = passLastMsgWhenSubscribe;
        }
        next(value) {
          if (this.isStopped) {
            throw new Error("Subject is closed");
          }
          const len = this.observers.length;
          const copy = this.observers.slice();
          for (let i = 0; i < len; i++) {
            const item = copy[i].next;
            if (typeof item !== "undefined" && typeof value !== "undefined") {
              item(value);
            }
          }
          if (this.passLastMsgWhenSubscribe) {
            if (typeof value !== "undefined") {
              this.lastSaved["value"] = value;
            }
          }
        }
        error(err) {
          if (this.isStopped) {
            throw new Error("Subject is closed");
          }
          this._hasError = true;
          this.isStopped = true;
          const len = this.observers.length;
          const copy = this.observers.slice();
          for (let i = 0; i < len; i++) {
            const item = copy[i].error;
            if (typeof item !== "undefined" && typeof err !== "undefined") {
              item(err);
            }
          }
          this.observers.length = 0;
        }
        complete() {
          if (this.isStopped) {
            throw new Error("Subject is closed");
          }
          this.isStopped = true;
          const copy = this.observers.slice();
          const len = copy.length;
          for (let i = 0; i < len; i++) {
            const item = copy[i].complete;
            if (typeof item !== "undefined") {
              item();
            }
          }
          if (this.observers.length != len) {
            console.warn(`Subscribe count changed from ${len} to ${this.observers.length}`);
          }
          this.observers.length = 0;
        }
        hasError() {
          return this._hasError;
        }
        unsubscribe(observer) {
          const index = this.observers.findIndex((item) => item === observer);
          if (index > -1) {
            this.observers.splice(index, 1);
          }
        }
        subscribe(next, error, complete) {
          if (this.isStopped) {
            throw new Error("Subject is stopped");
          }
          const observer = {
            next,
            error,
            complete
          };
          this.observers.push(observer);
          if (this.passLastMsgWhenSubscribe) {
            if (typeof observer.next !== "undefined" && typeof this.lastSaved["value"] !== "undefined") {
              observer.next(this.lastSaved["value"]);
            }
          }
          const ret = new Subscription(() => {
            this.unsubscribe(observer);
          });
          return ret;
        }
        asObservable() {
          return this;
        }
      };
    }
  });

  // node_modules/lupine.components/src/lib/path-utils.ts
  var pathUtils;
  var init_path_utils = __esm({
    "node_modules/lupine.components/src/lib/path-utils.ts"() {
      pathUtils = {
        join(...parts) {
          var _a;
          let joined = parts.filter(Boolean).join("/");
          joined = joined.replace(/\/+/g, "/");
          const isAbsolute = (_a = parts[0]) == null ? void 0 : _a.startsWith("/");
          return isAbsolute ? "/" + joined.replace(/^\/+/, "") : joined.replace(/^\/+/, "");
        },
        dirname(p) {
          if (!p) return ".";
          p = p.replace(/\/+$/, "");
          const idx = p.lastIndexOf("/");
          if (idx === -1) return ".";
          if (idx === 0) return "/";
          return p.slice(0, idx);
        },
        // get filename, remove ext if exists
        basename(p, ext) {
          if (!p) return "";
          p = p.replace(/\/+$/, "");
          const idx = p.lastIndexOf("/");
          let base = idx === -1 ? p : p.slice(idx + 1);
          if (!ext) {
            const lastPot = p.lastIndexOf(".");
            if (lastPot >= 0) {
              base = base.slice(0, lastPot);
            }
          } else if (ext && base.endsWith(ext)) {
            base = base.slice(0, -ext.length);
          }
          return base;
        },
        // .hidden's ext is empty (Node.js behavior)
        extname(p) {
          if (!p) return "";
          const base = pathUtils.basename(p);
          const idx = base.lastIndexOf(".");
          return idx > 0 ? base.slice(idx) : "";
        }
      };
    }
  });

  // node_modules/lupine.components/src/lib/promise-timeout.ts
  var promiseTimeout;
  var init_promise_timeout = __esm({
    "node_modules/lupine.components/src/lib/promise-timeout.ts"() {
      promiseTimeout = (delayMs) => new Promise((resolve) => setTimeout(resolve, delayMs));
    }
  });

  // node_modules/lupine.components/src/lib/simple-storage.ts
  var SimpleStorage;
  var init_simple_storage = __esm({
    "node_modules/lupine.components/src/lib/simple-storage.ts"() {
      SimpleStorage = class {
        settings = {};
        constructor(settings) {
          this.settings = settings;
        }
        contains(key) {
          return key in this.settings;
        }
        set(key, value) {
          return this.settings[key] = value;
        }
        get(key, defaultValue) {
          return key in this.settings ? this.settings[key] : defaultValue;
        }
        getInt(key, defaultValue) {
          if (key in this.settings) {
            const i = parseInt(this.settings[key]);
            if (!isNaN(i)) {
              return i;
            }
          }
          return defaultValue;
        }
        getBoolean(key, defaultValue) {
          return key in this.settings ? this.settings[key] === "1" || this.settings[key].toLowerCase() === "true" : defaultValue;
        }
        getJson(key, defaultValue) {
          if (key in this.settings) {
            try {
              return JSON.parse(this.settings[key]);
            } catch (error) {
            }
          }
          return defaultValue;
        }
      };
    }
  });

  // node_modules/lupine.components/src/lib/stop-propagation.ts
  var stopPropagation;
  var init_stop_propagation = __esm({
    "node_modules/lupine.components/src/lib/stop-propagation.ts"() {
      stopPropagation = (event) => {
        if (!event) return;
        if (event.stopPropagation) event.stopPropagation();
        if (event.preventDefault) event.preventDefault();
        event.cancelBubble = true;
        event.returnValue = false;
      };
    }
  });

  // node_modules/lupine.components/src/components/notice-message.tsx
  var NotificationColor, notificationColorFromValue, NotificationMessage;
  var init_notice_message = __esm({
    "node_modules/lupine.components/src/components/notice-message.tsx"() {
      init_src();
      NotificationColor = /* @__PURE__ */ ((NotificationColor2) => {
        NotificationColor2["Success"] = "var(--success-bg-color)";
        NotificationColor2["Info"] = "var(--info-bg-color)";
        NotificationColor2["Warning"] = "var(--warning-bg-color)";
        NotificationColor2["Error"] = "var(--error-bg-color)";
        return NotificationColor2;
      })(NotificationColor || {});
      notificationColorFromValue = (value) => {
        switch (value) {
          case "Success":
            return "var(--success-bg-color)" /* Success */;
          case "Info":
            return "var(--info-bg-color)" /* Info */;
          case "Warning":
            return "var(--warning-bg-color)" /* Warning */;
          case "Error":
            return "var(--error-bg-color)" /* Error */;
        }
        return "var(--info-bg-color)" /* Info */;
      };
      NotificationMessage = class {
        // public static readonly Color = NotificationColor;
        static initialized = false;
        static container;
        static init() {
          const css2 = {
            position: "fixed",
            top: 0,
            right: 0,
            height: "auto",
            overflowY: "auto",
            maxHeight: "100%",
            width: "100%",
            maxWidth: "400px",
            // cursor: 'pointer',
            // backgroundColor: '#fefefe',
            padding: "0 10px",
            zIndex: "var(--layer-notice)",
            // borderRadius: '6px',
            // boxShadow: '0px 0px 2px #000',
            ">div": {
              color: "var(--notice-color-with-bg)",
              padding: "10px 8px",
              margin: "16px 0",
              borderRadius: "6px",
              boxShadow: "var(--cover-box-shadow)",
              //'3px 3px 8px #767676',
              transition: "all 0.5s",
              transform: "scale(0.1)",
              opacity: 0
            },
            ".close-btn": {
              position: "absolute",
              top: "-2px",
              right: "3px",
              color: "var(--notice-color-with-bg)",
              fontWeight: "bold",
              fontSize: "22px",
              lineHeight: "20px",
              cursor: "pointer",
              transition: "0.3s"
            },
            ".close-btn:hover": {
              color: "black"
            }
          };
          bindGlobalStyle("lj_notification", css2);
          let container = document.querySelector(".lj_notification");
          if (!container) {
            container = document.createElement("div");
            container.className = "lj_notification";
            document.body.appendChild(container);
            this.container = container;
          }
        }
        static sendMessage(message, backgroundColor = "var(--info-bg-color)" /* Info */, permanent = false, showTime = 3e3) {
          if (!this.initialized) {
            this.initialized = true;
            this.init();
          }
          this.container.scrollTop = 0;
          const div = document.createElement("div");
          div.innerHTML = message;
          div.style.backgroundColor = backgroundColor;
          this.container.insertBefore(div, this.container.firstChild);
          setTimeout(() => {
            div.style.opacity = "1";
            div.style.transform = "scale(1)";
          }, 0);
          if (permanent) {
            const closeBtn = document.createElement("span");
            closeBtn.innerHTML = "&times;";
            closeBtn.className = "close-btn";
            div.appendChild(closeBtn);
            closeBtn.onclick = () => {
              this.container.removeChild(div);
            };
          } else {
            setTimeout(() => {
              div.style.opacity = "0";
              div.style.transform = "scale(0.1)";
              setTimeout(() => {
                this.container.removeChild(div);
              }, 1e3);
            }, showTime);
          }
        }
      };
    }
  });

  // node_modules/lupine.web/jsx-runtime/index.js
  function jsx(type, props) {
    return { type, props };
  }
  function Fragment(props) {
    return { type: "Fragment", props };
  }
  var init_jsx_runtime = __esm({
    "node_modules/lupine.web/jsx-runtime/index.js"() {
    }
  });

  // node_modules/lupine.components/src/components/action-sheet.tsx
  var ActionSheet, ActionSheetSelectOptionsProps, ActionSheetSelect, ActionSheetMessage, ActionSheetMessagePromise, ActionSheetInput, ActionSheetInputPromise, ActionSheetSelectPromise, ActionSheetMultiSelectPromise;
  var init_action_sheet = __esm({
    "node_modules/lupine.components/src/components/action-sheet.tsx"() {
      init_src();
      init_lib2();
      init_notice_message();
      init_jsx_runtime();
      ActionSheet = class {
        static hostNode;
        static async show({
          title,
          children,
          contentMaxWidth,
          contentMaxHeight,
          closeEvent,
          closeWhenClickOutside = true,
          confirmButtonText = "",
          handleConfirmClicked,
          cancelButtonText = "Cancel",
          zIndex,
          buttonsPosition = "bottom"
        }) {
          const onConfirm = () => {
            if (handleConfirmClicked) {
              handleConfirmClicked(handleClose);
            } else {
              handleClose("confirm");
            }
          };
          const onCancel = () => {
            handleClose("cancel");
          };
          const onClickContainer = (event) => {
            if (closeWhenClickOutside !== false && event.target.classList.contains("act-sheet-box")) {
              handleClose("cancel");
            }
          };
          const handleClose = (reason) => {
            closeEvent == null ? void 0 : closeEvent(reason);
            ref.current.classList.remove("animation-open");
            setTimeout(() => {
              base.remove();
            }, 300);
          };
          const base = document.createElement("div");
          const ref = {
            onLoad: async () => {
              setTimeout(() => {
                ref.current.classList.add("animation-open");
              }, 1);
            }
          };
          const cssContainer = {
            position: "fixed",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            backgroundColor: "var(--cover-mask-bg-color)",
            ".act-sheet-body": {
              display: "flex",
              flexDirection: "column",
              textAlign: "center",
              position: "fixed",
              bottom: "0px",
              left: "0px",
              width: "100%",
              maxHeight: contentMaxHeight ? contentMaxHeight : "100%",
              color: "var(--primary-color)",
              padding: "8px",
              transition: "all 0.3s",
              transform: "translateY(100%)",
              "&.animation-open": {
                transform: "translateY(0)"
              },
              ".act-sheet-title": {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "flex-end",
                width: "100%",
                ".t": { padding: "12px 15px 12px 15px" },
                ".btn": { display: "flex", gap: "4px" },
                ".act-sheet-header-item": {
                  border: "none",
                  background: "transparent",
                  fontSize: "12px",
                  fontWeight: "bold",
                  cursor: "pointer",
                  padding: "4px 8px",
                  borderRadius: "6px"
                }
              },
              ".act-sheet-content": {
                display: "flex",
                flexDirection: "column",
                flex: 1,
                overflowY: "auto",
                borderRadius: "8px",
                backgroundColor: "var(--cover-bg-color)",
                //'#fefefe',
                width: "100%",
                maxWidth: contentMaxWidth ? contentMaxWidth : `clamp(200px, 90%, 600px)`,
                margin: "0 auto"
              },
              ".act-sheet-bottom-item, .act-sheet-item": {
                backgroundColor: "var(--cover-bg-color)",
                //'#fefefe',
                padding: "20px 0",
                cursor: "pointer",
                transition: "all 0.3s ease",
                width: "100%",
                maxWidth: contentMaxWidth ? contentMaxWidth : `clamp(200px, 90%, 600px)`,
                borderTop: "1px solid var(--primary-border-color)"
              },
              ".act-sheet-bottom-item": {
                borderRadius: "8px",
                margin: "0 auto",
                marginTop: "4px"
              },
              ".act-sheet-bottom-item:hover, .act-sheet-item:hover": {
                fontWeight: "bold"
              },
              ".act-sheet-confirm, .act-sheet-item": {
                borderRadius: "unset",
                marginTop: "unset",
                maxWidth: "unset"
              }
            }
          };
          const component = /* @__PURE__ */ jsx(
            "div",
            {
              css: cssContainer,
              class: "act-sheet-box",
              onClick: onClickContainer,
              "data-back-action": backActionHelper.genBackActionId(),
              children: /* @__PURE__ */ jsx("div", { ref, class: "act-sheet-body", children: [
                /* @__PURE__ */ jsx("div", { class: "act-sheet-content", children: [
                  /* @__PURE__ */ jsx("div", { class: "act-sheet-title", children: [
                    /* @__PURE__ */ jsx("span", { class: "t", children: title }),
                    /* @__PURE__ */ jsx("div", { class: "btn", children: [
                      buttonsPosition === "header" && cancelButtonText && /* @__PURE__ */ jsx("div", { class: "act-sheet-header-item", onClick: onCancel, children: cancelButtonText }),
                      buttonsPosition === "header" && confirmButtonText && /* @__PURE__ */ jsx("div", { class: "act-sheet-header-item", onClick: onConfirm, children: confirmButtonText })
                    ] })
                  ] }),
                  children,
                  buttonsPosition === "bottom" && confirmButtonText && /* @__PURE__ */ jsx("div", { class: "act-sheet-bottom-item act-sheet-confirm", onClick: onConfirm, children: confirmButtonText })
                ] }),
                buttonsPosition === "bottom" && cancelButtonText && /* @__PURE__ */ jsx("div", { class: "act-sheet-bottom-item", onClick: onCancel, children: cancelButtonText })
              ] })
            }
          );
          base.style.position = "fixed";
          base.style.zIndex = zIndex || "var(--layer-actionsheet-window)";
          document.body.appendChild(base);
          await mountInnerComponent(base, component);
          return handleClose;
        }
      };
      ActionSheetSelectOptionsProps = {
        YesNo: ["Yes", "No"],
        Ok: ["OK"]
      };
      ActionSheetSelect = class {
        static async show({
          title,
          contentMaxHeight,
          options: options3 = ActionSheetSelectOptionsProps.Ok,
          closeEvent,
          handleClicked,
          closeWhenClickOutside = true,
          confirmButtonText,
          handleConfirmClicked,
          cancelButtonText = "Cancel"
        }) {
          const handleClose = await ActionSheet.show({
            title,
            children: /* @__PURE__ */ jsx("div", { children: options3.map((option, index) => /* @__PURE__ */ jsx("div", { class: "act-sheet-item", onClick: () => handleClicked(index, handleClose), children: option }, index)) }),
            contentMaxHeight,
            confirmButtonText,
            handleConfirmClicked,
            cancelButtonText,
            closeEvent,
            closeWhenClickOutside
          });
          return handleClose;
        }
      };
      ActionSheetMessage = class {
        static async show({
          title,
          message,
          contentMaxWidth,
          contentMaxHeight,
          closeWhenClickOutside = true,
          confirmButtonText,
          handleConfirmClicked,
          cancelButtonText = ""
        }) {
          const handleClose = await ActionSheet.show({
            title,
            children: /* @__PURE__ */ jsx(
              "div",
              {
                css: { padding: "8px", borderTop: "1px solid var(--primary-border-color)" },
                onClick: () => handleClose("select"),
                children: message
              }
            ),
            contentMaxWidth,
            contentMaxHeight,
            confirmButtonText,
            handleConfirmClicked,
            cancelButtonText,
            closeWhenClickOutside
          });
          return handleClose;
        }
      };
      ActionSheetMessagePromise = async ({
        title,
        message,
        contentMaxWidth,
        contentMaxHeight,
        closeWhenClickOutside = true,
        confirmButtonText,
        zIndex
      }) => {
        return new Promise(async (resolve, reject) => {
          const closeEvent = (reason) => {
            resolve();
          };
          await ActionSheet.show({
            title,
            children: /* @__PURE__ */ jsx("div", { css: { padding: "8px", borderTop: "1px solid var(--primary-border-color)" }, children: message }),
            contentMaxWidth,
            contentMaxHeight,
            confirmButtonText,
            closeEvent,
            closeWhenClickOutside,
            zIndex
          });
        });
      };
      ActionSheetInput = class {
        static async show({
          title,
          defaultValue,
          contentMaxHeight,
          closeWhenClickOutside = true,
          confirmButtonText = "OK",
          handleConfirmValue,
          cancelButtonText = "Cancel"
        }) {
          let value = defaultValue || "";
          const handleClose = await ActionSheet.show({
            title,
            children: /* @__PURE__ */ jsx("div", { css: { padding: "8px", borderTop: "1px solid var(--primary-border-color)" }, children: /* @__PURE__ */ jsx(
              "input",
              {
                class: "input-base w-100p",
                type: "text",
                value,
                onInput: (e) => value = e.target.value
              }
            ) }),
            contentMaxHeight,
            confirmButtonText,
            handleConfirmClicked: (close) => {
              handleConfirmValue(value, close);
            },
            cancelButtonText,
            closeWhenClickOutside
          });
          return handleClose;
        }
      };
      ActionSheetInputPromise = async ({
        title,
        defaultValue,
        contentMaxWidth,
        contentMaxHeight,
        closeWhenClickOutside = true,
        confirmButtonText = "OK",
        cancelButtonText = "Cancel",
        zIndex
      }) => {
        return new Promise(async (resolve, reject) => {
          const closeEvent = (reason) => {
            if (reason !== "confirm") {
              resolve(void 0);
            }
          };
          let value = defaultValue || "";
          await ActionSheet.show({
            title,
            children: /* @__PURE__ */ jsx("div", { css: { padding: "8px", borderTop: "1px solid var(--primary-border-color)" }, children: /* @__PURE__ */ jsx(
              "input",
              {
                class: "input-base w-100p",
                type: "text",
                value,
                onInput: (e) => value = e.target.value
              }
            ) }),
            contentMaxWidth,
            contentMaxHeight,
            confirmButtonText,
            handleConfirmClicked: (close) => {
              resolve(value);
              close("confirm");
            },
            closeEvent,
            cancelButtonText,
            closeWhenClickOutside,
            zIndex
          });
        });
      };
      ActionSheetSelectPromise = async ({
        title,
        contentMaxWidth,
        contentMaxHeight,
        options: options3 = ActionSheetSelectOptionsProps.Ok,
        closeWhenClickOutside = true,
        cancelButtonText = "Cancel",
        zIndex
      }) => {
        return new Promise(async (resolve, reject) => {
          const handleClicked = async (index, close) => {
            resolve(index);
            close("select");
          };
          const closeEvent = (reason) => {
            if (reason !== "select") {
              resolve(-1);
            }
          };
          const handleClose = await ActionSheet.show({
            title,
            children: /* @__PURE__ */ jsx("div", { children: options3.map((option, index) => /* @__PURE__ */ jsx("div", { class: "act-sheet-item", onClick: () => handleClicked(index, handleClose), children: option }, index)) }),
            contentMaxWidth,
            contentMaxHeight,
            cancelButtonText,
            closeEvent,
            closeWhenClickOutside,
            zIndex
          });
        });
      };
      ActionSheetMultiSelectPromise = async ({
        title,
        contentMaxWidth,
        contentMaxHeight,
        options: options3,
        initialSelected = [],
        maxCount,
        align = "center",
        closeWhenClickOutside = true,
        confirmButtonText = "Confirm",
        cancelButtonText = "Cancel",
        zIndex,
        maxCountMessage = "Max count reached"
      }) => {
        return new Promise(async (resolve) => {
          const selected = new Set(initialSelected);
          const itemRefs = options3.map(() => ({}));
          const toggleOption = (index) => {
            if (selected.has(index)) {
              selected.delete(index);
              if (itemRefs[index].current) {
                itemRefs[index].current.classList.remove("selected");
              }
            } else {
              if (maxCount !== void 0 && selected.size >= maxCount) {
                NotificationMessage.sendMessage(maxCountMessage, "var(--error-bg-color)" /* Error */);
                return;
              }
              selected.add(index);
              if (itemRefs[index].current) {
                itemRefs[index].current.classList.add("selected");
              }
            }
          };
          const closeEvent = (reason) => {
            if (reason !== "confirm") {
              resolve([...initialSelected]);
            }
          };
          const alignMap = {
            left: "flex-start",
            center: "center",
            right: "flex-end"
          };
          const css2 = {
            ".act-sheet-item.row-box": {
              cursor: "pointer",
              justifyContent: alignMap[align],
              paddingRight: "36px",
              // reserve space for checkmark
              paddingLeft: "16px",
              position: "relative"
            },
            ".checkmark": {
              position: "absolute",
              right: "16px",
              color: "var(--primary-color)",
              opacity: "0",
              transition: "opacity 0.2s",
              fontSize: "18px"
            },
            ".act-sheet-item.selected .checkmark": {
              opacity: "1"
            },
            ".act-sheet-item.selected": {
              color: "var(--primary-color)",
              fontWeight: "bold",
              backgroundColor: "var(--primary-bg-color-hover, rgba(0,0,0,0.04))"
            }
          };
          const handleClose = await ActionSheet.show({
            title,
            children: /* @__PURE__ */ jsx("div", { css: css2, children: options3.map((option, index) => /* @__PURE__ */ jsx(
              "div",
              {
                ref: itemRefs[index],
                class: ["act-sheet-item row-box", selected.has(index) ? "selected" : ""].join(" "),
                onClick: () => toggleOption(index),
                children: [
                  /* @__PURE__ */ jsx("span", { children: option }),
                  /* @__PURE__ */ jsx("span", { class: "checkmark", children: "\u2713" })
                ]
              }
            )) }),
            contentMaxWidth,
            contentMaxHeight,
            confirmButtonText,
            handleConfirmClicked: (close) => {
              resolve(Array.from(selected).sort((a, b) => a - b));
              close("confirm");
            },
            cancelButtonText,
            closeEvent,
            closeWhenClickOutside,
            zIndex,
            buttonsPosition: "header"
          });
        });
      };
    }
  });

  // node_modules/lupine.components/src/components/button-push-animation.tsx
  var ButtonPushAnimationSize, ButtonPushAnimation;
  var init_button_push_animation = __esm({
    "node_modules/lupine.components/src/components/button-push-animation.tsx"() {
      init_jsx_runtime();
      ButtonPushAnimationSize = /* @__PURE__ */ ((ButtonPushAnimationSize2) => {
        ButtonPushAnimationSize2["SmallSmall"] = "button-ss";
        ButtonPushAnimationSize2["Small"] = "button-s";
        ButtonPushAnimationSize2["Medium"] = "button-m";
        ButtonPushAnimationSize2["Large"] = "button-l";
        ButtonPushAnimationSize2["LargeLarge"] = "button-ll";
        return ButtonPushAnimationSize2;
      })(ButtonPushAnimationSize || {});
      ButtonPushAnimation = (props) => {
        let disabled = props.disabled || false;
        const onClick = () => {
          if (disabled) {
            return;
          }
          if (props.onClick) {
            props.onClick();
          }
        };
        if (props.hook) {
          props.hook.setEnabled = (enabled) => {
            disabled = !enabled;
            ref.current.disabled = disabled;
          };
          props.hook.getEnabled = () => {
            return !disabled;
          };
        }
        const ref = {};
        const css2 = {
          all: "unset",
          cursor: "pointer",
          "-webkit-tap-highlight-color": "rgba(0, 0, 0, 0)",
          position: "relative",
          borderRadius: "var(--border-radius-m)",
          backgroundColor: "rgba(0, 0, 0, 0.75)",
          boxShadow: "-0.15em -0.15em 0.15em -0.075em rgba(5, 5, 5, 0.25), 0.0375em 0.0375em 0.0675em 0 rgba(5, 5, 5, 0.1)",
          ".button-outer": {
            position: "relative",
            zIndex: 1,
            borderRadius: "inherit",
            transition: "box-shadow 300ms ease",
            willChange: "box-shadow",
            boxShadow: "0 0.05em 0.05em -0.01em rgba(5, 5, 5, 1), 0 0.01em 0.01em -0.01em rgba(5, 5, 5, 0.5), 0.15em 0.3em 0.1em -0.01em rgba(5, 5, 5, 0.25)"
          },
          ".button-inner": {
            position: "relative",
            zIndex: 2,
            borderRadius: "inherit",
            padding: "var(--button-padding)",
            background: "linear-gradient(135deg, #ffffff, #eeeeee)",
            transition: "box-shadow 300ms ease, background-image 250ms ease, transform 250ms ease;",
            willChange: "box-shadow, background-image, transform",
            overflow: "clip",
            // clipPath: 'inset(0 0 0 0 round 999vw)',
            boxShadow: "0 0 0 0 inset rgba(5, 5, 5, 0.1), -0.05em -0.05em 0.05em 0 inset rgba(5, 5, 5, 0.25), 0 0 0 0 inset rgba(5, 5, 5, 0.1), 0 0 0.05em 0.2em inset rgba(255, 255, 255, 0.25), 0.025em 0.05em 0.1em 0 inset rgba(255, 255, 255, 1), 0.12em 0.12em 0.12em inset rgba(255, 255, 255, 0.25), -0.075em -0.25em 0.25em 0.1em inset rgba(5, 5, 5, 0.25)"
          },
          ".button-inner span": {
            position: "relative",
            zIndex: 4,
            // fontFamily: 'Inter, sans-serif',
            letterSpacing: "-0.05em",
            // fontWeight: 500,
            color: "rgba(0, 0, 0, 0);",
            backgroundImage: "linear-gradient(135deg, rgba(25, 25, 25, 1), rgba(75, 75, 75, 1))",
            backgroundClip: "text",
            transition: "transform 250ms ease",
            display: "block",
            willChange: "transform",
            textShadow: "rgba(0, 0, 0, 0.1) 0 0 0.1em",
            userSelect: "none"
          },
          "&:disabled .button-inner span": {
            backgroundImage: "linear-gradient(135deg, rgba(150, 150, 150, 1), rgba(200, 200, 200, 1))",
            opacity: 0.7
          },
          "&.button-ss": {
            borderRadius: "2px"
          },
          "&.button-s": {
            borderRadius: "3px"
          },
          "&.button-l": {
            borderRadius: "6px"
          },
          "&.button-ll": {
            borderRadius: "10px"
          },
          "&.button-ss .button-inner": {
            padding: "0.1rem 0.3rem",
            fontSize: "0.65rem"
          },
          "&.button-s .button-inner": {
            padding: "0.2rem 0.5rem",
            fontSize: "0.85rem"
          },
          "&.button-l .button-inner": {
            padding: "0.4rem 1.2rem",
            fontSize: "1.5rem"
          },
          "&.button-ll .button-inner": {
            padding: "0.5rem 1.5rem",
            fontSize: "2rem"
          },
          "&:active:not(:disabled) .button-outer": {
            boxShadow: "0 0 0 0 rgba(5, 5, 5, 1), 0 0 0 0 rgba(5, 5, 5, 0.5), 0 0 0 0 rgba(5, 5, 5, 0.25)"
          },
          "&:active:not(:disabled) .button-inner": {
            boxShadow: "0.1em 0.15em 0.05em 0 inset rgba(5, 5, 5, 0.75), -0.025em -0.03em 0.05em 0.025em inset rgba(5, 5, 5, 0.5), 0.25em 0.25em 0.2em 0 inset rgba(5, 5, 5, 0.5), 0 0 0.05em 0.5em inset rgba(255, 255, 255, 0.15), 0 0 0 0 inset rgba(255, 255, 255, 1), 0.12em 0.12em 0.12em inset rgba(255, 255, 255, 0.25), -0.075em -0.12em 0.2em 0.1em inset rgba(5, 5, 5, 0.25)"
          },
          "&:hover:not(:disabled) .button-inner": {
            transform: "scale(0.99)"
          },
          "&:hover:not(:disabled) .button-inner span": {
            transform: "scale(0.975)"
          },
          ...props.css
        };
        return /* @__PURE__ */ jsx(
          "button",
          {
            ref,
            css: css2,
            class: ["button-push-animation", props.size, props.class].join(" "),
            disabled,
            onClick,
            children: /* @__PURE__ */ jsx("div", { class: "button-outer", children: /* @__PURE__ */ jsx("div", { class: "button-inner", children: /* @__PURE__ */ jsx("span", { children: props.text }) }) })
          }
        );
      };
    }
  });

  // node_modules/lupine.components/src/components/button.tsx
  var ButtonSize, Button;
  var init_button = __esm({
    "node_modules/lupine.components/src/components/button.tsx"() {
      init_jsx_runtime();
      ButtonSize = /* @__PURE__ */ ((ButtonSize2) => {
        ButtonSize2["SmallLarge"] = "button-ss";
        ButtonSize2["Small"] = "button-s";
        ButtonSize2["Medium"] = "button-m";
        ButtonSize2["Large"] = "button-l";
        ButtonSize2["LargeLarge"] = "button-ll";
        return ButtonSize2;
      })(ButtonSize || {});
      Button = (props) => {
        let disabled = props.disabled || false;
        const onClick = () => {
          if (disabled) {
            return;
          }
          if (props.onClick) {
            props.onClick();
          }
        };
        if (props.hook) {
          props.hook.setEnabled = (enabled) => {
            disabled = !enabled;
            ref.current.disabled = disabled;
          };
          props.hook.getEnabled = () => {
            return !disabled;
          };
        }
        const ref = {};
        return /* @__PURE__ */ jsx(
          "button",
          {
            ref,
            class: ["button-base", props.size, props.class].join(" "),
            css: props.css,
            disabled,
            onClick,
            children: props.text
          }
        );
      };
    }
  });

  // node_modules/lupine.components/src/components/spinner.tsx
  var SpinnerSize, Spinner01, Spinner02, Spinner03;
  var init_spinner = __esm({
    "node_modules/lupine.components/src/components/spinner.tsx"() {
      init_jsx_runtime();
      SpinnerSize = /* @__PURE__ */ ((SpinnerSize2) => {
        SpinnerSize2["Small"] = "22px";
        SpinnerSize2["Medium"] = "30px";
        SpinnerSize2["Large"] = "40px";
        SpinnerSize2["LargeLarge"] = "60px";
        return SpinnerSize2;
      })(SpinnerSize || {});
      Spinner01 = ({
        size = "30px" /* Medium */,
        color = "var(--primary-color)"
      }) => {
        const borderWidth = size === "22px" /* Small */ || size === "30px" /* Medium */ ? "4px" : size === "40px" /* Large */ ? "6px" : "9px";
        const css2 = {
          width: size,
          aspectRatio: 1,
          borderRadius: "50%",
          background: `radial-gradient(farthest-side,${color} 94%,#0000) top/8px 8px no-repeat, conic-gradient(#0000 30%,${color})`,
          "-webkit-mask": `radial-gradient(farthest-side,#0000 calc(100% - ${borderWidth}),#000 0)`,
          animation: "spinner01 1s infinite linear",
          "@keyframes spinner01": {
            "100%": { transform: "rotate(1turn)" }
          }
        };
        return /* @__PURE__ */ jsx("div", { css: css2 });
      };
      Spinner02 = ({
        size = "30px" /* Medium */,
        color = "var(--primary-color)"
      }) => {
        const base = parseInt(size.replace("px", ""));
        const ballSize = Array.from({ length: 7 }, (_, i) => `${(i * base / 15 / 7).toFixed(2)}px`);
        const css2 = {
          width: size,
          height: size,
          display: "flex",
          placeItems: "center",
          justifyContent: "center",
          ".spinner02-box": {
            "--spin02-w": `${base / 2 - 3}px`,
            width: "4px",
            height: "4px",
            borderRadius: "50%",
            color,
            boxShadow: `
    calc(1*var(--spin02-w))      calc(0*var(--spin02-w))      0 0,
    calc(0.707*var(--spin02-w))  calc(0.707*var(--spin02-w))  0 ${ballSize[1]},
    calc(0*var(--spin02-w))      calc(1*var(--spin02-w))      0 ${ballSize[2]},
    calc(-0.707*var(--spin02-w)) calc(0.707*var(--spin02-w))  0 ${ballSize[3]},
    calc(-1*var(--spin02-w))     calc(0*var(--spin02-w))      0 ${ballSize[4]},
    calc(-0.707*var(--spin02-w)) calc(-0.707*var(--spin02-w)) 0 ${ballSize[5]},
    calc(0*var(--spin02-w))      calc(-1*var(--spin02-w))     0 ${ballSize[6]}`,
            animation: "spinner02 1s infinite steps(8)"
          },
          "@keyframes spinner02": {
            "100%": { transform: "rotate(1turn)" }
          }
        };
        return /* @__PURE__ */ jsx("div", { css: css2, children: /* @__PURE__ */ jsx("div", { class: "spinner02-box" }) });
      };
      Spinner03 = ({
        size = "30px" /* Medium */,
        colorRGB = "55 55 55"
      }) => {
        const css2 = {
          width: size,
          height: size,
          aspectRatio: 1,
          display: "grid",
          borderRadius: "50%",
          background: `linear-gradient(0deg, rgb(${colorRGB} / 50%) 30%, #0000 0 70%, rgb(${colorRGB} / 100%) 0) 50% / 8% 100%, linear-gradient(90deg, rgb(${colorRGB} / 25%) 30%, #0000 0 70%, rgb(${colorRGB} / 75%) 0) 50% / 100% 8%`,
          backgroundRepeat: "no-repeat",
          animation: "spinner03 1s infinite steps(12)",
          "&::before, &::after": {
            content: '""',
            gridArea: "1/1",
            borderRadius: "50%",
            background: "inherit",
            opacity: 0.915,
            transform: "rotate(30deg)"
          },
          "&::after": {
            opacity: 0.83,
            transform: "rotate(60deg)"
          },
          "@keyframes spinner03": {
            "100%": { transform: "rotate(1turn)" }
          }
        };
        return /* @__PURE__ */ jsx("div", { css: css2 });
      };
    }
  });

  // node_modules/lupine.components/src/components/drag-refresh.tsx
  var DragFresh;
  var init_drag_refresh = __esm({
    "node_modules/lupine.components/src/components/drag-refresh.tsx"() {
      init_spinner();
      init_jsx_runtime();
      DragFresh = (props) => {
        const css2 = {
          display: "flex",
          flexDirection: "column",
          width: "100%",
          height: "0px",
          position: "relative",
          ".drag-spinner": {
            position: "fixed",
            top: "0",
            left: "0",
            width: "100%",
            zIndex: "var(--layer-dragged-item)",
            display: "none",
            justifyContent: "center",
            transition: "opacity 0.5s ease",
            alignItems: "end",
            backgroundImage: "linear-gradient(to bottom, rgba(200,200,200,0.8), rgba(255,255,255,0))"
          },
          "&.show .drag-spinner": {
            display: "flex"
          }
        };
        let isEnabled = false;
        if (props.hook) {
          props.hook.setCheckEnabled = (checkEnabled) => {
            props.checkEnabled = checkEnabled;
          };
          props.hook.setOnDragRefresh = (onDragRefresh) => {
            props.onDragRefresh = onDragRefresh;
          };
        }
        const closeSpin = () => {
          const spinnerDom = ref.$(".drag-spinner");
          if (!spinnerDom) return;
          spinnerDom.style.opacity = "0";
          setTimeout(() => {
            spinnerDom.style.opacity = "1";
            spinnerDom.parentElement.classList.remove("show");
          }, 300);
        };
        const ref = {
          onLoad: async () => {
            const container = document.querySelector(props.container);
            const pullDom = ref.current;
            const spinnerDom = ref.$(".drag-spinner");
            if (!container || !pullDom || !spinnerDom) return;
            let touchstartY = 0;
            let touchstartX = 0;
            let direction = "";
            let needRefresh = false;
            const maxHeight = 150;
            container.addEventListener("touchstart", (e) => {
              isEnabled = props.checkEnabled && props.onDragRefresh ? props.checkEnabled() : false;
              if (!isEnabled) return;
              touchstartY = e.touches[0].clientY;
              touchstartX = e.touches[0].clientX;
              direction = "";
              needRefresh = false;
            });
            container.addEventListener("touchmove", (e) => {
              if (!isEnabled) return;
              const touchY = e.touches[0].clientY;
              const touchX = e.touches[0].clientX;
              const movedY = touchY - touchstartY;
              const movedX = touchX - touchstartX;
              if (direction === "") {
                if (Math.abs(movedY) > Math.abs(movedX)) {
                  direction = "Y";
                } else {
                  direction = "X";
                }
              }
              if (direction !== "Y") {
                return;
              }
              if (container.scrollTop <= 0 && movedY > 5) {
                needRefresh = movedY > 60;
                if (movedY > 5) {
                  pullDom.classList.add("show");
                  spinnerDom.style.height = `${Math.min(maxHeight, movedY)}px`;
                } else {
                  pullDom.classList.remove("show");
                  spinnerDom.style.height = "0";
                }
              } else {
                pullDom.classList.remove("show");
                spinnerDom.style.height = "0";
              }
            });
            container.addEventListener("touchend", (e) => {
              var _a;
              if (!isEnabled) return;
              if (direction === "Y") {
                if (needRefresh) {
                  (_a = props.onDragRefresh) == null ? void 0 : _a.call(props, closeSpin);
                } else {
                  closeSpin();
                }
              }
              direction = "";
            });
          }
        };
        return /* @__PURE__ */ jsx("div", { css: css2, ref, class: "drag-refresh-box", children: /* @__PURE__ */ jsx("div", { class: "drag-spinner", children: /* @__PURE__ */ jsx(Spinner02, { size: "40px" /* Large */ }) }) });
      };
    }
  });

  // node_modules/lupine.components/src/components/editable-label.tsx
  var EditableLabel;
  var init_editable_label = __esm({
    "node_modules/lupine.components/src/components/editable-label.tsx"() {
      init_jsx_runtime();
      EditableLabel = (props) => {
        let editFlag = false;
        let oldValue = props.text;
        const onDblClick = () => {
          if (editFlag) return;
          editFlag = true;
          const el = ref.$("input.editable-label");
          oldValue = el.value;
          el.removeAttribute("readonly");
          el.classList.remove("not-editable");
          el.setSelectionRange(0, 0);
        };
        const reset = () => {
          const el = ref.$("input.editable-label");
          el.setAttribute("readonly", "readonly");
          el.classList.add("not-editable");
          oldValue = "";
          editFlag = false;
          return el;
        };
        const onKeyDown = (ev) => {
          if (!editFlag) return;
          if (ev.key === "Enter") {
            onBlur();
          } else if (ev.key === "Escape") {
            const el = ref.$("input.editable-label");
            el.value = oldValue;
            reset();
          }
        };
        const onBlur = () => {
          var _a;
          const savedValue = oldValue;
          const el = reset();
          if (savedValue !== el.value) {
            if (props.mandtory === true && !el.value) {
              el.value = savedValue;
            } else {
              (_a = props.save) == null ? void 0 : _a.call(props, el.value);
            }
          }
        };
        if (props.hook) {
          props.hook.updateValue = (value) => {
            const el = ref.$("input.editable-label");
            el.value = value;
          };
        }
        const css2 = {
          ".not-editable": {
            borderColor: "transparent",
            boxShadow: "unset"
          },
          "input.editable-label": {
            width: "100%"
          }
        };
        const ref = {};
        return /* @__PURE__ */ jsx("div", { css: css2, ref, children: /* @__PURE__ */ jsx(
          "input",
          {
            class: "input-base editable-label not-editable",
            onDblClick,
            onKeyDown,
            value: props.text,
            onBlur,
            readOnly: true
          }
        ) });
      };
    }
  });

  // node_modules/lupine.components/src/components/float-window.tsx
  var FloatWindow;
  var init_float_window = __esm({
    "node_modules/lupine.components/src/components/float-window.tsx"() {
      init_src();
      init_lib2();
      init_jsx_runtime();
      FloatWindow = class _FloatWindow {
        static hostNode;
        static initialized = false;
        static pressed = false;
        static startX = 0;
        static startY = 0;
        static startTop = 0;
        static startLeft = 0;
        static init() {
          window.addEventListener("mousemove", _FloatWindow.onMousemove.bind(_FloatWindow), false);
          document.documentElement.addEventListener("mouseup", _FloatWindow.onMouseup.bind(_FloatWindow), false);
        }
        static async show({
          title,
          children,
          contentMaxHeight,
          contentMinWidth,
          buttons,
          noMoving = false,
          noModal = false,
          closeEvent,
          handleClicked,
          closeWhenClickOutside = false,
          zIndex,
          contentOverflowY = "auto"
          // set to unset for having popup menu inside
        }) {
          const onClickContainer = (event) => {
            if (closeWhenClickOutside !== false && event.target.classList.contains("fwin-box")) {
              handleClose();
            }
          };
          const handleClose = () => {
            closeEvent == null ? void 0 : closeEvent();
            ref.current.classList.add("transition");
            ref.current.classList.remove("animation");
            setTimeout(() => {
              base.remove();
            }, 300);
          };
          const base = document.createElement("div");
          const onMousedown = (event) => {
            if (noMoving) return;
            if (!this.initialized) {
              this.initialized = true;
              this.init();
            }
            _FloatWindow.hostNode = ref.current;
            _FloatWindow.onMousedown.bind(_FloatWindow)(event);
          };
          const newButtons = !buttons || buttons.length === 0 ? ["OK", "Cancel"] : buttons;
          const onClickButtons = (index) => {
            handleClicked(index, handleClose);
          };
          const ref = {
            onLoad: async () => {
              ref.current.classList.add("transition");
              setTimeout(() => {
                ref.current.classList.add("animation");
              }, 1);
              setTimeout(() => {
                ref.current.classList.remove("transition");
              }, 300);
            }
          };
          const cssContainer = {
            position: noModal ? "" : "fixed",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            backgroundColor: noModal ? "" : "var(--cover-mask-bg-color)",
            ".fwin-body": {
              position: "fixed",
              top: "50%",
              left: "50%",
              transform: "translate(-50%, -50%) scale(0.1)",
              color: "var(--primary-color)",
              backgroundColor: "var(--cover-bg-color)",
              //'#fefefe',
              border: "var(--primary-border)",
              //'1px solid #888',
              borderRadius: "6px",
              minWidth: contentMinWidth ? contentMinWidth : "",
              maxWidth: "90%",
              boxShadow: "var(--cover-box-shadow)",
              //'#0000004c 0px 19px 38px, #00000038 0px 15px 12px',
              opacity: 0,
              // zIndex: 'var(--layer-float-window)',
              "&.transition": {
                transition: "all 0.3s"
              },
              "&.animation": {
                transform: "translate(-50%, -50%) scale(1)",
                opacity: 1
              },
              "&.animation-close": {
                transition: "all 0.3s",
                transform: "translate(-50%, -50%) scale(0)",
                opacity: 0
              },
              ".fwin-title": {
                padding: "10px 15px 5px",
                borderBottom: "var(--primary-border)",
                //'1px solid #e9ecef',
                ".fwin-close": {
                  color: "#aaaaaa",
                  float: "right",
                  fontSize: "26px",
                  fontWeight: "bold",
                  cursor: "pointer",
                  marginTop: "-3px",
                  marginRight: "-10px"
                },
                ".fwin-close:hover": {
                  transition: "all 300ms ease",
                  color: "#555555"
                }
              },
              ".fwin-content": {
                padding: "15px",
                maxHeight: contentMaxHeight ? `min(${contentMaxHeight}, calc(100% - 100px))` : "calc(100% - 100px)",
                overflowY: contentOverflowY
              },
              ".fwin-bottom": {
                display: "flex",
                padding: "5px 15px",
                borderTop: "var(--primary-border)",
                //'1px solid #e9ecef',
                justifyContent: "end",
                ">div": {
                  marginLeft: "5px"
                }
              }
            }
          };
          const component = /* @__PURE__ */ jsx("div", { css: cssContainer, class: "fwin-box", onClick: onClickContainer, children: /* @__PURE__ */ jsx("div", { ref, class: "fwin-body", onMouseDown: onMousedown, children: [
            /* @__PURE__ */ jsx("div", { class: "fwin-title", children: [
              title,
              /* @__PURE__ */ jsx("span", { class: "fwin-close", onClick: handleClose, children: "\xD7" })
            ] }),
            /* @__PURE__ */ jsx("div", { class: "fwin-content", children }),
            /* @__PURE__ */ jsx("div", { class: "fwin-bottom", children: newButtons.map((i, index) => /* @__PURE__ */ jsx(
              "button",
              {
                class: "button-base button-s mr-m",
                onClick: () => {
                  onClickButtons(index);
                },
                children: i
              }
            )) })
          ] }) });
          base.style.position = "fixed";
          base.style.zIndex = zIndex || "var(--layer-float-window)";
          document.body.appendChild(base);
          await mountInnerComponent(base, component);
          return handleClose;
        }
        static onMousedown(event) {
          if (event.buttons !== 1 || event.button !== 0) return;
          if (event.srcElement.className !== "fwin-title") return;
          this.pressed = true;
          this.startX = event.clientX;
          this.startY = event.clientY;
          const nodeStyle = document.defaultView.getComputedStyle(this.hostNode);
          this.startTop = parseInt(nodeStyle["top"], 10);
          this.startLeft = parseInt(nodeStyle["left"], 10);
        }
        static onMousemove(event) {
          if (!this.pressed || event.buttons !== 1 || event.button !== 0) {
            return;
          }
          stopPropagation(event);
          if (event.clientX < 0 || event.clientY < 0 || event.clientX > window.innerWidth || event.clientY > window.innerHeight) {
            return;
          }
          let movedX = this.startLeft + (event.clientX - this.startX);
          let movedY = this.startTop + (event.clientY - this.startY);
          if (movedY <= 0) movedY = 0;
          if (movedX <= 0) movedX = 0;
          this.hostNode.style.top = movedY + "px";
          this.hostNode.style.left = movedX + "px";
        }
        static onMouseup() {
          if (this.pressed) this.pressed = false;
        }
      };
    }
  });

  // node_modules/lupine.components/src/components/grid.tsx
  var Grid;
  var init_grid = __esm({
    "node_modules/lupine.components/src/components/grid.tsx"() {
      init_jsx_runtime();
      Grid = ({ gridOption }) => {
        const cssContainer = {
          display: "grid",
          ...gridOption.options
        };
        const cells = [];
        gridOption.cells.forEach((cell, index) => {
          const name = cell.name || "cell" + index;
          cssContainer[`.${name}`] = cell.option;
          cells.push(/* @__PURE__ */ jsx("div", { class: name, children: cell.component }));
        });
        const className = "grid-box" + (gridOption.className ? ` ${gridOption.className}` : "");
        return /* @__PURE__ */ jsx("div", { css: cssContainer, class: className, children: cells });
      };
    }
  });

  // node_modules/lupine.components/src/components/html-load.tsx
  var HtmlLoad;
  var init_html_load = __esm({
    "node_modules/lupine.components/src/components/html-load.tsx"() {
      HtmlLoad = (props) => {
        const ref = {
          onLoad: async (el) => {
            const dom = await props.html();
            await ref.mountInnerComponent(dom);
          }
        };
        if (props.hook) {
          props.hook.getRef = () => ref;
          props.hook.render = (html2) => {
            ref.mountInnerComponent(html2);
          };
        }
        return {
          type: "Fragment",
          props: {
            ref,
            children: props.initialHtml || ""
          },
          html: []
        };
      };
    }
  });

  // node_modules/lupine.components/src/components/html-var.tsx
  var HtmlVar;
  var init_html_var = __esm({
    "node_modules/lupine.components/src/components/html-var.tsx"() {
      HtmlVar = class {
        _value;
        _dirty = false;
        _ref;
        resolve;
        promise;
        constructor(initial) {
          this.promise = new Promise((res) => {
            this.resolve = res;
          });
          this._value = initial || "";
          this._ref = {
            onLoad: async (el) => {
              const res = this.resolve;
              if (this._dirty) {
                await this.update();
              }
              res();
            }
          };
        }
        async update() {
          const v = typeof this._value === "function" ? await this._value() : this._value;
          await this._ref.mountInnerComponent(v);
          this._dirty = false;
          this._value = "";
        }
        // need to wait before use ref.current
        async waitUpdate() {
          await this.promise;
        }
        set value(value) {
          this._value = value;
          if (this._dirty) {
            return;
          }
          this._dirty = true;
          if (!this._ref.current) {
            return;
          }
          this.promise = new Promise(async (res) => {
            this.resolve = res;
            await this.update();
            this.resolve();
          });
        }
        get value() {
          return this._ref.current ? this._ref.current.innerHTML : this._value;
        }
        get ref() {
          return this._ref;
        }
        get node() {
          const delayLoad = typeof this._value === "function";
          this._dirty = delayLoad ? true : false;
          return {
            type: "Fragment",
            props: {
              ref: this._ref,
              children: delayLoad ? "" : this._value
            },
            html: []
          };
        }
      };
    }
  });

  // node_modules/lupine.components/src/components/input-with-title.tsx
  var InputWithTitle;
  var init_input_with_title = __esm({
    "node_modules/lupine.components/src/components/input-with-title.tsx"() {
      init_jsx_runtime();
      InputWithTitle = (title, defaultValue, onInputChanged, onInputInputed, className = "input-base", width = "100%") => {
        return /* @__PURE__ */ jsx("div", { children: [
          /* @__PURE__ */ jsx("div", { style: { paddingBottom: "4px" }, children: title }),
          /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(
            "input",
            {
              class: className,
              style: { width },
              onChange: (e) => {
                var _a;
                return onInputChanged == null ? void 0 : onInputChanged((_a = e == null ? void 0 : e.target) == null ? void 0 : _a.value);
              },
              onInput: (e) => {
                var _a;
                return onInputInputed == null ? void 0 : onInputInputed((_a = e == null ? void 0 : e.target) == null ? void 0 : _a.value);
              },
              value: defaultValue
            }
          ) })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/components/link-item.tsx
  var LinkItem;
  var init_link_item = __esm({
    "node_modules/lupine.components/src/components/link-item.tsx"() {
      init_jsx_runtime();
      LinkItem = (props) => {
        return /* @__PURE__ */ jsx("a", { class: ["link-item", props.className].join(" "), href: props.url, alt: props.alt || props.text, children: props.text });
      };
    }
  });

  // node_modules/lupine.components/src/components/link-list.tsx
  var LinkList;
  var init_link_list = __esm({
    "node_modules/lupine.components/src/components/link-list.tsx"() {
      init_link_item();
      init_jsx_runtime();
      LinkList = ({
        title,
        items,
        className,
        textColor = "black",
        backgroundColor = "#d3d3d3",
        titleBackgroundColor = "#b6b6b6"
      }) => {
        const css2 = {
          width: "100%",
          margin: "auto",
          height: "auto",
          backgroundColor,
          ".link-list-title, .link-list-top": {
            display: "flex",
            width: "100%",
            flexWrap: "wrap",
            padding: "0 16px"
          },
          ".link-list-title": {
            backgroundColor: titleBackgroundColor
          },
          ".link-list-item": {
            display: "inline-block",
            color: textColor,
            padding: "8px 16px 8px 0",
            textDecoration: "none"
          },
          ".link-list-item:last-child": {
            paddingRight: "unset"
          },
          ".link-list-title .link-list-item": {
            fontSize: "18px"
          }
        };
        return /* @__PURE__ */ jsx("div", { css: css2, class: ["link-list-box", className].join(" "), children: [
          title && /* @__PURE__ */ jsx("div", { class: "link-list-title", children: /* @__PURE__ */ jsx("div", { class: "link-list-item", children: title }) }),
          /* @__PURE__ */ jsx("div", { class: "link-list-top", children: items.map((item) => {
            return /* @__PURE__ */ jsx(LinkItem, { className: "link-list-item", url: item.url, alt: item.alt, text: item.text });
          }) })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/styles/media-query.ts
  function adjustedMediaQueryRange(direction, mediaQueryWidth, adjustWidth) {
    const adjustedWidth = Number.parseInt(mediaQueryWidth) + adjustWidth;
    if (direction === 0 /* Below */) {
      return `@media only screen and (max-width: ${adjustedWidth}px)`;
    } else {
      return `@media only screen and (min-width: ${adjustedWidth}px)`;
    }
  }
  var MediaQueryMaxWidth, MediaQueryRange, MediaQueryDirection;
  var init_media_query = __esm({
    "node_modules/lupine.components/src/styles/media-query.ts"() {
      MediaQueryMaxWidth = class _MediaQueryMaxWidth {
        static _ExtraSmall = "480px";
        static _Mobile = "767px";
        // Grid: col-1, 12
        static _Tablet = "991px";
        // Grid: col-1-md, 12-md
        static _Desktop = "1399px";
        // Grid: col-1-lg, 12-lg
        static get ExtraSmallMax() {
          return _MediaQueryMaxWidth._ExtraSmall;
        }
        static get MobileMax() {
          return _MediaQueryMaxWidth._Mobile;
        }
        static get TabletMax() {
          return _MediaQueryMaxWidth._Tablet;
        }
        static get DesktopMax() {
          return _MediaQueryMaxWidth._Desktop;
        }
        static set ExtraSmallMax(value) {
          _MediaQueryMaxWidth._ExtraSmall = value;
        }
        static set MobileMax(value) {
          _MediaQueryMaxWidth._Mobile = value;
        }
        static set TabletMax(value) {
          _MediaQueryMaxWidth._Tablet = value;
        }
        static set DesktopMax(value) {
          _MediaQueryMaxWidth._Desktop = value;
        }
      };
      MediaQueryRange = class {
        static get ExtraSmallBelow() {
          return `@media only screen and (max-width: ${MediaQueryMaxWidth.ExtraSmallMax})`;
        }
        static get ExtraSmallAbove() {
          return `@media only screen and (min-width: ${MediaQueryMaxWidth.ExtraSmallMax})`;
        }
        static get MobileBelow() {
          return `@media only screen and (max-width: ${MediaQueryMaxWidth.MobileMax})`;
        }
        static get MobileAbove() {
          return `@media only screen and (min-width: ${MediaQueryMaxWidth.MobileMax})`;
        }
        static get TabletBelow() {
          return `@media only screen and (max-width: ${MediaQueryMaxWidth.TabletMax})`;
        }
        static get TabletAbove() {
          return `@media only screen and (min-width: ${MediaQueryMaxWidth.TabletMax})`;
        }
        static get DesktopBelow() {
          return `@media only screen and (max-width: ${MediaQueryMaxWidth.DesktopMax})`;
        }
        static get DesktopAbove() {
          return `@media only screen and (min-width: ${MediaQueryMaxWidth.DesktopMax})`;
        }
      };
      MediaQueryDirection = /* @__PURE__ */ ((MediaQueryDirection2) => {
        MediaQueryDirection2[MediaQueryDirection2["Below"] = 0] = "Below";
        MediaQueryDirection2[MediaQueryDirection2["Above"] = 1] = "Above";
        return MediaQueryDirection2;
      })(MediaQueryDirection || {});
    }
  });

  // node_modules/lupine.components/src/styles/shared-themes.ts
  var sharedThemes;
  var init_shared_themes = __esm({
    "node_modules/lupine.components/src/styles/shared-themes.ts"() {
      sharedThemes = {
        // z-index
        "--layer-inside": "100",
        // for inside orders
        "--layer-cover": "200",
        "--layer-header-footer": "300",
        "--layer-sidebar": "400",
        "--layer-sidebar-sub": "410",
        "--layer-slider": "500",
        // screen slider
        "--layer-modal": "600",
        "--layer-modal-over": "610",
        "--layer-float-window": "700",
        "--layer-actionsheet-window": "710",
        "--layer-menu": "800",
        // popup menu
        "--layer-menu-sub": "810",
        "--layer-notice": "900",
        // notice, loading, toast
        "--layer-tooltip": "2000",
        "--layer-dragged-item": "2100",
        "--layer-guide": "2500",
        // learning guide
        "--font-size-base": "16px",
        "--font-weight-base": "",
        //'400',
        "--font-family-base": 'system-ui, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif',
        "--line-height-base": "1.1",
        "--font-size-h1-l": "2.5rem",
        //40px
        "--font-size-h1": "2rem",
        //32px
        "--font-size-h2": "1.5rem",
        //24px
        "--font-size-h3": "1.17rem",
        //18.72px
        "--font-size-h3-5": "1.08rem",
        //17.28px
        "--font-size-h4": "1rem",
        //16px
        "--font-size-h4-5": ".91rem",
        //14.56px
        "--font-size-h5": ".83rem",
        //13.28px
        "--font-size-h6": ".67rem",
        //10.72px
        "--font-size-h6-s": ".55rem",
        //9.28px
        "--font-size-title": "var(--font-size-h2)",
        "--font-size-subtitle": "var(--font-size-h3-5)",
        "--font-size-paragraph": "var(--font-size-h4)",
        "--font-size-paragraph-s": "var(--font-size-h5)",
        "--input-height": "2.2rem",
        "--input-padding": ".3rem .6rem",
        "--button-height": "2.1rem",
        "--button-padding": ".3rem .9rem",
        // space for margin, padding
        "--space-ss": ".15rem",
        "--space-s": ".25rem",
        "--space-m": ".5rem",
        "--space-l": "1rem",
        "--space-ll": "2rem",
        "--border-radius-s": "2px",
        "--border-radius-m": "4px",
        "--border-radius-l": "8px"
      };
    }
  });

  // node_modules/lupine.components/src/styles/dark-themes.ts
  var darkThemes;
  var init_dark_themes = __esm({
    "node_modules/lupine.components/src/styles/dark-themes.ts"() {
      init_shared_themes();
      darkThemes = {
        ...sharedThemes,
        "--theme-name": "dark",
        "--scrollbar-bg": "#1c1c1c",
        "--scrollbar-thumb-bg": "#373636",
        "--scrollbar-active-thumb-bg": "#5b5b5b",
        "--primary-color": "#d8d8d8",
        "--primary-color-disabled": "#7d7d7d",
        "--primary-bg-color": "#000000",
        "--primary-border-color": "#aeaeae",
        "--primary-border": "1px solid var(--primary-border-color)",
        "--primary-opacity": "0.5",
        // used for dark theme
        "--primary-disabled-opacity": "0.7",
        // used for dark theme
        "--primary-accent-color": "#1a588a",
        // used for radio and checkbox's background color
        "--secondary-color": "#747474",
        "--secondary-bg-color": "#1c1c1c",
        "--secondary-border-color": "#494949",
        "--secondary-border": "1px solid var(--secondary-border-color)",
        // including menus, tabs
        "--activatable-color-normal": "var(--primary-color)",
        "--activatable-bg-color-normal": "var(--primary-bg-color)",
        "--activatable-color-hover": "#e2e2e2",
        "--activatable-bg-color-hover": "#6d6d6d",
        "--activatable-color-selected": "#c2c2c2",
        "--activatable-bg-color-selected": "#5d5d5d",
        // '--menu-color-hover': '#303030',
        // '--menu-color': 'var(--primary-color)',  //'#2a2a2a',
        // '--menu-bg-color': 'var(--primary-bg-color)',  //'#2a2a2a',
        // '--menu-bg-color-hover': '#a0a0a0',
        "--menu-font-size": "1rem",
        "--menubar-color": "#eeeeee",
        "--menubar-bg-color": "#000000",
        "--menubar-sub-bg-color": "#f9f9f9",
        "--sidebar-color": "var(--primary-color)",
        "--sidebar-bg-color": "#000000",
        // '--sidebar-sub-color': 'var(--sidebar-color)',
        // '--sidebar-sub-bg-color': '#000000',
        "--sidebar-border": "1px solid #303030",
        // '--sidebar-hover-color': 'var(--sidebar-color)',
        // '--sidebar-hover-bg-color': '#000000',
        "--row-1-bg-color": "#212121",
        "--row-2-bg-color": "#303030",
        "--row-hover-bg-color": "#383838",
        "--success-color": "#04AA6D",
        "--info-color": "#2196F3",
        "--warning-color": "#ff9800",
        "--error-color": "#f44336",
        "--success-bg-color": "#10553b",
        "--info-bg-color": "#1a588a",
        "--warning-bg-color": "#a36305",
        "--error-bg-color": "#882c25",
        "--notice-color-with-bg": "#ececec",
        "--cover-mask-bg-color": "#878a9460",
        "--cover-bg-color": "#202020",
        // for dropdown-menu
        "--cover-box-shadow": "1px 1px 4px #c6c6c6",
        // for big block, deeper shadow arround, good for dark theme
        "--cover-box-shadow-around": "#ffffff 0 0 6px 1px",
        "--input-color": "#bdbdbd",
        "--input-bg-color": "#000000",
        "--input-box-shadow": "0px 0px 0px #000000, 1px 1px 0px 0px #50505045",
        "--input-border-focus": "1px solid #0074d9",
        "--button-color": "#bdbdbd",
        "--button-bg": "-webkit-linear-gradient(top, #282828 0%, #212223 74%, #1a1a1a 100%)",
        // darker
        "--button-bg-hover": "-webkit-linear-gradient(top, #282828 0%, #313233 74%, #252525 100%)",
        // darker
        // '--button-bg': '-webkit-linear-gradient(top, #414141 0%, #373e48 74%, #434242 100%)',
        "--button-border": "1px solid #373e48",
        "--button-box-shadow": "unset",
        "--header-color": "#000080",
        "--header-bg-color": "#000000",
        // for setting-section
        "--ss-group-color": "var(--primary-color)",
        "--ss-group-bg-color": "#232323",
        "--ss-row-btn-color": "#eee",
        "--ss-row-btn-bg-color": "#262626",
        "--ss-row-btn-warn-color": "red",
        "--mobile-header-shadow": "0px -1px 4px 1px #848484"
        // '--background-primary': '#353536', //	Primary background
        // '--color-primary': '#e0e0e0', //	Primary text color
        // backgroundPrimary: '', //	Primary background
        // backgroundOnPrimary: '', //	Background for surfaces on top of primary background
        // backgroundSecondary: '#f5f5f6', //	Secondary background
        // backgroundOnSecondary: '#e5e5e6', //	Background for surfaces on top of secondary background
      };
    }
  });

  // node_modules/lupine.components/src/styles/light-themes.ts
  var lightThemes;
  var init_light_themes = __esm({
    "node_modules/lupine.components/src/styles/light-themes.ts"() {
      init_shared_themes();
      lightThemes = {
        ...sharedThemes,
        "--theme-name": "light",
        // scroll bar
        "--scrollbar-bg": "#d5d5d5",
        "--scrollbar-thumb-bg": "#979797",
        "--scrollbar-active-thumb-bg": "#737373",
        "--primary-color": "#303030",
        "--primary-color-disabled": "#a0a0a0",
        "--primary-bg-color": "#ffffff",
        "--primary-border-color": "#858585",
        "--primary-border": "1px solid var(--primary-border-color)",
        "--primary-opacity": "unset",
        // used for dark theme
        "--primary-disabled-opacity": "0.5",
        // used for dark theme
        "--primary-accent-color": "#0a74c9",
        // used for radio and checkbox's background color
        "--secondary-color": "#818181",
        "--secondary-bg-color": "#eeeeee",
        "--secondary-border-color": "#a0a0a0",
        "--secondary-border": "1px solid var(--secondary-border-color)",
        // including menus, tabs, sidebars
        "--activatable-color-normal": "var(--primary-color)",
        "--activatable-bg-color-normal": "var(--primary-bg-color)",
        "--activatable-color-hover": "#1d1d1d",
        "--activatable-bg-color-hover": "#bcbcbc",
        "--activatable-color-selected": "#2d2d2d",
        "--activatable-bg-color-selected": "#dcdcdc",
        // '--menu-color-hover': '#303030',
        // '--menu-bg-color': '#ffffff',
        // '--menu-bg-color-hover': '#a0a0a0',
        "--menu-font-size": "1rem",
        "--menubar-color": "#eeeeee",
        "--menubar-bg-color": "#000000",
        "--menubar-sub-bg-color": "#f9f9f9",
        "--sidebar-color": "var(--primary-color)",
        "--sidebar-bg-color": "#f4f3f4",
        // '--sidebar-sub-color': 'var(--sidebar-color)',
        // '--sidebar-sub-bg-color': '#eaeaea',
        "--sidebar-border": "1px solid #858585",
        // '--sidebar-hover-color': 'var(--sidebar-color)',
        // '--sidebar-hover-bg-color': '#e0e0e0',
        "--row-bg-color1": "#ffffff",
        "--row-bg-color2": "#ffffff",
        "--success-color": "#04AA6D",
        "--info-color": "#2196F3",
        "--warning-color": "#ff9800",
        "--error-color": "#f44336",
        "--success-bg-color": "#04AA6D",
        "--info-bg-color": "#2196F3",
        "--warning-bg-color": "#ff9800",
        "--error-bg-color": "#f44336",
        "--notice-color-with-bg": "#ffffff",
        "--cover-mask-bg-color": "#00000060",
        "--cover-bg-color": "#f5f5f5",
        // for dropdown-menu
        "--cover-box-shadow": "3px 3px 8px #767676",
        // for big block, deeper shadow arround, good for dark theme
        "--cover-box-shadow-around": "#000000 2px 4px 20px 1px",
        // for input, checkbox, radio box, select
        "--input-color": "#4e4e4e",
        "--input-bg-color": "#ffffff",
        "--input-box-shadow": "0px 0px 0px #000000, 1px 1px 0px 0px #50505045",
        "--input-border-focus": "1px solid #0074d9",
        // for button, div
        "--button-color": "#4e4e4e",
        "--button-bg": "-webkit-linear-gradient(top, #ffffff 0%, #f6f6f6 74%, #ededed 100%)",
        "--button-bg-hover": "-webkit-linear-gradient(top, #ffffff 0%, #e6e6e6 74%, #dddddd 100%)",
        "--button-border": "1px solid #f6f6f6",
        "--button-box-shadow": "1px 1px 1px #00000085, 0px 1px 0px 2px #0705053b",
        "--header-color": "#000080",
        "--header-bg-color": "#ffffff",
        // for setting-section
        "--ss-group-color": "var(--primary-color)",
        "--ss-group-bg-color": "var(--activatable-bg-color-selected)",
        "--ss-row-btn-color": "#eee",
        "--ss-row-btn-bg-color": "#333",
        "--ss-row-btn-warn-color": "red",
        "--mobile-header-shadow": "0 4px 4px var(--primary-border-color)"
        // '--po-background': '#e5e5e5', //	Background for surfaces on top of primary background
        // // backgroundSecondary: '#f5f5f5', //	Secondary background
        // // backgroundOnSecondary: '#e5e5e5', //	Background for surfaces on top of secondary background
        // '--background-modifier-hover': '', //	Hovered elements
        // '--background-modifier-active-hover': '', //	Active hovered elements
        // '--background-modifier-border': '', //	Border color
        // '--background-modifier-border-hover': '', //	Border color (hover)
        // '--background-modifier-border-focus': '', //	Border color (focus)
        // '--background-modifier-error': '', //	Error background
        // '--background-modifier-error-hover': '', //	Error background (hover)
        // '--background-modifier-success': '', //	Success background
        // '--background-modifier-message': '', //	Messages background
        // '--background-modifier-form-field': '', //	Form field background
      };
    }
  });

  // node_modules/lupine.components/src/styles/base-themes.ts
  var baseThemes;
  var init_base_themes = __esm({
    "node_modules/lupine.components/src/styles/base-themes.ts"() {
      init_dark_themes();
      init_light_themes();
      baseThemes = {
        light: lightThemes,
        dark: darkThemes,
        lightGreen: {
          ...lightThemes,
          "--background-primary": "#d8ffe3",
          //	Primary background
          "--color-primary": "#303030",
          //	Primary text color
          backgroundPrimary: "",
          //	Primary background
          backgroundOnPrimary: "",
          //	Background for surfaces on top of primary background
          backgroundSecondary: "#f5f5f7",
          //	Secondary background
          backgroundOnSecondary: "#e5e5e7"
          //	Background for surfaces on top of secondary background
        }
      };
    }
  });

  // node_modules/lupine.components/src/styles/index.ts
  var init_styles2 = __esm({
    "node_modules/lupine.components/src/styles/index.ts"() {
      init_media_query();
      init_shared_themes();
      init_dark_themes();
      init_light_themes();
      init_base_themes();
    }
  });

  // node_modules/lupine.components/src/components/menu-bar.tsx
  var fetchMenu, MenuBar;
  var init_menu_bar = __esm({
    "node_modules/lupine.components/src/components/menu-bar.tsx"() {
      init_src();
      init_styles2();
      init_link_item();
      init_jsx_runtime();
      fetchMenu = async (menuId) => {
        const data = await getRenderPageProps().renderPageFunctions.fetchData(`/api/menu/get/${menuId}`);
        return data.json;
      };
      MenuBar = ({
        menuId,
        items,
        className,
        textColor = "var(--menubar-color)",
        backgroundColor = "var(--menubar-bg-color)",
        //'black',
        hoverColor = "var(--activatable-color-hover)",
        //'#ffffff',
        hoverBgColor = "var(--activatable-bg-color-hover)",
        //'#d12121',
        maxWidth = "100%",
        maxWidthMobileMenu = MediaQueryMaxWidth.TabletMax
      }) => {
        const css2 = {
          width: "100%",
          maxWidth,
          margin: "auto",
          // height: 'auto',
          backgroundColor,
          position: "relative",
          ".menu-bar-top": {
            display: "flex",
            width: "100%",
            justifyContent: "center"
          },
          ".menu-bar-item": {
            display: "inline-block",
            color: textColor,
            padding: "14px 16px",
            textDecoration: "none",
            position: "relative"
          },
          ".menu-bar-item:hover, .menu-bar-sub-box:hover > .menu-bar-item": {
            // for desktop, make parent menu hover when sub menu is hover
            color: hoverColor,
            backgroundColor: hoverBgColor
          },
          ".menu-bar-sub-box .menu-bar-sub": {
            display: "none",
            position: "absolute",
            backgroundColor: "var(--menubar-sub-bg-color)",
            //'#f9f9f9',
            minWidth: "165px",
            boxShadow: "0px 8px 16px 0px rgba(0,0,0,0.2)",
            zIndex: "var(--layer-menu-sub)",
            flexDirection: "column"
          },
          ".menu-bar-sub-box > .menu-bar-item": {
            padding: "14px 26px 14px 16px",
            width: "100%"
          },
          ".menu-bar-sub-box > .menu-bar-item::after": {
            content: '""',
            position: "absolute",
            top: "50%",
            transform: "translateY(-50%)",
            marginLeft: "6px",
            width: 0,
            height: 0,
            borderLeft: "5px solid transparent",
            borderRight: "5px solid transparent",
            borderTop: "5px solid " + textColor
          },
          ".menu-bar-sub-box .menu-bar-sub > .menu-bar-item": {
            color: "black"
          },
          ".menu-bar-sub-box:hover > .menu-bar-sub": {
            display: "flex"
          },
          ".menu-bar-sub-box .menu-bar-sub .menu-bar-item:hover": {
            // backgroundColor: '#ddd',
            color: hoverColor,
            backgroundColor: hoverBgColor
          },
          ".menu-bar-mobile": {
            display: "none",
            position: "relative",
            backgroundColor,
            padding: "5px 18px 6px",
            ".menu-bar-toggle": {
              cursor: "pointer",
              padding: "14px 0 19px 0",
              "span, span::before, span::after": {
                cursor: "pointer",
                height: "3px",
                width: "25px",
                borderRadius: "1px",
                background: "#ffffff",
                position: "absolute",
                display: "block",
                transition: "all 300ms ease-in-out"
              },
              "span::before, span::after": {
                content: '""'
              },
              "span::before": {
                top: "-10px"
              },
              "span::after": {
                bottom: "-10px"
              }
            },
            ".menu-bar-toggle.active span": {
              backgroundColor: "transparent"
            },
            ".menu-bar-toggle.active span::before": {
              transform: "rotate(45deg)",
              top: 0
            },
            ".menu-bar-toggle.active span::after": {
              transform: "rotate(-45deg)",
              top: 0
            }
          },
          ["@media only screen and (max-width: " + maxWidthMobileMenu + ")"]: {
            ".menu-bar-mobile": {
              display: "block"
            },
            ".menu-bar-top": {
              display: "none"
            },
            ".menu-bar-top.open": {
              display: "flex",
              flexDirection: "column"
            },
            ".menu-bar-top.open .menu-bar-sub-box > .menu-bar-sub": {
              display: "flex",
              position: "unset",
              ".menu-bar-item": {
                paddingLeft: "32px",
                color: textColor,
                backgroundColor
              },
              ".menu-bar-item:hover": {
                color: hoverColor,
                backgroundColor: hoverBgColor
              }
            },
            ".menu-bar-sub-box:hover > .menu-bar-item": {
              // for mobile, no parent menu hover when sub menu is hover
              color: textColor,
              backgroundColor
            },
            ".menu-bar-sub-box:hover > .menu-bar-item:hover": {
              color: hoverColor,
              backgroundColor: hoverBgColor
            }
          }
        };
        const renderItems = (items2, className2) => {
          return /* @__PURE__ */ jsx("div", { class: className2, children: items2.map((item) => {
            return item.items ? /* @__PURE__ */ jsx("div", { class: "menu-bar-sub-box", children: [
              /* @__PURE__ */ jsx("div", { class: "menu-bar-item", children: item.text }),
              renderItems(item.items, "menu-bar-sub")
            ] }) : /* @__PURE__ */ jsx(LinkItem, { className: "menu-bar-item", url: item.url, alt: item.alt, text: item.text });
          }) });
        };
        const ref = {
          onLoad: async () => {
            if (menuId) {
              const menu = await fetchMenu(menuId);
              if (menu.result && menu.result.items.length > 0) {
                const items2 = menu.result.items.map((i) => {
                  const l = i.split("	");
                  return { text: l[5], url: l[4] };
                });
                const newDom = renderItems(items2, "menu-bar-top");
              }
            }
          }
        };
        const onToggleClick = () => {
          const menu = ref.$(".menu-bar-mobile .menu-bar-toggle");
          menu.classList.toggle("active");
          const topMenu = ref.$(".menu-bar-top");
          topMenu.classList.toggle("open");
        };
        return /* @__PURE__ */ jsx("div", { ref, css: css2, class: ["menu-bar-box", className].join(" "), children: [
          /* @__PURE__ */ jsx("div", { class: "menu-bar-mobile", children: /* @__PURE__ */ jsx("div", { class: "menu-bar-toggle", onClick: onToggleClick, children: /* @__PURE__ */ jsx("span", {}) }) }),
          renderItems(items, "menu-bar-top")
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/components/menu-item-props.tsx
  var init_menu_item_props = __esm({
    "node_modules/lupine.components/src/components/menu-item-props.tsx"() {
    }
  });

  // node_modules/lupine.components/src/components/menu-sidebar.tsx
  var MenuSidebar;
  var init_menu_sidebar = __esm({
    "node_modules/lupine.components/src/components/menu-sidebar.tsx"() {
      init_src();
      init_lib2();
      init_styles2();
      init_jsx_runtime();
      MenuSidebar = ({
        mobileMenu,
        desktopMenu,
        menuId,
        items,
        className,
        color = "white",
        backgroundColor = "dark",
        maxWidth = "100%",
        maxWidthMobileMenu = MediaQueryMaxWidth.TabletMax,
        isDevAdmin = false
      }) => {
        const css2 = {
          // backgroundColor,
          ".menu-sidebar-top": {
            width: "100%",
            backgroundColor: "var(--sidebar-bg-color)",
            maxWidth,
            margin: "auto",
            // height: 'auto',
            position: "relative",
            display: "flex",
            // width: '100%',
            justifyContent: "center",
            flexDirection: "column"
          },
          // '&.mobile .menu-sidebar-top': {
          //   position: 'absolute',
          // },
          ".menu-sidebar-item": {
            display: "inline-block",
            color,
            cursor: "pointer",
            padding: "14px 16px",
            textDecoration: "none",
            position: "relative",
            borderBottom: "var(--sidebar-border)"
          },
          // select parent when hover on a child, .menu-sidebar-sub-box:hover > .menu-sidebar-item
          ".menu-sidebar-item:hover": {
            color: "var(--activatable-color-hover)",
            backgroundColor: "var(--activatable-bg-color-hover)"
          },
          ".menu-sidebar-sub-box .menu-sidebar-sub": {
            display: "none",
            // position: 'absolute',
            // color: 'var(--sidebar-sub-color)',
            // backgroundColor: 'var(--sidebar-sub-bg-color)',
            minWidth: "165px",
            // boxShadow: '0px 8px 16px 0px rgba(0,0,0,0.2)',
            zIndex: "var(--layer-sidebar-sub)",
            flexDirection: "column"
          },
          ".menu-sidebar-sub-box > .menu-sidebar-item": {
            padding: "14px 26px 14px 16px",
            width: "100%"
          },
          ".menu-sidebar-sub-box > .menu-sidebar-sub > .menu-sidebar-item": {
            paddingLeft: "32px"
          },
          ".menu-sidebar-sub-box > .menu-sidebar-item::after": {
            content: '""',
            position: "absolute",
            top: "50%",
            transform: "translateY(-50%) rotate(-90deg)",
            marginLeft: "6px",
            width: 0,
            height: 0,
            borderLeft: "5px solid transparent",
            borderRight: "5px solid transparent",
            borderTop: "5px solid " + color,
            right: "10px",
            transition: "all 300ms ease-in-out"
          },
          ".menu-sidebar-sub-box.open > .menu-sidebar-item::after": {
            transform: "rotate(0deg)"
          },
          "&.mobile .menu-sidebar-sub-box > .menu-sidebar-item::after": {
            transform: "rotate(0deg)"
          },
          // '.menu-sidebar-sub-box .menu-sidebar-sub > .menu-sidebar-item': {
          //   color: 'black',
          // },
          ".menu-sidebar-sub-box.open > .menu-sidebar-sub": {
            display: "flex"
          },
          ".menu-sidebar-sub-box .menu-sidebar-sub .menu-sidebar-item:hover": {
            color: "var(--activatable-color-hover)",
            backgroundColor: "var(--activatable-bg-color-hover)"
          },
          ".menu-sidebar-mobile": {
            display: "none",
            position: "relative",
            // backgroundColor: 'var(--primary-bg-color)',
            padding: "5px 4px 6px",
            ".menu-sidebar-toggle": {
              cursor: "pointer",
              padding: "6px 0 8px 0",
              "span, span::before, span::after": {
                cursor: "pointer",
                height: "3px",
                width: "25px",
                borderRadius: "1px",
                background: "var(--primary-color)",
                position: "absolute",
                display: "block",
                transition: "all 300ms ease-in-out"
              },
              "span::before, span::after": {
                content: '""'
              },
              "span::before": {
                top: "-7px"
              },
              "span::after": {
                bottom: "-7px"
              }
            },
            ".menu-sidebar-toggle.active span": {
              backgroundColor: "transparent"
            },
            ".menu-sidebar-toggle.active span::before": {
              transform: "rotate(45deg)",
              top: 0
            },
            ".menu-sidebar-toggle.active span::after": {
              transform: "rotate(-45deg)",
              top: 0
            }
          },
          // hide menu for mobile place
          "&.mobile": {
            display: "none"
            // width: '33px',
          },
          "&.mobile .menu-sidebar-mobile": {
            display: "block",
            width: "33px"
          },
          ["@media only screen and (max-width: " + maxWidthMobileMenu + ")"]: {
            // hide menu for not mobile place
            display: "none",
            // show menu for mobile place
            "&.mobile": {
              display: "block"
            },
            "&.mobile.open": {
              position: "absolute",
              width: "100%",
              height: "100%",
              top: 0,
              left: 0,
              display: "flex",
              flexDirection: "column",
              backgroundColor: "#ccccccc2",
              zIndex: "var(--layer-sidebar)"
            },
            ".menu-sidebar-top": {
              display: "none"
            },
            ".menu-sidebar-top.open": {
              display: "flex",
              flexDirection: "column",
              // left: 0,
              // top: 0,
              flex: 1,
              overflowY: "auto",
              // paddingTop: '200px',
              width: "200px",
              marginLeft: "unset",
              justifyContent: "start"
            },
            ".menu-sidebar-top.open .menu-sidebar-sub-box > .menu-sidebar-sub": {
              display: "flex",
              position: "unset",
              ".menu-sidebar-item": {
                paddingLeft: "32px",
                color,
                backgroundColor
              },
              ".menu-sidebar-item:hover": {
                color: "var(--activatable-color-hover)",
                backgroundColor: "var(--activatable-bg-color-hover)"
              }
            },
            ".menu-sidebar-sub-box:hover > .menu-sidebar-item": {
              backgroundColor: "unset"
            },
            ".menu-sidebar-sub-box:hover > .menu-sidebar-item:hover": {
              color: "var(--activatable-color-hover)",
              backgroundColor: "var(--activatable-bg-color-hover)"
            }
          }
        };
        const renderItems = (items2, className2) => {
          return /* @__PURE__ */ jsx("div", { class: className2, children: items2.filter((item) => isDevAdmin || !item.devAdmin).map((item) => {
            if (item.hide === true) {
              return null;
            }
            let ref2 = {};
            return item.items ? /* @__PURE__ */ jsx("div", { ref: ref2, class: "menu-sidebar-sub-box", onClick: () => onItemToggleClick(ref2), children: [
              /* @__PURE__ */ jsx("div", { class: "menu-sidebar-item", children: item.text }),
              renderItems(item.items, "menu-sidebar-sub")
            ] }) : item.js ? /* @__PURE__ */ jsx(
              "a",
              {
                class: "menu-sidebar-item",
                href: "javascript:void(0)",
                alt: item.alt || item.text,
                onClick: (event) => {
                  stopPropagation(event);
                  onToggleClick(event);
                  item.js && item.js();
                },
                children: item.text
              }
            ) : /* @__PURE__ */ jsx("a", { class: "menu-sidebar-item", href: item.url, alt: item.alt || item.text, target: "_blank", children: item.text });
          }) });
        };
        const ref = {
          // onLoad: async () => {
          //   if (menuId) {
          //     const menu = await fetchMenu(menuId);
          //     if (menu.result.items.length > 0) {
          //       const items = menu.result.items.map((i: any) => {
          //         const l = i.split('\t');
          //         return { text: l[5], url: l[4] };
          //       });
          //       const newDom = renderItems(items, 'menu-sidebar-top');
          //       //mountComponents('.menu-sidebar-top', newDom);
          //     }
          //   }
          // },
        };
        const onToggleClick = (event) => {
          event.stopPropagation();
          const menu = ref.$(".menu-sidebar-mobile .menu-sidebar-toggle");
          menu.classList.toggle("active");
          const topMenu = ref.$(".menu-sidebar-top");
          topMenu.classList.toggle("open");
          ref.current.classList.toggle("open");
        };
        const onItemToggleClick = (ref2) => {
          ref2.current.classList.toggle("open");
        };
        bindGlobalStyle("menu-sidebar-box", css2);
        const newCss = !desktopMenu && !mobileMenu || desktopMenu && mobileMenu ? {
          ["@media only screen and (max-width: " + maxWidthMobileMenu + ")"]: {
            display: "block",
            ".menu-sidebar-top": {
              display: "block"
            }
          }
        } : {};
        const onMaskClick = (event) => {
          if (ref.current.classList.contains("open")) {
            onToggleClick(event);
          }
        };
        return /* @__PURE__ */ jsx(
          "div",
          {
            css: newCss,
            ref,
            class: ["menu-sidebar-box", className, mobileMenu ? "mobile" : ""].join(" "),
            onClick: onMaskClick,
            children: [
              /* @__PURE__ */ jsx("div", { class: "menu-sidebar-mobile", children: /* @__PURE__ */ jsx("div", { class: "menu-sidebar-toggle", onClick: onToggleClick, children: /* @__PURE__ */ jsx("span", {}) }) }),
              renderItems(items, "menu-sidebar-top")
            ]
          }
        );
      };
    }
  });

  // node_modules/lupine.components/src/components/message-box.tsx
  var MessageBoxButtonProps, MessageBox;
  var init_message_box = __esm({
    "node_modules/lupine.components/src/components/message-box.tsx"() {
      init_float_window();
      MessageBoxButtonProps = /* @__PURE__ */ ((MessageBoxButtonProps2) => {
        MessageBoxButtonProps2["YesNo"] = "yesno";
        MessageBoxButtonProps2["OkCancel"] = "okcancel";
        MessageBoxButtonProps2["Ok"] = "ok";
        return MessageBoxButtonProps2;
      })(MessageBoxButtonProps || {});
      MessageBox = class {
        static async show({
          title,
          children,
          contentMaxHeight,
          contentMinWidth,
          buttonType = "okcancel" /* OkCancel */,
          noMoving = false,
          noModal = false,
          closeEvent,
          handleClicked,
          closeWhenClickOutside = false
        }) {
          const buttons = buttonType === "okcancel" /* OkCancel */ ? ["OK", "Cancel"] : buttonType === "yesno" /* YesNo */ ? ["Yes", "No"] : ["OK"];
          return FloatWindow.show({
            title,
            children,
            contentMaxHeight,
            contentMinWidth,
            buttons,
            noMoving,
            noModal,
            closeEvent,
            handleClicked,
            closeWhenClickOutside
          });
        }
      };
    }
  });

  // node_modules/lupine.components/src/components/meta-data.tsx
  function isNameMeta(data) {
    return !!(data.name && data.content);
  }
  function isPropertyMeta(data) {
    return !!(data.property && data.content);
  }
  function isHttpEquivMeta(data) {
    return !!(data.httpEquiv && data.content);
  }
  var MetaData;
  var init_meta_data = __esm({
    "node_modules/lupine.components/src/components/meta-data.tsx"() {
      init_src();
      init_lib2();
      init_jsx_runtime();
      MetaData = (data) => {
        if (isNameMeta(data)) {
          addMetaDataTags(`name:${data.name}`, `<meta name="${data.name}" content="${encodeHtml(data.content)}">`);
        } else if (isPropertyMeta(data)) {
          addMetaDataTags(
            `property:${data.property}`,
            `<meta property="${data.property}" content="${encodeHtml(data.content)}">`
          );
        } else if (isHttpEquivMeta(data)) {
          addMetaDataTags(
            `http-equiv:${data.httpEquiv}`,
            `<meta http-equiv="${data.httpEquiv}" content="${encodeHtml(data.content)}">`
          );
        } else if (data.key && data.string) {
          addMetaDataTags(`${data.key}`, `${data.string}`);
        } else {
          console.warn("Unknown meta data:", data);
        }
        return /* @__PURE__ */ jsx(Fragment, {});
      };
    }
  });

  // node_modules/lupine.components/src/components/meta-description.tsx
  var MetaDescription;
  var init_meta_description = __esm({
    "node_modules/lupine.components/src/components/meta-description.tsx"() {
      init_src();
      init_lib2();
      init_jsx_runtime();
      MetaDescription = ({ children }) => {
        addMetaDataTags("name:description", `<meta name="description" content="${encodeHtml(children)}">`);
        return /* @__PURE__ */ jsx(Fragment, {});
      };
    }
  });

  // node_modules/lupine.components/src/components/modal.tsx
  var ModalWindow;
  var init_modal = __esm({
    "node_modules/lupine.components/src/components/modal.tsx"() {
      init_float_window();
      ModalWindow = class {
        static async show({
          title,
          children,
          contentMaxHeight,
          contentMinWidth,
          buttons,
          noMoving = true,
          noModal = false,
          closeEvent,
          handleClicked,
          closeWhenClickOutside = true,
          zIndex,
          contentOverflowY
        }) {
          return FloatWindow.show({
            title,
            children,
            contentMaxHeight,
            contentMinWidth,
            buttons,
            noMoving,
            noModal,
            closeEvent,
            handleClicked,
            closeWhenClickOutside,
            zIndex,
            contentOverflowY
          });
        }
      };
    }
  });

  // node_modules/lupine.components/src/components/page-title.tsx
  var PageTitle;
  var init_page_title = __esm({
    "node_modules/lupine.components/src/components/page-title.tsx"() {
      init_src();
      init_jsx_runtime();
      PageTitle = ({ children }) => {
        setPageTitle(children);
        return /* @__PURE__ */ jsx(Fragment, {});
      };
    }
  });

  // node_modules/lupine.components/src/components/paging-link.tsx
  var _DEFAULT_PAGE_LIMIT, getDefaultPageLimit, setDefaultPageLimit, pageLinkOptions, PagingLink;
  var init_paging_link = __esm({
    "node_modules/lupine.components/src/components/paging-link.tsx"() {
      init_src();
      init_jsx_runtime();
      _DEFAULT_PAGE_LIMIT = 10;
      getDefaultPageLimit = () => {
        return _DEFAULT_PAGE_LIMIT;
      };
      setDefaultPageLimit = (limit) => {
        _DEFAULT_PAGE_LIMIT = limit;
      };
      pageLinkOptions = [10, 20, 50, 100, 200, 500];
      PagingLink = ({
        itemsCount,
        pageLimit = getDefaultPageLimit(),
        pageIndex = 0,
        baseLink,
        onClick,
        textPerpage = "/Page",
        textOk = "Go",
        textTo = "To",
        textPage = "Page",
        showControl
      }) => {
        const css2 = {
          display: "flex",
          justifyContent: "end",
          alignItems: "center",
          textAlign: "right",
          padding: "6px 16px 6px 0",
          fontSize: "14px",
          ".paging-link-index a, .paging-link-index.current": {
            padding: "2px 6px",
            textDecoration: "none"
          },
          ".paging-link-index.current": {
            fontWeight: "bold"
          },
          "span.paging-link-index a:hover, span.paging-link-go a:hover": {
            textDecoration: "underline"
          },
          ".paging-link-ctl-box": {
            display: "flex",
            alignItems: "center"
          },
          ".paging-link-ctl-box .paging-link-jump": {
            width: "50px",
            padding: "1px 3px",
            margin: "0 3px",
            textAlign: "right"
          },
          ".paging-link-ctl-box .paging-link-limit": {
            width: "90px",
            padding: "1px 3px",
            margin: "0 3px"
          },
          ".paging-link-ok": {
            margin: "0 3px"
          }
        };
        bindGlobalStyle("paging-link-box", css2);
        pageIndex = pageIndex ?? (Number.parseInt(getRenderPageProps().query["pg_i"] || "") || 0);
        pageLimit = pageLimit || _DEFAULT_PAGE_LIMIT;
        let maxPages = Math.floor(itemsCount / pageLimit);
        if (itemsCount > 0 && pageLimit > 0) {
          if (itemsCount % pageLimit !== 0) {
            maxPages++;
          }
          if (pageIndex > maxPages) {
            pageIndex = maxPages - 1;
          }
        }
        const onPageLimitChange = (e) => {
          const limit = Number(e.target.value || "0");
          if (limit > 0) {
            setDefaultPageLimit(limit);
            onClick && onClick(pageIndex);
          }
        };
        const onOkClick = () => {
          let index = Number(ref.$(".paging-link-jump").value || "0");
          if (index < 1) {
            index = 1;
          }
          if (index > maxPages) {
            index = maxPages;
          }
          onClick && onClick(index - 1);
        };
        const ref = {};
        return /* @__PURE__ */ jsx("div", { ref, class: "paging-link-box", children: [
          pageIndex > 0 ? /* @__PURE__ */ jsx("span", { class: "paging-link-go", children: /* @__PURE__ */ jsx(
            "a",
            {
              href: onClick ? "javascript:void(0)" : baseLink + "?pg_i=" + (pageIndex - 1),
              onClick: () => onClick && onClick(pageIndex - 1),
              children: "<"
            }
          ) }) : /* @__PURE__ */ jsx("span", { class: "paging-link-go disabled", children: "<" }),
          Array.from({ length: maxPages }, (_, i) => i).map((i) => /* @__PURE__ */ jsx(Fragment, { children: i < 2 || i >= maxPages - 2 || i > pageIndex - 3 && i < pageIndex + 3 ? i == pageIndex ? /* @__PURE__ */ jsx("span", { class: "paging-link-index current", children: i + 1 }) : /* @__PURE__ */ jsx("span", { class: "paging-link-index", children: /* @__PURE__ */ jsx(
            "a",
            {
              href: onClick ? "javascript:void(0)" : baseLink + "?pg_i=" + i,
              onClick: () => onClick && onClick(i),
              children: i + 1
            }
          ) }) : (i == pageIndex - 4 || i == pageIndex + 4) && /* @__PURE__ */ jsx("span", { class: "paging-link-skip", children: "..." }) })),
          pageIndex < maxPages - 1 ? /* @__PURE__ */ jsx("span", { class: "paging-link-go", children: /* @__PURE__ */ jsx(
            "a",
            {
              href: onClick ? "javascript:void(0)" : baseLink + "?pg_i=" + (pageIndex + 1),
              onClick: () => onClick && onClick(pageIndex + 1),
              children: ">"
            }
          ) }) : /* @__PURE__ */ jsx("span", { class: "paging-link-go disabled", children: ">" }),
          showControl && /* @__PURE__ */ jsx("div", { class: "paging-link-ctl-box", children: [
            textTo,
            /* @__PURE__ */ jsx("input", { class: "input-base paging-link-jump input-s", type: "number", value: pageIndex + 1 }),
            " / ",
            maxPages,
            " ",
            textPage,
            /* @__PURE__ */ jsx("button", { class: "button-base button-s paging-link-ok", onClick: onOkClick, children: textOk }),
            /* @__PURE__ */ jsx("select", { class: "input-base paging-link-limit input-s", onChange: onPageLimitChange, children: [
              /* @__PURE__ */ jsx("option", { value: "", children: " - " }),
              pageLinkOptions.map((page) => /* @__PURE__ */ jsx("option", { value: page, children: [
                page,
                textPerpage
              ] }))
            ] })
          ] })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/components/panel.tsx
  var Panel;
  var init_panel = __esm({
    "node_modules/lupine.components/src/components/panel.tsx"() {
      init_jsx_runtime();
      Panel = ({ children, className, css: css2 }) => {
        const newCss = {
          display: "flex",
          flexDirection: "column",
          ...css2
        };
        return /* @__PURE__ */ jsx("div", { css: newCss, class: ["panel-box", className].join(" "), children });
      };
    }
  });

  // node_modules/lupine.components/src/components/popup-menu.tsx
  var PopupMenuWithIcon, PopupMenuWithButton, PopupMenuWithLabel, PopupMenu;
  var init_popup_menu = __esm({
    "node_modules/lupine.components/src/components/popup-menu.tsx"() {
      init_lib2();
      init_jsx_runtime();
      PopupMenuWithIcon = (props) => {
        const hook = {};
        const css2 = {
          cursor: "pointer",
          display: "flex",
          flexDirection: "row",
          alignItems: "center",
          fontSize: "24px"
        };
        return /* @__PURE__ */ jsx(
          "div",
          {
            onClick: () => {
              hook.openMenu && hook.openMenu();
            },
            css: css2,
            children: /* @__PURE__ */ jsx(
              PopupMenu,
              {
                list: props.list,
                defaultValue: props.defaultValue,
                tips: props.tips,
                minWidth: props.minWidth,
                maxWidth: props.maxWidth,
                maxHeight: props.maxHeight,
                handleSelected: props.handleSelected,
                handleOpened: props.handleOpened,
                handleClosed: props.handleClosed,
                noUpdateLabel: props.noUpdateLabel,
                hook,
                noTriangleIcon: props.noTriangleIcon
              }
            )
          }
        );
      };
      PopupMenuWithButton = (props) => {
        const hook = {};
        return /* @__PURE__ */ jsx(
          "button",
          {
            class: "button-base",
            onClick: () => {
              hook.openMenu && hook.openMenu();
            },
            css: { ">div": { float: "right", textAlign: "left" } },
            children: [
              props.label,
              ":",
              " ",
              /* @__PURE__ */ jsx(
                PopupMenu,
                {
                  list: props.list,
                  defaultValue: props.defaultValue,
                  tips: props.tips,
                  minWidth: props.minWidth,
                  maxWidth: props.maxWidth,
                  maxHeight: props.maxHeight,
                  handleSelected: props.handleSelected,
                  handleOpened: props.handleOpened,
                  handleClosed: props.handleClosed,
                  noUpdateLabel: props.noUpdateLabel,
                  hook,
                  noTriangleIcon: props.noTriangleIcon,
                  align: props.align
                }
              )
            ]
          }
        );
      };
      PopupMenuWithLabel = (props) => {
        const hook = {};
        return /* @__PURE__ */ jsx(
          "div",
          {
            onClick: () => {
              hook.openMenu && hook.openMenu();
            },
            css: { cursor: "pointer", ">div": { float: "right", textAlign: "left" } },
            children: [
              props.label,
              ":",
              " ",
              /* @__PURE__ */ jsx(
                PopupMenu,
                {
                  list: props.list,
                  defaultValue: props.defaultValue,
                  tips: props.tips,
                  minWidth: props.minWidth,
                  maxWidth: props.maxWidth,
                  maxHeight: props.maxHeight,
                  handleSelected: props.handleSelected,
                  handleOpened: props.handleOpened,
                  handleClosed: props.handleClosed,
                  noUpdateLabel: props.noUpdateLabel,
                  hook,
                  noTriangleIcon: props.noTriangleIcon,
                  align: props.align
                }
              )
            ]
          }
        );
      };
      PopupMenu = ({
        list: list2,
        defaultValue,
        icon,
        tips = "",
        width,
        minWidth,
        maxWidth,
        maxHeight,
        handleSelected,
        handleOpened,
        handleClosed,
        noUpdateLabel,
        hook,
        align = "right",
        noTriangleIcon
      }) => {
        const css2 = {
          ".popup-menu-item": {
            padding: "0 0 1px 0",
            display: "inline-block",
            position: "relative",
            ".triangle-icon": {
              display: "inline-block",
              cursor: "pointer",
              whiteSpace: "nowrap",
              marginRight: "15px"
            },
            // cover-box-shadow
            ".triangle-icon::after": {
              content: '""',
              position: "absolute",
              top: "50%",
              transform: "translateY(-50%)",
              marginLeft: "3px",
              width: 0,
              height: 0,
              borderLeft: "5px solid transparent",
              borderRight: "5px solid transparent",
              borderTop: "5px solid var(--primary-color)"
            }
          },
          ".popup-menu-item:hover": {
            padding: "1px 0 0 0"
          },
          ".popup-menu-bottom": {
            position: "relative",
            height: "1px",
            ".popup-menu-list": {
              display: "none",
              position: "absolute",
              fontSize: "var(--menu-font-size)",
              top: 0,
              width: width || "100px",
              color: "var(--activatable-color-normal)",
              backgroundColor: "var(--activatable-bg-color-normal)",
              zIndex: "var(--layer-menu)",
              borderRadius: "4px",
              border: "1px solid #ddd",
              padding: "5px 0px",
              overflow: "auto",
              "line-height": "1.2em",
              "min-width": minWidth || "max-content",
              "max-width": maxWidth || "200px",
              "max-height": maxHeight || "300px",
              "box-shadow": "var(--cover-box-shadow)",
              //'#0000004c 0px 19px 38px, #00000038 0px 15px 12px',
              ".menu-focus": {
                position: "absolute",
                height: "0px"
              },
              ".item": {
                padding: "2px 12px"
              },
              ".item:hover": {
                padding: "2px 11px 2px 13px",
                color: "var(--activatable-color-hover)",
                backgroundColor: "var(--activatable-bg-color-hover)",
                cursor: "pointer"
              },
              ".item.indent1": {
                paddingLeft: "19px"
              },
              ".item.indent1:hover": {
                paddingLeft: "18px"
              },
              ".item.indent2": {
                paddingLeft: "35px"
              },
              ".item.indent2:hover": {
                paddingLeft: "34px"
              }
            },
            ".popup-menu-list.left-align": {
              left: "2px"
            },
            ".popup-menu-list.right-align": {
              right: "2px"
            },
            ".popup-menu-list.open": {
              display: "inline-block"
            }
          }
        };
        let ref = { id: "" };
        let isShowing = false;
        let selectedValue = defaultValue;
        const openMenu = (event) => {
          stopPropagation(event);
          handleOpened && handleOpened();
          isShowing = !isShowing;
          const listDom = ref.$(".popup-menu-list");
          if (align === "left") {
            listDom.classList.add("left-align");
          } else {
            listDom.classList.add("right-align");
          }
          listDom.classList.toggle("open", isShowing);
          ref.$(".popup-menu-list .menu-focus").focus();
        };
        if (hook) {
          hook.openMenu = openMenu;
          hook.getValue = () => selectedValue;
          hook.setLabel = (label) => {
            if (!icon && noUpdateLabel !== true) {
              ref.$(".popup-menu-item .popup-menu-text").innerText = label;
            }
          };
        }
        const itemClick = (event, item) => {
          stopPropagation(event);
          isShowing = false;
          ref.$(".popup-menu-list").classList.remove("open");
          if (event.target) {
            selectedValue = event.target.innerText;
            if (!icon && noUpdateLabel !== true) {
              ref.$(".popup-menu-item .popup-menu-text").innerText = event.target.innerText;
            }
            if (handleSelected) {
              handleSelected(event.target.innerText, item);
            }
          }
          handleClosed && handleClosed();
        };
        const onBlur = (event) => {
          setTimeout(() => {
            ref.$(".popup-menu-list").classList.remove("open");
            isShowing && handleClosed && handleClosed();
            isShowing = false;
          }, 300);
        };
        return /* @__PURE__ */ jsx("div", { ref, css: css2, onClick: openMenu, title: tips, children: [
          /* @__PURE__ */ jsx("div", { class: "popup-menu-item", children: icon ? icon : /* @__PURE__ */ jsx("span", { class: "popup-menu-text" + (noTriangleIcon !== true ? " triangle-icon" : ""), children: defaultValue || "&nbsp;" }) }),
          /* @__PURE__ */ jsx("div", { class: "popup-menu-bottom", children: /* @__PURE__ */ jsx("div", { class: "popup-menu-list", children: [
            /* @__PURE__ */ jsx("div", { children: list2.map((item) => {
              if (item === "") return /* @__PURE__ */ jsx("hr", {});
              const text = typeof item === "string" ? item : item.text;
              const indent = typeof item === "string" ? 0 : item.indent;
              return /* @__PURE__ */ jsx("div", { class: "item" + (indent ? " indent" + indent : ""), onClick: (e) => itemClick(e, item), children: text });
            }) }),
            /* @__PURE__ */ jsx("div", { class: "menu-focus", onBlur, tabIndex: 0 })
          ] }) })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/components/progress.tsx
  var Progress;
  var init_progress = __esm({
    "node_modules/lupine.components/src/components/progress.tsx"() {
      init_html_var();
      init_jsx_runtime();
      Progress = (props) => {
        const css2 = {
          position: "fixed",
          display: "flex",
          bottom: "0",
          left: "0",
          width: "100%",
          zIndex: "var(--layer-modal-over)",
          flexDirection: "column",
          backgroundColor: "#e6e6e6de",
          padding: "16px",
          ".progress-box": {
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            width: "100%",
            height: "auto",
            margin: "auto"
          },
          ".progress-bar": {
            display: "flex",
            width: "100%",
            height: "60px",
            borderRadius: "4px",
            overflow: "hidden"
          },
          ".progress-bar1": {
            height: "100%",
            width: "0%",
            backgroundColor: "#49e57e"
          },
          ".progress-bar2": {
            height: "100%",
            width: "100%",
            backgroundColor: "#2bb8cd"
          },
          ".progress-tips": {
            marginTop: "10px",
            fontSize: "30px",
            color: "#49e57e"
          }
        };
        props.hook.onProgress = (percentage, chunkNumber, totalChunks) => {
          percentage = Math.round(percentage * 100);
          const bar1 = document.querySelector(".progress-bar1");
          const bar2 = document.querySelector(".progress-bar2");
          bar1.style.width = `${percentage}%`;
          bar2.style.width = `${100 - percentage}%`;
          dom.value = `${percentage}%`;
        };
        props.hook.onShow = (show, title) => {
          var _a, _b;
          if (title) {
            domTitle.value = title;
          }
          if (show) {
            (_a = ref.current) == null ? void 0 : _a.classList.remove("d-none");
          } else {
            (_b = ref.current) == null ? void 0 : _b.classList.add("d-none");
          }
        };
        const ref = {};
        const domTitle = new HtmlVar("Progress");
        const dom = new HtmlVar("0 %");
        return /* @__PURE__ */ jsx("div", { ref, css: css2, class: "progress-top d-none", children: /* @__PURE__ */ jsx("div", { class: "progress-box", children: [
          /* @__PURE__ */ jsx("div", { class: "progress-title mb-m align-left w-100p", children: domTitle.node }),
          /* @__PURE__ */ jsx("div", { class: "progress-bar", children: [
            /* @__PURE__ */ jsx("div", { class: "progress-bar1" }),
            /* @__PURE__ */ jsx("div", { class: "progress-bar2" })
          ] }),
          /* @__PURE__ */ jsx("div", { class: "progress-tips", children: dom.node })
        ] }) });
      };
    }
  });

  // node_modules/lupine.components/src/components/radio-label-component.tsx
  var RadioLabelComponent;
  var init_radio_label_component = __esm({
    "node_modules/lupine.components/src/components/radio-label-component.tsx"() {
      init_src2();
      init_jsx_runtime();
      RadioLabelComponent = (props) => {
        const css2 = {
          display: "flex",
          "& > label": {
            display: "flex",
            alignItems: "center"
          }
        };
        bindGlobalStyle("radio-label-component", css2);
        return /* @__PURE__ */ jsx("div", { class: "radio-label-component" + (props.className ? " " + props.className : ""), children: /* @__PURE__ */ jsx("label", { children: [
          /* @__PURE__ */ jsx(
            "input",
            {
              type: "radio",
              name: props.name,
              class: "input-base input-s" + (props.radioClassname ? " " + props.radioClassname : ""),
              checked: props.checked,
              disabled: props.disabled,
              onChange: (event) => {
                var _a;
                return (_a = props.onChange) == null ? void 0 : _a.call(props, event.target.checked);
              }
            }
          ),
          /* @__PURE__ */ jsx("span", { class: "ml-ss", children: props.label })
        ] }) });
      };
    }
  });

  // node_modules/lupine.components/src/components/redirect.tsx
  var Redirect;
  var init_redirect = __esm({
    "node_modules/lupine.components/src/components/redirect.tsx"() {
      init_jsx_runtime();
      Redirect = ({ title = "redirect...", url, delaySeconds = 0 }) => {
        const ref = {
          onLoad: async (el) => {
            setTimeout(() => {
              window.location.href = url;
            }, delaySeconds * 1e3);
          }
        };
        return /* @__PURE__ */ jsx("div", { ref, children: title });
      };
    }
  });

  // node_modules/lupine.components/src/components/resizable-splitter.tsx
  var ResizableSplitter;
  var init_resizable_splitter = __esm({
    "node_modules/lupine.components/src/components/resizable-splitter.tsx"() {
      init_src();
      init_lib2();
      init_jsx_runtime();
      ResizableSplitter = class _ResizableSplitter {
        static hostNode;
        static isVertical = true;
        static isRightOrTop = true;
        static initialized = false;
        static startXorY = 0;
        static startWidthOrHeight = 0;
        static pressed = false;
        static init() {
          const css2 = {
            ".resizable-splitter-v-left, .resizable-splitter-v-right": {
              position: "absolute",
              top: 0,
              bottom: 0,
              left: 0,
              width: "2px",
              cursor: "col-resize"
            },
            ".resizable-splitter-v-right": {
              left: "unset",
              right: 0
            },
            ".resizable-splitter-v-left:hover, .resizable-splitter-v-right:hover": {
              width: "4px",
              backgroundColor: "#ccc"
            },
            ".resizable-splitter-h-top, .resizable-splitter-h-bottom": {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              height: "2px",
              cursor: "row-resize"
            },
            ".resizable-splitter-h-bottom": {
              top: "unset",
              bottom: 0
            },
            ".resizable-splitter-h-top:hover, .resizable-splitter-h-bottom:hover": {
              height: "4px",
              backgroundColor: "#ccc"
            }
          };
          bindGlobalStyle("resizable-splitter", css2, false, true);
          window.addEventListener("mousemove", _ResizableSplitter.onMousemove.bind(_ResizableSplitter), false);
          document.documentElement.addEventListener("mouseup", _ResizableSplitter.onMouseup.bind(_ResizableSplitter), false);
        }
        static getSplitterClassName(isVertical, isRightOrTop) {
          const className = "resizable-splitter-" + (isVertical ? isRightOrTop ? "v-right" : "v-left" : isRightOrTop ? "h-top" : "h-bottom");
          return className;
        }
        static onMousedown(event) {
          if (event.buttons !== 1 || event.button !== 0) return;
          this.pressed = true;
          this.startXorY = this.isVertical ? event.clientX : event.clientY;
          const startPosition = document.defaultView.getComputedStyle(this.hostNode)[this.isVertical ? "width" : "height"];
          this.startWidthOrHeight = parseInt(startPosition, 10);
        }
        static onMousemove(event) {
          if (!this.pressed || event.buttons !== 1 || event.button !== 0) {
            return;
          }
          stopPropagation(event);
          if (this.isVertical) {
            const movedXorY = this.startWidthOrHeight + (event.clientX - this.startXorY) * (this.isRightOrTop ? 1 : -1);
            this.hostNode.style.width = movedXorY + "px";
          } else {
            const movedXorY = this.startWidthOrHeight + (event.clientY - this.startXorY) * (this.isRightOrTop ? -1 : 1);
            this.hostNode.style.height = movedXorY + "px";
          }
        }
        static onMouseup() {
          if (this.pressed) this.pressed = false;
        }
        static getSplitter(selector, isVertical, isRightOrTop) {
          if (!this.initialized) {
            this.initialized = true;
            this.init();
          }
          const className = this.getSplitterClassName(isVertical, isRightOrTop);
          const onMousedown = (event) => {
            _ResizableSplitter.hostNode = document.querySelector(selector);
            if (!_ResizableSplitter.hostNode) {
              console.error(`Can't find element: ${selector}`);
              return;
            }
            _ResizableSplitter.isVertical = isVertical;
            _ResizableSplitter.isRightOrTop = isRightOrTop;
            _ResizableSplitter.onMousedown.bind(_ResizableSplitter)(event);
          };
          return /* @__PURE__ */ jsx("div", { onMouseDown: onMousedown, class: className });
        }
      };
    }
  });

  // node_modules/lupine.components/src/components/select-angle-component.tsx
  var SelectAngleComponent;
  var init_select_angle_component = __esm({
    "node_modules/lupine.components/src/components/select-angle-component.tsx"() {
      init_jsx_runtime();
      SelectAngleComponent = (props) => {
        const css2 = {
          width: props.size || "80px",
          height: props.size || "80px",
          "&circle": {
            width: "100%",
            height: "100%",
            borderRadius: "50%",
            border: "2px solid #aaa",
            position: "relative",
            backgroundColor: "var(--primary-bg-color)",
            cursor: "pointer",
            touchAction: "none"
          },
          "&needle": {
            width: "2px",
            height: "50%",
            backgroundColor: "red",
            position: "absolute",
            top: "0",
            left: "50%",
            transformOrigin: "bottom center",
            transform: "rotate(90deg)"
          },
          "&tips": {
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            fontSize: "12px",
            color: "var(--primary-color)",
            fontWeight: "600",
            zIndex: "10"
          },
          "&a0, &a90, &a180, &a270": {
            width: "6px",
            height: "6px",
            borderRadius: "50%",
            backgroundColor: "#333",
            position: "absolute",
            top: "0",
            left: "50%",
            transform: "translate(-50%, -50%)",
            fontSize: "12px",
            color: "#333"
          },
          "&a90": {
            top: "50%",
            left: "100%"
          },
          "&a180": {
            top: "100%",
            left: "50%"
          },
          "&a270": {
            top: "50%",
            left: "0"
          }
        };
        let cx = 0;
        let cy = 0;
        let mv = false;
        if (props.hook) {
          props.hook.setAngle = (angle) => {
            updateAngleSub(angle);
          };
        }
        const updateAngle = (ev) => {
          const dx = ev.clientX - cx;
          const dy = ev.clientY - cy;
          let deg = Math.atan2(dy, dx) * (180 / Math.PI);
          deg = (deg + 450) % 360;
          updateAngleSub(deg);
        };
        const updateAngleSub = (deg) => {
          const needle = ref.$("&needle");
          const text = ref.$("&tips");
          needle.style.transform = `rotate(${deg}deg)`;
          text.textContent = `${deg.toFixed(0)}\xB0`;
          props.onChange(deg);
        };
        const pointerdown = (ev) => {
          const picker = ref.$("&circle");
          const rect = picker.getBoundingClientRect();
          cx = rect.left + rect.width / 2;
          cy = rect.top + rect.height / 2;
          ev.currentTarget.setPointerCapture(ev.pointerId);
          updateAngle(ev);
          mv = true;
        };
        const pointermove = (ev) => {
          if (!mv) {
            return;
          }
          updateAngle(ev);
        };
        const pointerup = (ev) => {
          ev.currentTarget.releasePointerCapture(ev.pointerId);
          mv = false;
        };
        const ref = {};
        return /* @__PURE__ */ jsx("div", { ref, css: css2, children: /* @__PURE__ */ jsx("div", { class: "&circle", onPointerDown: pointerdown, onPointerMove: pointermove, onPointerUp: pointerup, children: [
          /* @__PURE__ */ jsx("div", { class: "&needle" }),
          /* @__PURE__ */ jsx("div", { class: "&tips", children: "90\xB0" }),
          /* @__PURE__ */ jsx("div", { class: "&a0", onClick: () => updateAngleSub(0) }),
          /* @__PURE__ */ jsx("div", { class: "&a90", onClick: () => updateAngleSub(90) }),
          /* @__PURE__ */ jsx("div", { class: "&a180", onClick: () => updateAngleSub(180) }),
          /* @__PURE__ */ jsx("div", { class: "&a270", onClick: () => updateAngleSub(270) })
        ] }) });
      };
    }
  });

  // node_modules/lupine.components/src/components/select-with-title.tsx
  var SelectWithTitle;
  var init_select_with_title = __esm({
    "node_modules/lupine.components/src/components/select-with-title.tsx"() {
      init_jsx_runtime();
      SelectWithTitle = (title, options3, onOptionChanged, size, className = "input-base", width = "100%") => {
        const css2 = {
          select: {
            height: "auto",
            overflowY: "auto",
            width
          }
        };
        return /* @__PURE__ */ jsx("div", { css: css2, children: [
          /* @__PURE__ */ jsx("div", { children: title }),
          /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx("select", { class: className, onChange: (e) => {
            var _a;
            return onOptionChanged((_a = e == null ? void 0 : e.target) == null ? void 0 : _a.value);
          }, size, children: options3.map((option) => /* @__PURE__ */ jsx("option", { value: option.value, selected: option.selected, children: option.option })) }) })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/components/slide-tab-component.tsx
  var SlideTabComponent;
  var init_slide_tab_component = __esm({
    "node_modules/lupine.components/src/components/slide-tab-component.tsx"() {
      init_src2();
      init_jsx_runtime();
      SlideTabComponent = (props) => {
        const css2 = {
          display: "flex",
          flexDirection: "column",
          flex: 1,
          fontSize: "12px",
          borderRadius: "6px",
          padding: "0px 8px 4px 8px",
          // marginBottom: '8px',
          height: "100%",
          ".slide-tab-c-list": {
            flex: 1,
            borderRadius: "6px",
            display: "flex",
            overflowX: "auto",
            width: "100%",
            scrollSnapType: "x mandatory",
            gap: "8px",
            paddingBottom: "10px",
            scrollBehavior: "smooth",
            WebkitOverflowScrolling: "touch"
          },
          ".slide-tab-c-slide": {
            width: "100%",
            overflow: "hidden",
            position: "relative",
            minWidth: "100%",
            flexShrink: 0,
            scrollSnapAlign: "start",
            height: "100%",
            overflowY: "auto"
          },
          ".slide-tab-c-nav": {
            display: "flex",
            flexDirection: "row",
            justifyContent: "center",
            backgroundColor: "var(--primary-bg-color)",
            position: "sticky",
            top: 0,
            zIndex: 1
          },
          ".slide-tab-c-nav-wrap": {
            display: "flex",
            flexDirection: "row",
            justifyContent: "center",
            padding: "2px 4px",
            borderRadius: "4px",
            backgroundColor: "var(--secondary-bg-color)"
          },
          ".slide-tab-c-nav-item": {
            cursor: "pointer",
            padding: "4px 8px",
            borderRadius: "4px",
            marginRight: "8px"
          },
          ".slide-tab-c-nav-item.active": {
            backgroundColor: "var(--primary-accent-color)",
            color: "white"
          }
        };
        bindGlobalStyle("slide-tab-c-box", css2);
        const ref = {};
        let slideIndex = 0;
        let manualScroll = false;
        let scrollEndTimer = null;
        const drawerScroll = () => {
          if (manualScroll) {
            return;
          }
          if (scrollEndTimer) {
            clearTimeout(scrollEndTimer);
          }
          scrollEndTimer = setTimeout(() => {
            drawerScrollStop();
          }, 100);
        };
        const resetSlides = (index) => {
          const dots = ref.$all(".slide-tab-c-nav-item");
          for (let i = 0; i < dots.length; i++) {
            dots[i].classList.toggle("active", i === index);
          }
        };
        const drawerScrollStop = () => {
          const drawer = ref.$(".slide-tab-c-list");
          const width = drawer.clientWidth;
          const currentScrollIndex = Math.round(drawer.scrollLeft / width);
          slideIndex = currentScrollIndex;
          resetSlides(slideIndex);
        };
        const moveSlide = (slideIndex2) => {
          const drawer = ref.$(".slide-tab-c-list");
          const children = ref.$all(".slide-tab-c-slide");
          if (!drawer || !children || children.length === 0) {
            return;
          }
          const target = children[slideIndex2];
          if (!target) {
            return;
          }
          const offsetLeft = target.offsetLeft;
          manualScroll = true;
          drawer.scrollTo({
            left: offsetLeft,
            behavior: "smooth"
          });
          resetSlides(slideIndex2);
          setTimeout(() => {
            manualScroll = false;
          }, 300);
        };
        return /* @__PURE__ */ jsx("section", { class: "slide-tab-c-box", ref, children: [
          /* @__PURE__ */ jsx("div", { class: "slide-tab-c-nav", children: /* @__PURE__ */ jsx("div", { class: "slide-tab-c-nav-wrap", children: props.pages.map((page, index) => /* @__PURE__ */ jsx(
            "div",
            {
              class: `slide-tab-c-nav-item ${index === 0 ? "active" : ""}`,
              onClick: (event) => {
                event.preventDefault();
                moveSlide(index);
              },
              children: page.title
            }
          )) }) }),
          /* @__PURE__ */ jsx("div", { class: "slide-tab-c-list no-scrollbar-container", onScroll: drawerScroll, children: props.pages.map((page) => /* @__PURE__ */ jsx("div", { class: "slide-tab-c-slide no-scrollbar-container", children: page.content })) })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/components/stars-component.tsx
  var StarsComponent;
  var init_stars_component = __esm({
    "node_modules/lupine.components/src/components/stars-component.tsx"() {
      init_src2();
      init_jsx_runtime();
      StarsComponent = (props) => {
        const css2 = {
          display: "inline-flex",
          flexDirection: "row",
          alignItems: "center",
          gap: "2px",
          padding: "4px",
          ".stars-label": {
            color: "#9d9d9d",
            cursor: "pointer",
            display: "flex",
            alignItems: "center",
            "&.active": {
              color: "blue"
            },
            ".full, &.active .outline": {
              display: "none"
            },
            "&.active .full, .outline": {
              display: "inline"
            },
            ".ifc-icon": {
              backgroundColor: "unset"
            }
          },
          touchAction: "none",
          userSelect: "none"
        };
        bindGlobalStyle("stars-box", css2);
        const setValue = (value) => {
          props.value = value;
          const stars = ref.$all(".stars-label");
          stars.forEach((star, index) => {
            star.classList.toggle("active", index < value);
          });
        };
        const calcValue = (clientX) => {
          const el = ref.current;
          if (!el) return props.value;
          const rect = el.getBoundingClientRect();
          if (rect.width === 0) return props.value;
          const x = clientX - rect.left;
          let v = Math.ceil(x / rect.width * props.maxLength);
          v = Math.max(1, Math.min(props.maxLength, v));
          return v;
        };
        let mv = false;
        const onPointerDown = (ev) => {
          mv = true;
          ref.current.setPointerCapture(ev.pointerId);
          const v = calcValue(ev.clientX);
          setValue(v);
        };
        const onPointerMove = (ev) => {
          if (!mv) return;
          const v = calcValue(ev.clientX);
          setValue(v);
        };
        const onPointerUp = (ev) => {
          var _a;
          if (mv) {
            ref.current.releasePointerCapture(ev.pointerId);
            mv = false;
            (_a = props.onChange) == null ? void 0 : _a.call(props, props.value);
          }
        };
        if (props.hook) {
          props.hook.setValue = (value) => {
            setValue(value);
          };
          props.hook.getValue = () => props.value;
        }
        const fullIcon = props.fullIcon || /* @__PURE__ */ jsx("i", { class: "ifc-icon ma-cards-heart full" });
        const outlineIcon = props.outlineIcon || /* @__PURE__ */ jsx("i", { class: "ifc-icon ma-cards-heart-outline outline" });
        const ref = {};
        return /* @__PURE__ */ jsx(
          "div",
          {
            style: { fontSize: props.fontSize || "20px" },
            ref,
            class: "stars-box",
            onPointerDown,
            onPointerMove,
            onPointerUp,
            children: Array.from({ length: props.maxLength }).map((_, index) => /* @__PURE__ */ jsx("label", { class: "stars-label" + (index < props.value ? " active" : ""), children: [
              fullIcon,
              outlineIcon
            ] }, index))
          }
        );
      };
    }
  });

  // node_modules/lupine.components/src/components/svg.tsx
  var Svg;
  var init_svg = __esm({
    "node_modules/lupine.components/src/components/svg.tsx"() {
      init_jsx_runtime();
      Svg = ({
        children,
        width,
        height,
        color
      }) => {
        let content = children || "";
        if (content.startsWith("data:image/svg+xml,")) {
          content = decodeURIComponent(content.slice("data:image/svg+xml,".length));
        } else if (content.includes("%") && content.includes("<svg")) {
          content = decodeURIComponent(content);
        }
        const css2 = {
          svg: {
            maxWidth: "100%",
            maxHeight: "100%",
            width,
            height,
            fill: color
          }
        };
        return /* @__PURE__ */ jsx("div", { css: css2, dangerouslySetInnerHTML: content });
      };
    }
  });

  // node_modules/lupine.components/src/components/switch-option-component.tsx
  var SwitchOptionComponent;
  var init_switch_option_component = __esm({
    "node_modules/lupine.components/src/components/switch-option-component.tsx"() {
      init_src2();
      init_jsx_runtime();
      SwitchOptionComponent = (props) => {
        const css2 = {
          display: "flex",
          flexDirection: "row",
          borderRadius: "9999px",
          padding: "2px 4px",
          fontSize: "0.7rem",
          backgroundColor: "#e7e7e7",
          width: "fit-content",
          ".switch-btn": {
            padding: "4px",
            borderRadius: "50%",
            border: "none",
            background: "transparent",
            color: "inherit",
            cursor: "pointer",
            transition: "all 0.2s"
          },
          ".switch-btn:first-child": {
            marginRight: "4px"
          },
          ".switch-btn.active": {
            backgroundColor: "#fff",
            color: "#000000",
            boxShadow: "2px 1px 2px 1px rgb(189 189 189)"
          }
        };
        bindGlobalStyle("switch-option-box", css2);
        const onNotationChange = (value) => {
          var _a;
          props.defaultOption = value;
          const btns = ref.$all(".switch-btn");
          btns[0].classList.toggle("active", value === props.option1);
          btns[1].classList.toggle("active", value === props.option2);
          (_a = props.onChange) == null ? void 0 : _a.call(props, value);
        };
        if (props.hook) {
          props.hook.setValue = (value) => {
            onNotationChange(value);
          };
          props.hook.getValue = () => props.defaultOption;
        }
        const ref = {};
        return /* @__PURE__ */ jsx("div", { style: { fontSize: props.fontSize }, ref, class: "switch-option-box", children: [
          /* @__PURE__ */ jsx(
            "button",
            {
              onClick: () => onNotationChange(props.option1),
              className: `switch-btn ${props.defaultOption === props.option1 ? "active" : ""}`,
              children: props.option1
            }
          ),
          /* @__PURE__ */ jsx(
            "button",
            {
              onClick: () => onNotationChange(props.option2),
              className: `switch-btn ${props.defaultOption === props.option2 ? "active" : ""}`,
              children: props.option2
            }
          )
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/components/tabs.tsx
  var Tabs;
  var init_tabs = __esm({
    "node_modules/lupine.components/src/components/tabs.tsx"() {
      init_src();
      init_lib2();
      init_jsx_runtime();
      Tabs = ({ pages, defaultIndex, topClassName, pagePadding, hook: refUpdate }) => {
        let newIndex = typeof defaultIndex === "number" ? defaultIndex : 0;
        const clearIndex = () => {
          const header = ref.$(`.&tabs > div > .tab.active`);
          header && header.classList.remove("active");
          const page = ref.$(`.&pages > .page.active`);
          page && page.classList.remove("active");
        };
        const updateIndex = (index) => {
          clearIndex();
          const doms = ref.$all(`.&tabs > div > .tab`);
          if (index >= 0 && index < doms.length) {
            doms[index].classList.add("active");
            const pages2 = ref.$all(`.&pages > .page`);
            pages2[index].classList.add("active");
            (refUpdate == null ? void 0 : refUpdate.indexChanged) && (refUpdate == null ? void 0 : refUpdate.indexChanged(index));
          }
        };
        const removePage = (index) => {
          const doms = ref.$all(`.&tabs > div > .tab`);
          if (index >= 0 && index < doms.length) {
            const newIndex2 = index === doms.length - 1 ? index - 1 : index;
            const isAct = doms[index].classList.contains("active");
            doms[index].parentNode.remove();
            const pages2 = ref.$all(`.&pages > .page`);
            pages2[index].remove();
            if (isAct) {
              updateIndex(newIndex2);
            }
          }
        };
        const removePageFromX = (event) => {
          stopPropagation(event);
          const tab = event.target.parentNode;
          const index = Array.prototype.indexOf.call(tab.parentNode.parentNode.children, tab.parentNode);
          removePage(index);
        };
        const newPage = async (title, page, index) => {
          const allTabs = ref.$all(`.&tabs > div > .tab`);
          let newPageIndex = allTabs.length;
          if (typeof index === "number" && index >= 0 && index < allTabs.length) {
            newPageIndex = index;
          }
          clearIndex();
          const newTab2 = createTabHeader(title, " active");
          const newTab = document.createElement("div");
          const newPage2 = document.createElement("div");
          newPage2.className = "page";
          if (newPageIndex === allTabs.length) {
            ref.$(`.&tabs`).appendChild(newTab);
            ref.$(`.&pages`).appendChild(newPage2);
          } else {
            ref.$(`.&tabs`).insertBefore(newTab, allTabs[newPageIndex]);
            const pages2 = ref.$all(`.&pages > .page`);
            ref.$(`.&pages`).insertBefore(newPage2, pages2[newPageIndex]);
          }
          await mountInnerComponent(newTab, newTab2);
          await mountInnerComponent(newPage2, page);
          updateIndex(newPageIndex);
        };
        const createTabHeader = (title, className) => {
          return /* @__PURE__ */ jsx("div", { onClick: onTabClick, class: "tab" + className, children: [
            title,
            /* @__PURE__ */ jsx("span", { class: "modal-close", onClick: removePageFromX, children: "\xD7" })
          ] });
        };
        const onTabClick = (event) => {
          stopPropagation(event);
          const tab = event.target;
          const index = Array.prototype.indexOf.call(tab.parentNode.parentNode.children, tab.parentNode);
          updateIndex(index);
        };
        const flashTitle = (index) => {
          const doms = ref.$all(`.&tabs > div > .tab`);
          if (index >= 0 && index < doms.length) {
            doms[index].classList.add("flash");
            setTimeout(() => {
              doms[index].classList.remove("flash");
            }, 1e3);
          }
        };
        if (refUpdate) {
          refUpdate.updateTitle = (index, title) => {
            const doms = ref.$all(`.&tabs > div > .tab`);
            if (index >= 0 && index < doms.length) {
              doms[index].innerHTML = title;
            }
          };
          refUpdate.updateIndex = updateIndex;
          refUpdate.removePage = removePage;
          refUpdate.newPage = newPage;
          refUpdate.getIndex = () => {
            const header = ref.$(`.&tabs > div > .tab.active`);
            return header ? Array.prototype.indexOf.call(header.parentNode.parentNode.children, header.parentNode) : -1;
          };
          refUpdate.getCount = () => {
            const doms = ref.$all(`.&tabs > div > .tab`);
            return doms.length;
          };
          refUpdate.findAndActivate = (title) => {
            const doms = ref.$all(`.&tabs > div > .tab`);
            for (let i = 0; i < doms.length; i++) {
              if (doms[i].innerText === title) {
                updateIndex(i);
                flashTitle(i);
                return true;
              }
            }
            return false;
          };
        }
        const css2 = {
          display: "flex",
          "flex-direction": "column",
          width: "100%",
          height: "100%",
          // border: 'solid 1px grey',
          "&:not(:has(.pages .page))": {
            // hide tabs when there is no tabs (not need to show borders)
            display: "none"
          },
          "> .&tabs": {
            display: "flex",
            height: "auto",
            "border-bottom": "1px solid grey",
            "overflow-x": "auto",
            "overflow-y": "hidden",
            "scrollbar-width": "thin",
            "scrollbar-color": "#ababab4d #d5d5d552",
            "> div > .tab": {
              padding: "2px 3px",
              width: "auto",
              "font-size": "smaller",
              "text-overflow": "ellipsis",
              overflow: "hidden",
              "white-space": "nowrap",
              margin: "1px 1px 0 1px",
              cursor: "pointer",
              position: "relative",
              // transition: 'all 1s',
              "border-top-right-radius": "4px",
              "border-top-left-radius": "4px",
              "border-top": "solid 1px var(--primary-border-color)",
              "border-left": "solid 1px var(--primary-border-color)",
              "border-right": "solid 1px var(--primary-border-color)",
              // 'border-bottom': '2px solid transparent',
              color: "var(--activatable-color-normal)",
              backgroundColor: "var(--activatable-bg-color-normal)"
            },
            "> div > .tab:hover": {
              padding: "3px 3px 1px 3px"
              // color: 'var(--activatable-color-hover)',
              // backgroundColor: 'var(--activatable-bg-color-hover)',
            },
            "> div > .tab.flash": {
              backgroundColor: "red"
            },
            "> div > .active": {
              // 'border-bottom': '2px solid red',
              color: "var(--activatable-color-selected)",
              backgroundColor: "var(--activatable-bg-color-selected)",
              marginBottom: "-1px",
              borderBottom: "1px solid #FFFFFF00"
            },
            "> div > .tab > .modal-close": {
              display: "none",
              float: "right",
              fontSize: "12px",
              fontWeight: "bold",
              cursor: "pointer",
              position: "absolute",
              top: "-4px",
              right: "1px"
            },
            "> div > .tab:hover > .modal-close": {
              display: "inline-block",
              color: "#ff0000"
            }
          },
          "> .&pages": {
            display: "flex",
            flex: "1",
            position: "relative",
            "> .page": {
              display: "none",
              position: "absolute",
              padding: pagePadding || "0px",
              overflow: "auto",
              width: "100%",
              maxWidth: "100%",
              height: "100%",
              overflowX: "auto",
              overflowY: "auto"
            },
            "> .active": {
              display: "inline-block"
            }
          }
        };
        const tabGlobalCssId = getGlobalStylesId(css2);
        bindGlobalStyle(tabGlobalCssId, css2);
        const ref = {
          globalCssId: tabGlobalCssId
        };
        const cssTab = {
          "&tabs": {
            display: "flex"
          },
          "&pages": {
            display: "flex"
          }
        };
        return /* @__PURE__ */ jsx("div", { ref, css: cssTab, class: topClassName ? " " + topClassName : "", children: [
          /* @__PURE__ */ jsx("div", { class: "&tabs tabs", children: pages.map((i, index) => {
            const className = index === newIndex ? " active" : "";
            return /* @__PURE__ */ jsx("div", { children: createTabHeader(i.title, className) });
          }) }),
          /* @__PURE__ */ jsx("div", { class: "&pages pages", children: pages.map((i, index) => {
            const className = index === newIndex ? " active" : "";
            return /* @__PURE__ */ jsx("div", { class: "page" + className, children: i.page });
          }) })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/components/text-glow.tsx
  var TextGlow;
  var init_text_glow = __esm({
    "node_modules/lupine.components/src/components/text-glow.tsx"() {
      init_src();
      init_jsx_runtime();
      TextGlow = (props) => {
        const css2 = {
          width: `100%`,
          height: `100%`,
          textAlign: "center",
          color: props.color || "#22b8ff",
          padding: props.padding || "10px",
          fontSize: props.fontSize || "30px",
          fontWeight: props.fontWeight || "500",
          ".text-glow": {
            animation: "text-glow-a 1.5s infinite alternate"
          },
          "@keyframes text-glow-a": {
            "0%": {
              textShadow: "0 0 5px #ff005e, 0 0 10px #ff005e, 0 0 20px #ff005e, 0 0 40px #ff005e, 0 0 80px #ff005e"
            },
            "100%": {
              textShadow: "0 0 10px #00d4ff, 0 0 20px #00d4ff, 0 0 40px #00d4ff, 0 0 80px #00d4ff, 0 0 160px #00d4ff"
            }
          }
        };
        bindGlobalStyle("text-glow-top", css2);
        return /* @__PURE__ */ jsx("div", { class: "text-glow-top", children: /* @__PURE__ */ jsx("div", { class: "text-glow", children: props.text }) });
      };
    }
  });

  // node_modules/lupine.components/src/components/text-scale.tsx
  var TextScale;
  var init_text_scale = __esm({
    "node_modules/lupine.components/src/components/text-scale.tsx"() {
      init_src();
      init_jsx_runtime();
      TextScale = (props) => {
        const css2 = {
          width: `100%`,
          height: `100%`,
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          color: props.color || "#22b8ff",
          fontSize: props.fontSize || "30px",
          fontWeight: props.fontWeight || "500",
          ".text-scale": {
            animation: "text-scale 1.5s infinite alternate",
            backgroundColor: props.backgroundColor || "#a1ffe8",
            padding: props.padding || "10px",
            borderRadius: "5px"
          },
          "@keyframes text-scale": {
            "0%, 100%": {
              transform: "scale(1)"
            },
            "40%": {
              transform: "scale(0.7)"
            }
          }
        };
        bindGlobalStyle("text-scale-top", css2);
        return /* @__PURE__ */ jsx("div", { class: "text-scale-top", children: /* @__PURE__ */ jsx("div", { class: "text-scale", children: props.text }) });
      };
    }
  });

  // node_modules/lupine.components/src/components/text-wave.tsx
  var TextWave;
  var init_text_wave = __esm({
    "node_modules/lupine.components/src/components/text-wave.tsx"() {
      init_src();
      init_jsx_runtime();
      TextWave = (props) => {
        const cssMap = {};
        props.text.split("").forEach((char, index) => {
          cssMap[`.span${index}`] = { animationDelay: `${index * 0.1}s` };
        });
        const css2 = {
          width: `100%`,
          height: `100%`,
          textAlign: "center",
          color: props.color || "#22b8ff",
          padding: props.padding || "10px",
          fontSize: props.fontSize || "20px",
          fontWeight: props.fontWeight,
          textShadow: "1px -1px #ffffff, -2px 2px #999, -6px 7px 3px #131f5be6",
          ".text-wave.wave-animetion span": {
            display: "inline-block",
            padding: "0 4px",
            animation: "wave-text 1s ease-in-out infinite"
          },
          ".text-wave.wave-animetion": {
            marginTop: "0.6em",
            ...cssMap
          },
          "@keyframes wave-text": {
            "0%": {
              transform: "translateY(0em)"
            },
            "60%": {
              transform: "translateY(-0.6em)"
            },
            "100%": {
              transform: "translateY(0em)"
            }
          }
        };
        bindGlobalStyle("text-wave-top", css2);
        return /* @__PURE__ */ jsx("div", { class: "text-wave-top", children: /* @__PURE__ */ jsx("div", { class: "text-wave wave-animetion", children: props.text.split("").map((char, index) => /* @__PURE__ */ jsx("span", { class: `span${index}`, children: char })) }) });
      };
    }
  });

  // node_modules/lupine.components/src/components/theme-selector.tsx
  var ThemeSelector;
  var init_theme_selector = __esm({
    "node_modules/lupine.components/src/components/theme-selector.tsx"() {
      init_src();
      init_popup_menu();
      init_jsx_runtime();
      ThemeSelector = ({ className, icon, noUpdateLabel }) => {
        const css2 = {
          display: "flex",
          flexDirection: "column",
          alignSelf: "end"
        };
        const handleSelected = (themeName) => {
          updateTheme(themeName);
        };
        const currentTheme = getCurrentTheme();
        const list2 = [];
        for (let themeName in currentTheme.themes) {
          list2.push(themeName);
        }
        return /* @__PURE__ */ jsx("div", { css: css2, class: ["theme-switch", className].join(" "), title: "Select theme", children: /* @__PURE__ */ jsx(
          PopupMenu,
          {
            list: list2,
            defaultValue: currentTheme.themeName,
            handleSelected,
            icon,
            noUpdateLabel
          }
        ) });
      };
    }
  });

  // node_modules/lupine.components/src/components/toggle-base.tsx
  var TogglePlayButtonSize, TogglePlayButton, ToggleButton, ToggleWaveFrame, ToggleBaseSize, ToggleBase;
  var init_toggle_base = __esm({
    "node_modules/lupine.components/src/components/toggle-base.tsx"() {
      init_src();
      init_jsx_runtime();
      TogglePlayButtonSize = {
        Small: { w: 50, h: 50 },
        Medium: { w: 70, h: 70 },
        Large: { w: 90, h: 90 }
      };
      TogglePlayButton = (props) => {
        const css2 = {
          width: `100%`,
          height: `100%`,
          borderRadius: "50%",
          backgroundColor: "#3b29cc",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          transition: "all 0.3s",
          cursor: "pointer",
          "&:hover": {
            opacity: 0.8
          },
          ".play-icon": {
            width: "50%",
            height: "50%",
            transition: "all 0.2s ease-in-out",
            backgroundColor: "#fff"
          },
          "&.toggle-off .play-icon": {
            clipPath: "polygon(20% 0, 20% 100%, 90% 50%, 90% 50%, 90% 50%, 90% 50%, 90% 50%, 90% 50%, 90% 50%)",
            translate: "6% 0"
          },
          "&.toggle-on .play-icon": {
            clipPath: "polygon(0 0, 0 100%, 33.33% 100%, 33.33% 0, 66.66% 0, 100% 0, 100% 100%, 66.66% 100%, 66.66% 0)",
            translate: "0 0"
          },
          "&.disabled": {
            cursor: "not-allowed",
            backgroundColor: "#5d578b"
          }
        };
        bindGlobalStyle("toggle-play-button-component", css2);
        const Btn = () => /* @__PURE__ */ jsx(
          "div",
          {
            class: `toggle-play-button-component toggle-placeholder ${props.checked ? "toggle-on" : "toggle-off"}${props.disabled ? " disabled" : ""}`,
            style: { backgroundColor: props.backgroundColor },
            children: /* @__PURE__ */ jsx("div", { class: "play-icon", style: { backgroundColor: props.textColor } })
          }
        );
        return props.noWave ? /* @__PURE__ */ jsx(ToggleBase, { ...props, children: /* @__PURE__ */ jsx(Btn, {}) }) : /* @__PURE__ */ jsx(ToggleBase, { ...props, children: /* @__PURE__ */ jsx(ToggleWaveFrame, { children: /* @__PURE__ */ jsx(Btn, {}) }) });
      };
      ToggleButton = (props) => {
        const css2 = {
          // width: `${props.size + 5}px`,
          // height: `${props.size + 5}px`,
          "&.disabled": {
            cursor: "not-allowed"
          },
          "&.toggle-on .on, &.toggle-off .off": {
            display: "block"
          },
          "&.toggle-on .off, &.toggle-off .on": {
            display: "none"
          }
        };
        return /* @__PURE__ */ jsx(ToggleBase, { ...props, size: { w: "auto", h: "auto" }, children: /* @__PURE__ */ jsx(
          "div",
          {
            css: css2,
            class: `toggle-button-component toggle-placeholder ${props.checked ? "toggle-on" : "toggle-off"}${props.disabled ? " disabled" : ""}`,
            children: [
              /* @__PURE__ */ jsx("div", { class: "on", children: props.onText }),
              /* @__PURE__ */ jsx("div", { class: "off", children: props.offText })
            ]
          }
        ) });
      };
      ToggleWaveFrame = (props) => {
        const css2 = {
          width: `100%`,
          height: `100%`,
          "@keyframes pulse-border": {
            "0%": {
              transform: "scale(0.6)",
              opacity: 1
            },
            "100%": {
              transform: "scale(1)",
              opacity: 0
            }
          },
          ".toggle-waves": {
            position: "absolute",
            width: `100%`,
            height: `100%`,
            top: "0",
            left: "0",
            borderRadius: "50%",
            backgroundColor: "#eb205580",
            opacity: 0,
            animation: "pulse-border 3s ease-in-out infinite"
          },
          ".toggle-waves-1": {
            "-webkit-animation-delay": "0s",
            "animation-delay": "0s"
          },
          ".toggle-waves-2": {
            "-webkit-animation-delay": "1s",
            "animation-delay": "1s"
          },
          ".toggle-waves-3": {
            "-webkit-animation-delay": "2s",
            "animation-delay": "2s"
          },
          ".toggle-waves-box": {
            position: "absolute",
            width: `100%`,
            height: `100%`,
            top: "0",
            left: "0",
            padding: `18%`
          },
          "&.disabled .toggle-waves": {
            backgroundColor: "#5d578b"
          }
        };
        bindGlobalStyle("toggle-waves-box", css2);
        return /* @__PURE__ */ jsx("div", { class: "toggle-waves-box toggle-placeholder", children: [
          /* @__PURE__ */ jsx("div", { class: "toggle-waves toggle-waves-1" }),
          /* @__PURE__ */ jsx("div", { class: "toggle-waves toggle-waves-2" }),
          /* @__PURE__ */ jsx("div", { class: "toggle-waves toggle-waves-3" }),
          /* @__PURE__ */ jsx("div", { class: "toggle-waves-box", children: props.children })
        ] });
      };
      ToggleBaseSize = {
        Small: { w: 30, h: 30 },
        Medium: { w: 50, h: 50 },
        Large: { w: 70, h: 70 }
      };
      ToggleBase = (props) => {
        const applyToggle = (checked, disabled2) => {
          const childDom = ref.$all(".toggle-base-container .toggle-placeholder");
          childDom.forEach((dom) => {
            dom.classList.toggle("toggle-on", checked);
            dom.classList.toggle("toggle-off", !checked);
            dom.classList.toggle("disabled", disabled2);
          });
        };
        let disabled = props.disabled || false;
        const ref = {
          onLoad: async (el) => {
            applyToggle(props.checked || false, disabled);
          }
        };
        const onClick = (e) => {
          if (disabled) {
            return;
          }
          const checked = e.target.checked;
          applyToggle(checked, disabled);
          if (props.onClick) {
            props.onClick(checked);
          }
        };
        if (props.hook) {
          props.hook.setChecked = (checked) => {
            ref.$("input.toggle-base-checkbox").checked = checked;
            applyToggle(checked, disabled);
          };
          props.hook.getChecked = () => {
            return ref.$("input.toggle-base-checkbox").checked;
          };
          props.hook.setEnabled = (enabled) => {
            disabled = !enabled;
            const dom = ref.$("input.toggle-base-checkbox");
            dom.disabled = disabled;
            applyToggle(dom.checked, disabled);
          };
          props.hook.getEnabled = () => {
            return !disabled;
          };
        }
        const css2 = {
          ".toggle-base-box, .toggle-base-container": {
            position: "relative",
            width: `100%`,
            height: `100%`
          },
          ".toggle-base-checkbox": {
            opacity: 0,
            position: "absolute",
            pointerEvents: "none"
          }
        };
        bindGlobalStyle("toggle-base-component", css2);
        return /* @__PURE__ */ jsx(
          "div",
          {
            ref,
            css: {
              width: `${typeof props.size.w === "number" ? props.size.w + "px" : props.size.w}`,
              height: `${typeof props.size.h === "number" ? props.size.h + "px" : props.size.h}`
            },
            class: "toggle-base-component",
            children: /* @__PURE__ */ jsx("label", { class: "toggle-base-box", children: [
              /* @__PURE__ */ jsx("div", { class: "toggle-base-container", children: props.children }),
              /* @__PURE__ */ jsx(
                "input",
                {
                  type: "checkbox",
                  class: "toggle-base-checkbox",
                  checked: props.checked || false,
                  disabled,
                  onClick
                }
              )
            ] })
          }
        );
      };
    }
  });

  // node_modules/lupine.components/src/components/toggle-switch.tsx
  var ToggleSwitchSize, ToggleSwitch;
  var init_toggle_switch = __esm({
    "node_modules/lupine.components/src/components/toggle-switch.tsx"() {
      init_src();
      init_toggle_base();
      init_jsx_runtime();
      ToggleSwitchSize = /* @__PURE__ */ ((ToggleSwitchSize2) => {
        ToggleSwitchSize2["SmallSmall"] = "smallsmall";
        ToggleSwitchSize2["Small"] = "small";
        ToggleSwitchSize2["Medium"] = "medium";
        ToggleSwitchSize2["Large"] = "large";
        return ToggleSwitchSize2;
      })(ToggleSwitchSize || {});
      ToggleSwitch = (props) => {
        var _a, _b;
        const sizeH = props.size === "smallsmall" /* SmallSmall */ ? 16 : props.size === "small" /* Small */ ? 22 : props.size === "large" /* Large */ ? 42 : 34;
        const classSize = props.size === "smallsmall" /* SmallSmall */ ? "smallsmall" : props.size === "small" /* Small */ ? "small" : props.size === "large" /* Large */ ? "large" : "";
        const css2 = {
          width: `100%`,
          height: `100%`,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          "& .ts-slider": {
            position: "relative",
            cursor: "pointer",
            backgroundColor: "var(--toggle-background-color, #c7c7c7)",
            transition: ".4s",
            borderRadius: "34px",
            height: "100%",
            display: "flex",
            padding: "0 27px 0 37px",
            alignItems: "center"
          },
          "&.smallsmall .ts-slider": {
            padding: "0 8px 0 22px",
            fontSize: "0.65rem"
          },
          "&.small .ts-slider": {
            padding: "0 17px 0 27px",
            fontSize: "0.85rem"
          },
          "&.large .ts-slider": {
            padding: "0 37px 0 57px"
          },
          "& .ts-slider .ts-circle": {
            position: "absolute",
            content: "",
            height: "26px",
            width: "26px",
            left: "4px",
            bottom: "4px",
            backgroundColor: "var(--toggle-ball-color, #fff)",
            transition: ".4s",
            borderRadius: "50%"
          },
          "&.smallsmall .ts-slider .ts-circle": {
            height: "12px",
            width: "12px",
            left: "2px",
            bottom: "2px"
          },
          "&.small .ts-slider .ts-circle": {
            height: "18px",
            width: "18px",
            left: "3px",
            bottom: "2px"
          },
          "&.large .ts-slider .ts-circle": {
            height: "38px",
            width: "38px",
            left: "4px",
            bottom: "2px"
          },
          "&.toggle-on .ts-on-text": {
            display: "block"
          },
          "&.toggle-off .ts-off-text": {
            display: "block"
          },
          "&.toggle-on .ts-slider": {
            backgroundColor: "var(--primary-accent-color, #0a74c9)",
            padding: "0 47px 0 17px"
          },
          "&.smallsmall.toggle-on .ts-slider": {
            padding: "0 18px 0 12px"
          },
          "&.small.toggle-on .ts-slider": {
            padding: "0 27px 0 17px"
          },
          "&.large.toggle-on .ts-slider": {
            padding: "0 72px 0 22px"
          },
          "&.toggle-on .ts-slider .ts-circle": {
            left: "unset",
            right: "3px"
          },
          "&.disabled .ts-slider": {
            cursor: "not-allowed",
            opacity: "var(--primary-disabled-opacity)"
          }
        };
        const cssTheme = {
          '[data-theme="dark" i]': {
            "--toggle-ball-color": "#000000",
            "--toggle-background-color": "#262626"
          }
        };
        bindGlobalStyle("toggle-switch-theme", cssTheme, false, true);
        bindGlobalStyle("toggle-switch-component", css2);
        const cssSize = {
          "& .ts-on-text, & .ts-off-text": {
            display: "none",
            width: props.textWidth
          }
        };
        return /* @__PURE__ */ jsx(ToggleBase, { ...props, size: { w: "auto", h: sizeH }, children: /* @__PURE__ */ jsx(
          "div",
          {
            css: cssSize,
            class: `toggle-switch-component toggle-placeholder ${props.checked ? "toggle-on" : "toggle-off"}${props.disabled ? " disabled" : ""} ${classSize}`,
            children: /* @__PURE__ */ jsx("span", { class: "ts-slider", children: [
              /* @__PURE__ */ jsx("span", { class: "ts-on-text", children: (_a = props.text) == null ? void 0 : _a.on }),
              /* @__PURE__ */ jsx("span", { class: "ts-circle" }),
              /* @__PURE__ */ jsx("span", { class: "ts-off-text", children: (_b = props.text) == null ? void 0 : _b.off })
            ] })
          }
        ) });
      };
    }
  });

  // node_modules/lupine.components/src/components/mobile-components/icon-menu-item-props.ts
  var init_icon_menu_item_props = __esm({
    "node_modules/lupine.components/src/components/mobile-components/icon-menu-item-props.ts"() {
    }
  });

  // node_modules/lupine.components/src/components/mobile-components/mobile-footer-menu.tsx
  var MobileFooterMenu;
  var init_mobile_footer_menu = __esm({
    "node_modules/lupine.components/src/components/mobile-components/mobile-footer-menu.tsx"() {
      init_src2();
      init_jsx_runtime();
      MobileFooterMenu = (props) => {
        const css2 = {
          ".footer-menu": {
            display: "none",
            // position: 'fixed',
            // left: 0,
            // right: 0,
            // bottom: 0,
            width: "100%",
            background: "var(--sidebar-bg-color)",
            paddingBottom: "env(safe-area-inset-bottom)",
            minHeight: "50px",
            justifyContent: "space-around",
            alignItems: "center",
            borderTop: "var(--primary-border)"
          },
          ".footer-menu, .footer-menu a": {
            textDecoration: "none",
            color: props.color || "var(--primary-color)"
          },
          ".footer-menu .footer-menu-item": {
            padding: "4px 0",
            fontSize: "11px",
            height: "55px",
            // 
            width: "55px",
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            alignItems: "center"
          },
          ".footer-menu .footer-menu-item i": {
            display: "block",
            fontSize: "22px",
            marginBottom: "4px"
          },
          ".footer-menu .footer-menu-item.footer-menu-topout": {
            marginTop: "-43px",
            borderRadius: "50%",
            backgroundColor: props.topoutBackgroundColor || "#f33939",
            color: props.topoutColor || "var(--primary-color)"
          },
          ".footer-menu .footer-menu-item-a": {
            zIndex: "var(--layer-header-footer)"
          },
          ".footer-menu .footer-menu-item.active": {
            color: props.activeColor || "var(--primary-accent-color)"
          },
          [MediaQueryRange.TabletBelow]: {
            ".footer-menu": {
              display: "flex"
            }
          }
        };
        const onClick = (index, href) => {
          const items = document.querySelector(".footer-menu-item.active");
          items == null ? void 0 : items.classList.remove("active");
          const item = document.querySelector(`a:nth-child(${index + 1}) .footer-menu-item`);
          item == null ? void 0 : item.classList.add("active");
        };
        let curretnUrl = typeof window !== "undefined" ? window.location.pathname : "";
        return /* @__PURE__ */ jsx("div", { css: css2, class: "footer-menu-box", children: /* @__PURE__ */ jsx("div", { class: "footer-menu", children: props.items.map((item, index) => {
          const handleClick = (e) => {
            if (item.js) {
              e.preventDefault();
              item.js();
            }
          };
          return /* @__PURE__ */ jsx("a", { class: "footer-menu-item-a", href: item.url || "javascript:void(0)", onClick: handleClick, children: /* @__PURE__ */ jsx(
            "div",
            {
              class: `footer-menu-item ${item.topout ? "footer-menu-topout" : ""} ${curretnUrl === item.url ? "active" : ""}`,
              onClick: () => onClick(index, item.url),
              children: [
                /* @__PURE__ */ jsx("i", { class: `ifc-icon ${item.icon}` }),
                item.text
              ]
            }
          ) }, index);
        }) }) });
      };
    }
  });

  // node_modules/lupine.components/src/components/mobile-components/mobile-header-title-icon.tsx
  var MobileHeadeIconHeight, MobileHeadeBackIcon, MobileHeadeCloseIcon, MobileHeaderEmptyIcon, MobileHeaderTitleIcon;
  var init_mobile_header_title_icon = __esm({
    "node_modules/lupine.components/src/components/mobile-components/mobile-header-title-icon.tsx"() {
      init_src2();
      init_jsx_runtime();
      MobileHeadeIconHeight = "40px";
      MobileHeadeBackIcon = ({ onClick }) => {
        return /* @__PURE__ */ jsx(
          "i",
          {
            class: "ifc-icon mg-arrow_back_ios_new_outlined mhti-back-icon",
            "data-back-action": backActionHelper.genBackActionId(),
            onClick: (event) => onClick(event)
          }
        );
      };
      MobileHeadeCloseIcon = ({ onClick }) => {
        return /* @__PURE__ */ jsx("i", { class: "ifc-icon ma-close mhti-close-icon", onClick: (event) => onClick(event) });
      };
      MobileHeaderEmptyIcon = () => {
        return /* @__PURE__ */ jsx("div", { class: "mhti-empty-icon", style: { width: "28px" } });
      };
      MobileHeaderTitleIcon = ({
        title,
        onBack,
        left,
        right,
        background,
        color,
        noShadow
      }) => {
        const css2 = {
          display: "flex",
          flexDirection: "row",
          width: "100%",
          padding: "6px 0",
          // backgroundColor: 'var(--activatable-bg-color-normal)',
          // boxShadow: 'var(--mobile-header-shadow)',
          color: color || "var(--primary-color)",
          background: background || "var(--activatable-bg-color-normal)",
          boxShadow: noShadow ? "unset" : "var(--mobile-header-shadow)",
          zIndex: "var(--layer-inside)",
          // bring boxShadow to front
          ".mhti-title": {
            display: "flex",
            fontSize: "1.3rem",
            flex: "1",
            color: "var(--activatable-text-color-normal)",
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap",
            alignItems: "center",
            justifyContent: "center"
          },
          ".mhti-title > *": {
            display: "flex",
            width: "100%",
            alignItems: "center",
            justifyContent: "center"
          },
          ".mhti-left, .mhti-right": {
            height: MobileHeadeIconHeight,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            cursor: "pointer",
            fontSize: "16px"
          },
          ".mhti-left": {
            paddingLeft: "8px"
          },
          ".mhti-right": {
            paddingRight: "8px"
          },
          ".mhti-left i, .mhti-right i": {
            fontSize: "28px"
          }
        };
        const domLeft = left instanceof HtmlVar ? left : new HtmlVar(left);
        const domCenter = title instanceof HtmlVar ? title : new HtmlVar(title);
        const domRight = right instanceof HtmlVar ? right : new HtmlVar(right);
        return /* @__PURE__ */ jsx("div", { css: css2, class: "mobile-header-title-icon-top", children: [
          /* @__PURE__ */ jsx("div", { class: "mhti-left", children: domLeft.node }),
          /* @__PURE__ */ jsx("div", { class: "mhti-title", children: domCenter.node }),
          /* @__PURE__ */ jsx("div", { class: "mhti-right", children: domRight.node })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/components/mobile-components/mobile-header-with-back.tsx
  var HeaderWithBackFrameHeight, HeaderWithBackFrameLeft, HeaderWithBackFrameRight, HeaderWithBackFrameEmpty, HeaderWithBackFrame;
  var init_mobile_header_with_back = __esm({
    "node_modules/lupine.components/src/components/mobile-components/mobile-header-with-back.tsx"() {
      init_src2();
      init_mobile_header_title_icon();
      init_jsx_runtime();
      HeaderWithBackFrameHeight = "40px";
      HeaderWithBackFrameLeft = ({ onClick }) => {
        return /* @__PURE__ */ jsx(
          "i",
          {
            class: "ifc-icon mg-arrow_back_ios_new_outlined header-back-left-icon",
            "data-back-action": backActionHelper.genBackActionId(),
            onClick: (event) => onClick(event)
          }
        );
      };
      HeaderWithBackFrameRight = ({ onClick }) => {
        return /* @__PURE__ */ jsx("i", { class: "ifc-icon ma-close header-back-right-icon", onClick: (event) => onClick(event) });
      };
      HeaderWithBackFrameEmpty = () => {
        return /* @__PURE__ */ jsx("div", { class: "header-back-top-empty" });
      };
      HeaderWithBackFrame = ({
        children,
        title,
        onBack,
        left,
        right,
        noHeader = false,
        background,
        color,
        noShadow,
        contentColor,
        contentBackground
      }) => {
        left = left || /* @__PURE__ */ jsx(HeaderWithBackFrameLeft, { onClick: onBack });
        right = right || /* @__PURE__ */ jsx(HeaderWithBackFrameRight, { onClick: onBack });
        const css2 = {
          display: "flex",
          flexDirection: "column",
          width: "100%",
          height: "100%",
          minHeight: "100%",
          background: background || "var(--activatable-bg-color-normal)",
          ".header-back-top": {
            display: "flex",
            flexDirection: "row",
            width: "100%",
            padding: "6px 0",
            backgroundColor: "var(--activatable-bg-color-normal)",
            boxShadow: "var(--mobile-header-shadow)"
          },
          ".header-back-content": {
            display: "flex",
            flex: "1",
            flexDirection: "column",
            overflowY: "auto",
            scrollbarWidth: "none",
            position: "relative",
            color: contentColor || "var(--primary-color)",
            background: contentBackground || "var(--activatable-bg-color-normal)",
            "&::-webkit-scrollbar": {
              display: "none"
              // height: '0',
            }
          },
          ".header-back-title": {
            fontSize: "15px",
            flex: "1",
            color: "var(--activatable-text-color-normal)",
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          },
          ".header-back-left, .header-back-right": {
            // width: HeaderWithBackFrameHeight,
            height: HeaderWithBackFrameHeight,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            cursor: "pointer",
            fontSize: "16px",
            padding: "0 8px"
          },
          ".header-back-left i, .header-back-right i": {
            fontSize: "28px"
          }
        };
        const domLeft = left instanceof HtmlVar ? left : new HtmlVar(left);
        const domCenter = title instanceof HtmlVar ? title : new HtmlVar(title);
        const domRight = right instanceof HtmlVar ? right : new HtmlVar(right);
        const ref = {};
        return /* @__PURE__ */ jsx("div", { ref, css: css2, class: "header-back-frame", children: [
          !noHeader && /* @__PURE__ */ jsx(
            MobileHeaderTitleIcon,
            {
              onBack,
              left: domLeft,
              title: domCenter,
              right: domRight,
              background,
              color,
              noShadow
            }
          ),
          /* @__PURE__ */ jsx("div", { class: "header-back-content", children })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/components/mobile-components/mobile-header-component.tsx
  var MobileHeaderHelper, mobileHeaderHelper, MobileHeaderLeft, MobileHeaderCenter, MobileHeaderRight, MobileHeaderHide, MobileHeaderComponent;
  var init_mobile_header_component = __esm({
    "node_modules/lupine.components/src/components/mobile-components/mobile-header-component.tsx"() {
      init_src2();
      init_jsx_runtime();
      MobileHeaderHelper = class _MobileHeaderHelper {
        static instance;
        leftContent = new HtmlVar("");
        centerContent = new HtmlVar("");
        rightContent = new HtmlVar("");
        constructor() {
        }
        static getInstance() {
          if (!_MobileHeaderHelper.instance) {
            _MobileHeaderHelper.instance = new _MobileHeaderHelper();
          }
          return _MobileHeaderHelper.instance;
        }
        setLeftContent(content) {
          this.leftContent.value = content;
        }
        getLeftContent() {
          return this.leftContent;
        }
        setCenterContent(content) {
          this.centerContent.value = content;
        }
        getCenterContent() {
          return this.centerContent;
        }
        setRightContent(content) {
          this.rightContent.value = content;
        }
        getRightContent() {
          return this.rightContent;
        }
        hideHeader() {
          this.leftContent.value = "";
          this.centerContent.value = "";
          this.rightContent.value = "";
        }
      };
      mobileHeaderHelper = MobileHeaderHelper.getInstance();
      MobileHeaderLeft = (props) => {
        mobileHeaderHelper.setLeftContent(props.children);
        return /* @__PURE__ */ jsx(Fragment, {});
      };
      MobileHeaderCenter = (props) => {
        mobileHeaderHelper.setCenterContent(props.children);
        return /* @__PURE__ */ jsx(Fragment, {});
      };
      MobileHeaderRight = (props) => {
        mobileHeaderHelper.setRightContent(props.children);
        return /* @__PURE__ */ jsx(Fragment, {});
      };
      MobileHeaderHide = () => {
        mobileHeaderHelper.hideHeader();
        return /* @__PURE__ */ jsx(Fragment, {});
      };
      MobileHeaderComponent = (props) => {
        const css2 = {
          display: "flex",
          flexDirection: "row",
          width: "100%",
          height: "auto",
          // padding: '2px 0',
          // boxShadow: 'var(--mobile-header-shadow)', //  2px 
          "& > *": {
            height: "100%"
          },
          ".mobile-header-center": {
            flex: 1
          }
        };
        return /* @__PURE__ */ jsx("div", { css: css2, class: "mobile-header-component", children: [
          /* @__PURE__ */ jsx("div", { class: "mobile-header-left", children: mobileHeaderHelper.getLeftContent().node }),
          /* @__PURE__ */ jsx("div", { class: "mobile-header-center", children: mobileHeaderHelper.getCenterContent().node }),
          /* @__PURE__ */ jsx("div", { class: "mobile-header-right", children: mobileHeaderHelper.getRightContent().node })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/components/mobile-components/mobile-side-menu.tsx
  var MobileSideMenuHelper, MobileSideMenu;
  var init_mobile_side_menu = __esm({
    "node_modules/lupine.components/src/components/mobile-components/mobile-side-menu.tsx"() {
      init_src2();
      init_jsx_runtime();
      MobileSideMenuHelper = class _MobileSideMenuHelper {
        static show() {
          const ref = document.querySelector(".mobile-side-menu-mask");
          if (!ref) return;
          ref.classList.add("show");
          const menuDom = ref.querySelector(".mobile-side-menu");
          if (menuDom) {
            menuDom.style.transition = "";
            menuDom.style.transform = "";
          }
          ref.style.backgroundColor = "";
          void ref.offsetWidth;
          ref.classList.add("animate-show");
          const backActionId = backActionHelper.genBackActionId();
          ref.setAttribute("data-back-action", backActionId);
        }
        static hide() {
          const ref = document.querySelector(".mobile-side-menu-mask");
          if (!ref) return;
          ref.removeAttribute("data-back-action");
          const menuDom = ref.querySelector(".mobile-side-menu");
          if (menuDom) {
            menuDom.style.transition = "";
            menuDom.style.transform = "";
          }
          ref.style.backgroundColor = "";
          ref.classList.remove("animate-show");
          setTimeout(() => {
            ref.classList.remove("show");
          }, 300);
        }
        static isTouchEventAdded = false;
        static addTouchEvent(maskDom) {
          if (this.isTouchEventAdded) {
            return;
          }
          this.isTouchEventAdded = true;
          let touchstartY = 0;
          let touchstartX = 0;
          let direction = "";
          let moveStart = false;
          let isOpen = false;
          let menuDom = null;
          let menuWidth = 0;
          document.addEventListener("touchstart", (e) => {
            touchstartY = e.touches[0].clientY;
            touchstartX = e.touches[0].clientX;
            direction = "";
            moveStart = false;
            isOpen = maskDom == null ? void 0 : maskDom.classList.contains("show");
            menuDom = document.querySelector(".mobile-side-menu");
            if (menuDom) {
              menuWidth = menuDom.offsetWidth || 210;
            }
            if (isOpen) {
              if (touchstartX > 80) {
                moveStart = true;
              } else {
                moveStart = true;
              }
            } else {
              if (touchstartX < 40) {
                moveStart = true;
                maskDom == null ? void 0 : maskDom.classList.add("show");
                if (menuDom) {
                  menuDom.style.transition = "none";
                  menuDom.style.transform = `translateX(-100%)`;
                }
              }
            }
          });
          document.addEventListener("touchmove", (e) => {
            if (!moveStart) {
              return;
            }
            const currentX = e.touches[0].clientX;
            const deltaX = currentX - touchstartX;
            if (direction === "") {
              if (Math.abs(deltaX) > 0) {
                direction = "X";
              } else {
                moveStart = false;
                return;
              }
            }
            if (menuDom) {
              menuDom.style.transition = "none";
              if (!isOpen) {
                const translateX = Math.min(0, -menuWidth + deltaX);
                menuDom.style.transform = `translateX(${translateX}px)`;
                const progress = (menuWidth + translateX) / menuWidth;
                maskDom.style.backgroundColor = `rgba(0,0,0,${0.69 * progress})`;
              } else {
                const translateX = Math.min(0, deltaX);
                menuDom.style.transform = `translateX(${translateX}px)`;
                const progress = (menuWidth + translateX) / menuWidth;
                if (progress >= 0) {
                  maskDom.style.backgroundColor = `rgba(0,0,0,${0.69 * progress})`;
                }
              }
            }
          });
          document.addEventListener("touchend", (e) => {
            if (!moveStart) return;
            const currentX = e.changedTouches[0].clientX;
            const deltaX = currentX - touchstartX;
            moveStart = false;
            direction = "";
            if (menuDom) {
              menuDom.style.transition = "";
              menuDom.style.transform = "";
              maskDom.style.backgroundColor = "";
              if (!isOpen) {
                if (deltaX > menuWidth / 3) {
                  _MobileSideMenuHelper.show();
                } else {
                  maskDom.classList.remove("show");
                }
              } else {
                if (deltaX < -menuWidth / 3) {
                  _MobileSideMenuHelper.hide();
                } else {
                  _MobileSideMenuHelper.show();
                }
              }
            }
          });
        }
      };
      MobileSideMenu = (props) => {
        const css2 = {
          ".mobile-side-menu-mask": {
            display: "none",
            flexDirection: "column",
            position: "fixed",
            top: "0",
            left: "0",
            right: "0",
            bottom: "0",
            zIndex: "var(--layer-menu)",
            backgroundColor: "#00000000",
            transition: "background-color 0.3s ease-in-out",
            "&.show": {
              display: "flex"
            },
            "&.animate-show": {
              backgroundColor: "#000000b0"
            },
            "&.animate-show .mobile-side-menu": {
              transform: "translateX(0)"
            }
          },
          ".mobile-side-menu": {
            display: "flex",
            flexDirection: "column",
            padding: "16px",
            transition: "transform 0.3s ease-in-out",
            backgroundColor: "var(--primary-bg-color)",
            width: "70%",
            maxWidth: "300px",
            height: "100%",
            overflowX: "hidden",
            overflowY: "auto",
            transform: "translateX(-100%)",
            boxShadow: "var(--cover-box-shadow)"
          }
        };
        const onClickContainer = (event) => {
          if (event.target instanceof HTMLDivElement && event.target.classList.contains("mobile-side-menu-mask")) {
            MobileSideMenuHelper.hide();
          }
        };
        const ref = {
          onLoad: async () => {
            MobileSideMenuHelper.addTouchEvent(ref.$(".mobile-side-menu-mask"));
          }
        };
        return /* @__PURE__ */ jsx("div", { css: css2, ref, children: /* @__PURE__ */ jsx("div", { class: "mobile-side-menu-mask", onClick: onClickContainer, children: /* @__PURE__ */ jsx("div", { class: "mobile-side-menu", children: props.children }) }) });
      };
    }
  });

  // node_modules/lupine.components/src/components/mobile-components/mobile-top-sys-icon.tsx
  var MobileTopSysIcon;
  var init_mobile_top_sys_icon = __esm({
    "node_modules/lupine.components/src/components/mobile-components/mobile-top-sys-icon.tsx"() {
      init_mobile_side_menu();
      init_jsx_runtime();
      MobileTopSysIcon = () => {
        const css2 = {
          cursor: "pointer",
          display: "flex",
          flexDirection: "row",
          alignItems: "center",
          fontSize: "28px",
          transition: "transform 0.1s ease, opacity 0.1s ease",
          "&:hover": {
            opacity: 0.6
          },
          "&:active": {
            opacity: 0.8,
            transform: "scale(0.9)"
          }
        };
        return /* @__PURE__ */ jsx("div", { css: css2, onClick: () => MobileSideMenuHelper.show(), children: /* @__PURE__ */ jsx("i", { class: "ifc-icon bs-list" }) });
      };
    }
  });

  // node_modules/lupine.components/src/components/mobile-components/mobile-top-sys-menu.tsx
  var MobileTopSysMenu;
  var init_mobile_top_sys_menu = __esm({
    "node_modules/lupine.components/src/components/mobile-components/mobile-top-sys-menu.tsx"() {
      init_src2();
      init_jsx_runtime();
      MobileTopSysMenu = (props) => {
        return /* @__PURE__ */ jsx(
          PopupMenuWithIcon,
          {
            list: props.menuItems,
            defaultValue: "",
            tips: "",
            minWidth: "auto",
            maxWidth: "200px",
            maxHeight: "300px",
            align: "right",
            noTriangleIcon: true,
            handleSelected: props.handleSelected,
            noUpdateLabel: true
          }
        );
      };
    }
  });

  // node_modules/lupine.components/src/components/mobile-components/index.ts
  var init_mobile_components = __esm({
    "node_modules/lupine.components/src/components/mobile-components/index.ts"() {
      init_icon_menu_item_props();
      init_mobile_footer_menu();
      init_mobile_header_with_back();
      init_mobile_header_component();
      init_mobile_header_title_icon();
      init_mobile_side_menu();
      init_mobile_top_sys_icon();
      init_mobile_top_sys_menu();
    }
  });

  // node_modules/lupine.components/src/components/index.ts
  var init_components = __esm({
    "node_modules/lupine.components/src/components/index.ts"() {
      init_action_sheet();
      init_button_push_animation();
      init_button();
      init_drag_refresh();
      init_editable_label();
      init_float_window();
      init_grid();
      init_html_load();
      init_html_var();
      init_input_with_title();
      init_link_item();
      init_link_list();
      init_menu_bar();
      init_menu_item_props();
      init_menu_sidebar();
      init_message_box();
      init_meta_data();
      init_meta_description();
      init_modal();
      init_notice_message();
      init_page_title();
      init_paging_link();
      init_panel();
      init_popup_menu();
      init_progress();
      init_radio_label_component();
      init_redirect();
      init_resizable_splitter();
      init_select_angle_component();
      init_select_with_title();
      init_slide_tab_component();
      init_spinner();
      init_stars_component();
      init_svg();
      init_switch_option_component();
      init_tabs();
      init_text_glow();
      init_text_scale();
      init_text_wave();
      init_theme_selector();
      init_toggle_base();
      init_toggle_switch();
      init_mobile_components();
    }
  });

  // node_modules/lupine.components/src/lib/upload-file.ts
  var _saveChunkSize2, setUploadChunkSize, getUploadChunkSize, checkUploadedFileSize, uploadFileChunk, uploadFile;
  var init_upload_file = __esm({
    "node_modules/lupine.components/src/lib/upload-file.ts"() {
      init_src();
      init_components();
      _saveChunkSize2 = {
        size: 1024 * 200
      };
      setUploadChunkSize = (chunkSize) => {
        _saveChunkSize2.size = chunkSize;
      };
      getUploadChunkSize = () => {
        return _saveChunkSize2.size;
      };
      checkUploadedFileSize = async (uploadUrl) => {
        let url = uploadUrl + (uploadUrl.indexOf("?") === -1 ? "?" : "") + "&check-size=1";
        const json = await getRenderPageProps().renderPageFunctions.fetchData(url);
        return json && json.json.size ? json.json.size : 0;
      };
      uploadFileChunk = async (chunk, chunkNumber, totalChunks, uploadUrl, key, retryCount = 3, retryMessage = "") => {
        let url = uploadUrl + (uploadUrl.indexOf("?") === -1 ? "?" : "");
        url += `&chunkNumber=${chunkNumber.toString()}`;
        url += `&totalChunks=${totalChunks.toString()}`;
        if (key) {
          url += `&key=${key}`;
        }
        let tryCount = 0;
        let json;
        while (tryCount < retryCount) {
          try {
            json = await getRenderPageProps().renderPageFunctions.fetchData(url, chunk);
            if (json && json.json) {
              json = json.json;
            }
            if (json && json.status) {
              break;
            }
          } catch (error) {
            console.log(`uploadFileChunk error, try: ${tryCount}`, error);
          }
          tryCount++;
          if (retryMessage) {
            NotificationMessage.sendMessage(
              retryMessage.replace("${tryCount}", tryCount.toString()),
              "var(--warning-bg-color)" /* Warning */
            );
          }
        }
        return json;
      };
      uploadFile = async (file, uploadUrl, progressFn, chunkSize = 0, retryCount = 3, retryMessage = "") => {
        let key = "";
        const len = file instanceof File ? file.size : file.length;
        if (!chunkSize) {
          chunkSize = _saveChunkSize2.size;
        }
        if (len <= chunkSize) {
          const result = await uploadFileChunk(file, 0, 1, uploadUrl, key, retryCount, retryMessage);
          if (!result || result.status !== "ok") {
            return result;
          }
          if (progressFn) {
            progressFn(1, 0, len);
          }
          return true;
        }
        const totalChunks = Math.ceil(len / chunkSize);
        for (let i = 0; i < totalChunks; i++) {
          const start = i * chunkSize;
          const end = Math.min((i + 1) * chunkSize, len);
          const chunk = file.slice(start, end);
          const result = await uploadFileChunk(chunk, i, totalChunks, uploadUrl, key, retryCount, retryMessage);
          if (!result || result.status !== "ok") {
            return result;
          }
          key = result.key;
          if (progressFn) {
            progressFn(Math.round((i + 1) / totalChunks * 100) / 100, i, totalChunks);
          }
        }
        return true;
      };
    }
  });

  // node_modules/lupine.components/src/lib/index.ts
  var init_lib2 = __esm({
    "node_modules/lupine.components/src/lib/index.ts"() {
      init_back_action_helper();
      init_base62();
      init_blob_utils();
      init_calculate_text_width();
      init_date_utils();
      init_deep_merge();
      init_disable_console();
      init_disable_debug();
      init_document_ready();
      init_dom_utils();
      init_download_file();
      init_download_link();
      init_download_stream();
      init_drag_util();
      init_dynamical_load();
      init_encode_html();
      init_find_parent_tag();
      init_format_bytes();
      init_lite_dom();
      init_message_hub();
      init_observable();
      init_path_utils();
      init_promise_timeout();
      init_simple_storage();
      init_stop_propagation();
      init_upload_file();
    }
  });

  // node_modules/lupine.components/src/components/desktop-footer.tsx
  var DesktopFooter;
  var init_desktop_footer = __esm({
    "node_modules/lupine.components/src/components/desktop-footer.tsx"() {
      init_jsx_runtime();
      DesktopFooter = (props) => {
        const css2 = {
          display: "flex",
          padding: "0 32px 16px",
          ".d-footer-cp": {
            padding: "1px 15px",
            margin: "auto"
          }
        };
        return /* @__PURE__ */ jsx("div", { css: css2, class: "d-footer-box", children: /* @__PURE__ */ jsx("div", { class: "d-footer-cp", children: props.title }) });
      };
    }
  });

  // node_modules/lupine.components/src/components/desktop-header.tsx
  var DesktopHeader;
  var init_desktop_header = __esm({
    "node_modules/lupine.components/src/components/desktop-header.tsx"() {
      init_jsx_runtime();
      DesktopHeader = (props) => {
        const css2 = {
          display: "flex",
          flexDirection: "row",
          width: "100%",
          height: "100%",
          ".d-header-title": {
            display: "flex",
            flex: "1",
            margin: "8px 16px",
            textShadow: "-3px -3px 10px white, 3px 3px 10px black",
            color: "darkblue",
            fontSize: "22px"
          },
          ".desktop-menu-bar": {
            display: "flex",
            flexDirection: "row",
            width: "auto",
            padding: "4px 16px 0",
            ".desktop-menu-item": {
              display: "flex",
              padding: "0 8px",
              height: "fit-content",
              a: {
                textDecoration: "none",
                color: "var(--sidebar-color)",
                i: {
                  paddingRight: "4px"
                }
              }
            }
          }
        };
        return /* @__PURE__ */ jsx("div", { css: css2, class: "desktop-menu-box", children: [
          /* @__PURE__ */ jsx("div", { class: "flex-1 d-header-title", children: props.title }),
          /* @__PURE__ */ jsx("div", { class: "desktop-menu-bar", children: props.items.map((item) => {
            const handleClick = (e) => {
              if (item.js) {
                e.preventDefault();
                item.js();
              }
            };
            return /* @__PURE__ */ jsx("div", { class: "desktop-menu-item", children: /* @__PURE__ */ jsx("a", { href: item.url || "javascript:void(0)", onClick: handleClick, children: [
              /* @__PURE__ */ jsx("i", { class: `ifc-icon ${item.icon}` }),
              item.text
            ] }) });
          }) })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/frames/responsive-frame.tsx
  var ResponsiveFrame;
  var init_responsive_frame = __esm({
    "node_modules/lupine.components/src/frames/responsive-frame.tsx"() {
      init_src2();
      init_mobile_footer_menu();
      init_desktop_footer();
      init_desktop_header();
      init_mobile_header_component();
      init_mobile_side_menu();
      init_jsx_runtime();
      ResponsiveFrame = (props) => {
        const cssContainer = {
          display: "flex",
          flexDirection: "column",
          width: "100%",
          height: "100%",
          minHeight: "100%",
          ".frame-top-menu": {
            display: "flex",
            flexDirection: "column",
            width: "100%",
            backgroundColor: "var(--activatable-bg-color-normal)"
          },
          ".frame-content": {
            display: "flex",
            flex: "1",
            flexDirection: "column",
            overflowY: "auto",
            scrollbarWidth: "none",
            "&::-webkit-scrollbar": {
              display: "none"
            }
          },
          ".content-block": {
            display: "flex",
            flex: "1",
            flexDirection: "column",
            overflowY: "auto",
            scrollbarWidth: "none"
          },
          ".content-block::-webkit-scrollbar": {
            display: "none"
          },
          ".content-block .padding-block": {
            padding: "0 16px"
          },
          [MediaQueryRange.TabletBelow]: {
            ".frame-footer .d-footer-box, .frame-top-menu .desktop-menu-box": {
              display: "none"
            }
          }
        };
        return /* @__PURE__ */ jsx("div", { css: cssContainer, class: "responsive-frame", children: [
          props.sharedContents,
          /* @__PURE__ */ jsx("div", { class: "frame-top-menu", children: [
            /* @__PURE__ */ jsx(DesktopHeader, { title: props.desktopHeaderTitle, items: props.desktopTopMenu }),
            /* @__PURE__ */ jsx(MobileHeaderComponent, {})
          ] }),
          /* @__PURE__ */ jsx("div", { class: "frame-content", children: [
            /* @__PURE__ */ jsx(MobileSideMenu, { children: props.mobileSideMenuContent }),
            /* @__PURE__ */ jsx("div", { class: "content-block " + props.placeholderClassname, children: props.mainContent }),
            /* @__PURE__ */ jsx("div", { class: "frame-footer", children: [
              props.desktopFooterTitle && /* @__PURE__ */ jsx(DesktopFooter, { title: props.desktopFooterTitle }),
              /* @__PURE__ */ jsx(MobileFooterMenu, { items: props.mobileBottomMenu })
            ] })
          ] })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/frames/top-frame.tsx
  var TopFrame;
  var init_top_frame = __esm({
    "node_modules/lupine.components/src/frames/top-frame.tsx"() {
      init_jsx_runtime();
      TopFrame = async (placeholderClassname, vnode) => {
        const cssContainer = {
          display: "flex",
          flexDirection: "column",
          width: "100%",
          height: "100%",
          position: "relative",
          ".top-frame-box": {
            display: "flex",
            flex: "1",
            flexDirection: "column",
            height: "100%",
            // trick: to put two padding-top properties
            "padding-top ": "constant(safe-area-inset-top)",
            "padding-top": "env(safe-area-inset-top)"
          }
        };
        return /* @__PURE__ */ jsx("div", { css: cssContainer, children: /* @__PURE__ */ jsx("div", { class: "top-frame-box " + placeholderClassname, children: vnode }) });
      };
    }
  });

  // node_modules/lupine.components/src/frames/slider-frame.tsx
  var SliderFrame2;
  var init_slider_frame = __esm({
    "node_modules/lupine.components/src/frames/slider-frame.tsx"() {
      init_src2();
      init_jsx_runtime();
      SliderFrame2 = (props) => {
        if (props.hook) {
          props.hook.load = (children) => {
            var _a;
            dom.value = children;
            (_a = ref.current) == null ? void 0 : _a.classList.remove("d-none");
            setTimeout(() => {
              var _a2;
              (_a2 = ref.current) == null ? void 0 : _a2.classList.add("show");
            }, 100);
          };
          props.hook.close = (event) => {
            var _a;
            stopPropagation(event);
            (_a = ref.current) == null ? void 0 : _a.classList.remove("show");
            setTimeout(async () => {
              var _a2;
              (_a2 = ref.current) == null ? void 0 : _a2.classList.add("d-none");
              dom.value = "";
              if (props.afterClose) {
                await props.afterClose();
              }
            }, 400);
          };
          props.hook.addClass = (className) => {
            var _a;
            (_a = ref.current) == null ? void 0 : _a.classList.add(className);
          };
          props.hook.isOpened = () => {
            var _a;
            return (_a = ref.current) == null ? void 0 : _a.classList.contains("show");
          };
        }
        const dom = new HtmlVar(/* @__PURE__ */ jsx("div", { class: "slider-frame-default", children: props.defaultContent || "(No Content)" }));
        const ref = {};
        const css2 = {
          display: "flex",
          flexDirection: "column",
          position: "fixed",
          top: "0",
          left: "0",
          right: "0",
          bottom: "0",
          zIndex: "var(--layer-slider)",
          transform: props.direction === "bottom" ? "translateY(100%)" : "translateX(100%)",
          transition: "transform 0.4s ease-in-out",
          backgroundColor: "var(--primary-bg-color)",
          "&.show": {
            transform: props.direction === "bottom" ? "translateY(0)" : "translateX(0)"
          },
          "& > fragment": {
            height: "100%"
          },
          "&.desktop-slide-left": {
            [MediaQueryRange.TabletAbove]: {
              ".header-back-content": {
                width: "30%"
              }
            }
          },
          "&.desktop-slide-right": {
            [MediaQueryRange.TabletAbove]: {
              top: "59px",
              left: "30%",
              transform: "translateX(0)",
              // notice: here is connected with mobile-header-title-icon.tsx
              ".mobile-header-title-icon-top": {
                width: "100%",
                boxShadow: "unset"
              },
              ".header-back-content": {
                width: "100%"
              },
              ".mhti-title": {
                fontSize: "15px"
              },
              ".mhti-left, .mhti-right": {
                display: "none"
              },
              "&.d-none": {
                display: "unset !important"
              }
            }
          }
        };
        return /* @__PURE__ */ jsx("div", { ref, css: css2, class: "slider-frame d-none", children: dom.node });
      };
    }
  });

  // node_modules/lupine.components/src/frames/index.ts
  var init_frames = __esm({
    "node_modules/lupine.components/src/frames/index.ts"() {
      init_responsive_frame();
      init_top_frame();
      init_slider_frame();
    }
  });

  // node_modules/lupine.components/src/demo/demo-about.tsx
  var DemoAboutPage;
  var init_demo_about = __esm({
    "node_modules/lupine.components/src/demo/demo-about.tsx"() {
      init_jsx_runtime();
      DemoAboutPage = () => {
        const css2 = {};
        return /* @__PURE__ */ jsx("div", { css: css2, class: "demo-about-top", children: [
          /* @__PURE__ */ jsx("div", { class: "row-box", children: "This is a demo page for testing components." }),
          /* @__PURE__ */ jsx("div", { class: "row-box" })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/demo/demo-container.tsx
  var DemoContainer;
  var init_demo_container = __esm({
    "node_modules/lupine.components/src/demo/demo-container.tsx"() {
      init_jsx_runtime();
      DemoContainer = (props) => {
        const css2 = {
          height: "100%",
          width: "100%",
          display: "flex",
          flexDirection: "column",
          ".&-iframe-box": {
            flex: 1,
            minHeight: "200px"
            // Ensure it has some height
          },
          ".&-iframe": {
            width: "100%",
            height: "100%",
            // backgroundColor: 'white', // Default background for preview
            border: "4px solid var(--primary-border-color)",
            borderRadius: "12px",
            backgroundColor: "var(--secondary-bg-color, #f5f5f5)"
          },
          ".&-control-box": {
            // Allow it to grow if needed, or scroll
            minHeight: "50px",
            maxHeight: "40%",
            overflowY: "auto",
            borderTop: "1px solid var(--border-color, #ccc)",
            padding: "var(--space-m, 8px)"
          }
        };
        const findIframe = () => {
          const iframe = ref.$("&-iframe");
          return iframe;
        };
        const onLoad = () => {
          if (props.onIframeLoad) {
            const iframe = findIframe();
            if (iframe.contentWindow) {
              props.onIframeLoad(iframe.contentWindow);
            }
          }
        };
        const ref = {};
        return /* @__PURE__ */ jsx("div", { css: css2, ref, class: "demo-container-top", children: [
          /* @__PURE__ */ jsx("div", { class: "&-iframe-box", children: /* @__PURE__ */ jsx("iframe", { class: "&-iframe", src: props.demoUrl, frameBorder: "0", onLoad }) }),
          /* @__PURE__ */ jsx("div", { class: "&-control-box", children: props.controlBox })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/demo/demo-css.tsx
  var demoCss;
  var init_demo_css = __esm({
    "node_modules/lupine.components/src/demo/demo-css.tsx"() {
      demoCss = {};
    }
  });

  // node_modules/lupine.components/src/components/button-demo.tsx
  var buttonDemo;
  var init_button_demo = __esm({
    "node_modules/lupine.components/src/components/button-demo.tsx"() {
      init_button();
      init_html_var();
      init_jsx_runtime();
      buttonDemo = {
        id: "button-demo",
        text: "Button Demo",
        args: {
          text: "Click Me",
          size: "button-m" /* Medium */,
          disabled: false
        },
        argTypes: {
          text: { control: "text", description: "The text displayed inside the button" },
          size: {
            control: "select",
            options: Object.values(ButtonSize),
            description: "The size of the button"
          },
          disabled: { control: "boolean", description: "Whether the button is disabled" }
        },
        render: (args) => {
          const msg = new HtmlVar("");
          return /* @__PURE__ */ jsx("div", { css: { padding: "20px" }, children: [
            /* @__PURE__ */ jsx(
              Button,
              {
                ...args,
                onClick: () => {
                  msg.value = `Clicked at ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}`;
                }
              }
            ),
            /* @__PURE__ */ jsx("div", { css: { marginTop: "10px", fontSize: "13px", color: "var(--secondary-color, #999)" }, children: msg.node })
          ] });
        },
        code: `import { Button, ButtonSize } from 'lupine.components/components/button';

// Basic Usage
<Button 
  text="Click Me" 
  size={ButtonSize.Medium} 
  onClick={() => console.log('Clicked!')} 
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/button-push-animation-demo.tsx
  var buttonPushAnimationDemo;
  var init_button_push_animation_demo = __esm({
    "node_modules/lupine.components/src/components/button-push-animation-demo.tsx"() {
      init_button_push_animation();
      init_html_var();
      init_jsx_runtime();
      buttonPushAnimationDemo = {
        id: "button-push-animation-demo",
        text: "Button Push Animation Demo",
        args: {
          text: "Push Me",
          size: "button-m" /* Medium */,
          disabled: false
        },
        argTypes: {
          text: { control: "text", description: "The text displayed inside the button" },
          size: {
            control: "select",
            options: Object.values(ButtonPushAnimationSize),
            description: "The size of the button"
          },
          disabled: { control: "boolean", description: "Whether the button is disabled" }
        },
        render: (args) => {
          const msg = new HtmlVar("");
          return /* @__PURE__ */ jsx("div", { css: { padding: "20px" }, children: [
            /* @__PURE__ */ jsx(ButtonPushAnimation, { ...args, onClick: () => msg.value = `Pushed at ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}` }),
            /* @__PURE__ */ jsx("div", { css: { marginTop: "10px", fontSize: "13px", color: "var(--secondary-color, #999)" }, children: msg.node })
          ] });
        },
        code: `import { ButtonPushAnimation, ButtonPushAnimationSize } from 'lupine.components/components/button-push-animation';

<ButtonPushAnimation 
  text="Push Me" 
  size={ButtonPushAnimationSize.Medium} 
  onClick={() => console.log('Pushed!')} 
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/toggle-switch-demo.tsx
  var toggleSwitchDemo;
  var init_toggle_switch_demo = __esm({
    "node_modules/lupine.components/src/components/toggle-switch-demo.tsx"() {
      init_toggle_switch();
      init_jsx_runtime();
      toggleSwitchDemo = {
        id: "toggle-switch-demo",
        text: "Toggle Switch Demo",
        args: {
          size: "medium" /* Medium */,
          disabled: false,
          checked: false,
          text: { on: "ON", off: "OFF" },
          textWidth: "30px"
        },
        argTypes: {
          size: {
            control: "select",
            options: Object.values(ToggleSwitchSize),
            description: "The size of the switch"
          },
          disabled: { control: "boolean", description: "Whether the switch is disabled" },
          checked: { control: "boolean", description: "Whether the switch is turned on" },
          textWidth: { control: "text", description: "Fixed width for the text to prevent jumping" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { css: { padding: "20px" }, children: /* @__PURE__ */ jsx(ToggleSwitch, { ...args }) });
        },
        code: `import { ToggleSwitch, ToggleSwitchSize } from 'lupine.components/components/toggle-switch';

<ToggleSwitch 
  size={ToggleSwitchSize.Medium} 
  disabled={false} 
  checked={false} 
  text={{ on: 'ON', off: 'OFF' }} 
  textWidth="30px" 
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/input-number.tsx
  var SIZE_CFG, InputNumber;
  var init_input_number = __esm({
    "node_modules/lupine.components/src/components/input-number.tsx"() {
      init_button();
      init_jsx_runtime();
      SIZE_CFG = {
        ["button-ss" /* SmallLarge */]: { h: 24, fs: 11, valW: 36 },
        ["button-s" /* Small */]: { h: 28, fs: 12, valW: 42 },
        ["button-m" /* Medium */]: { h: 36, fs: 14, valW: 52 },
        ["button-l" /* Large */]: { h: 44, fs: 16, valW: 60 },
        ["button-ll" /* LargeLarge */]: { h: 52, fs: 18, valW: 72 }
      };
      InputNumber = ({
        value = 0,
        min,
        max,
        step = 1,
        size = "button-m" /* Medium */,
        disabled = false,
        onChange,
        class: cls,
        css: extraCss
      }) => {
        let current = value;
        const valRef = {};
        const { h, fs, valW } = SIZE_CFG[size];
        const update = (next) => {
          if (disabled) return;
          if (min !== void 0 && next < min) return;
          if (max !== void 0 && next > max) return;
          current = next;
          if (valRef.current) valRef.current.textContent = String(current);
          onChange == null ? void 0 : onChange(current);
        };
        let repeatTimer = null;
        let repeatInterval = null;
        const pressStart = (delta) => {
          update(current + delta);
          repeatTimer = setTimeout(() => {
            repeatInterval = setInterval(() => update(current + delta), 80);
          }, 400);
        };
        const pressStop = () => {
          clearTimeout(repeatTimer);
          clearInterval(repeatInterval);
          repeatTimer = null;
          repeatInterval = null;
        };
        const css2 = {
          display: "inline-flex",
          alignItems: "center",
          border: "1px solid var(--primary-border-color)",
          borderRadius: "var(--border-radius-m, 8px)",
          overflow: "hidden",
          opacity: disabled ? "0.5" : "1",
          userSelect: "none",
          ".inp-btn": {
            display: "inline-flex",
            alignItems: "center",
            justifyContent: "center",
            width: `${h}px`,
            height: `${h}px`,
            fontSize: `${fs + 5}px`,
            fontWeight: "bold",
            lineHeight: 1,
            background: "transparent",
            border: "none",
            color: "var(--activatable-color-normal)",
            cursor: disabled ? "not-allowed" : "pointer",
            transition: "background 0.15s, transform 0.1s",
            flexShrink: 0,
            "&:hover": { background: "var(--activatable-bg-color-hover, rgba(0,0,0,0.06))" },
            "&:active": { transform: "scale(0.85)" }
          },
          ".inp-val": {
            display: "inline-flex",
            alignItems: "center",
            justifyContent: "center",
            minWidth: `${valW}px`,
            height: `${h}px`,
            fontSize: `${fs}px`,
            fontVariantNumeric: "tabular-nums",
            borderLeft: "1px solid var(--primary-border-color)",
            borderRight: "1px solid var(--primary-border-color)",
            color: "var(--activatable-color-normal)",
            padding: "0 6px"
          },
          ...extraCss
        };
        const minusBtnRef = {
          onLoad: async () => {
            const el = minusBtnRef.current;
            el.addEventListener(
              "touchstart",
              (e) => {
                e.preventDefault();
                pressStart(-step);
              },
              { passive: false }
            );
            el.addEventListener("touchend", pressStop);
            el.addEventListener("touchcancel", pressStop);
          }
        };
        const plusBtnRef = {
          onLoad: async () => {
            const el = plusBtnRef.current;
            el.addEventListener(
              "touchstart",
              (e) => {
                e.preventDefault();
                pressStart(+step);
              },
              { passive: false }
            );
            el.addEventListener("touchend", pressStop);
            el.addEventListener("touchcancel", pressStop);
          }
        };
        return /* @__PURE__ */ jsx("div", { css: css2, class: cls, children: [
          /* @__PURE__ */ jsx(
            "button",
            {
              ref: minusBtnRef,
              class: "inp-btn",
              disabled,
              onMouseDown: () => pressStart(-step),
              onMouseUp: pressStop,
              onMouseLeave: pressStop,
              children: "\u2212"
            }
          ),
          /* @__PURE__ */ jsx("span", { class: "inp-val", ref: valRef, children: value }),
          /* @__PURE__ */ jsx(
            "button",
            {
              ref: plusBtnRef,
              class: "inp-btn",
              disabled,
              onMouseDown: () => pressStart(+step),
              onMouseUp: pressStop,
              onMouseLeave: pressStop,
              children: "+"
            }
          )
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/components/input-number-demo.tsx
  var inputNumberDemo;
  var init_input_number_demo = __esm({
    "node_modules/lupine.components/src/components/input-number-demo.tsx"() {
      init_input_number();
      init_html_var();
      init_jsx_runtime();
      inputNumberDemo = {
        id: "input-number-demo",
        text: "Input Number",
        args: {
          value: 0,
          min: -10,
          max: 10,
          step: 1,
          size: "button-m" /* Medium */,
          disabled: false
        },
        argTypes: {
          value: { control: "number", description: "Initial value" },
          min: { control: "number", description: "Minimum allowed value" },
          max: { control: "number", description: "Maximum allowed value" },
          step: { control: "number", description: "Step amount per click" },
          size: {
            control: "select",
            options: Object.values(ButtonSize),
            description: "Size of the stepper"
          },
          disabled: { control: "boolean", description: "Disable interaction" }
        },
        render: (args) => {
          const msg = new HtmlVar("");
          return /* @__PURE__ */ jsx("div", { children: [
            /* @__PURE__ */ jsx(
              InputNumber,
              {
                ...args,
                onChange: (v) => {
                  msg.value = `Value changed: ${v}`;
                }
              }
            ),
            /* @__PURE__ */ jsx("div", { css: { marginTop: "10px", fontSize: "13px", color: "var(--secondary-color, #999)" }, children: msg.node })
          ] });
        },
        code: `import { InputNumber, InputNumberSize } from 'lupine.components/components/input-number';

// Basic usage
<InputNumber
  value={0}
  min={0}
  max={100}
  step={1}
  size={InputNumberSize.Medium}
  onChange={(v) => console.log('Value:', v)}
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/spinner-demo.tsx
  var spinnerDemo;
  var init_spinner_demo = __esm({
    "node_modules/lupine.components/src/components/spinner-demo.tsx"() {
      init_spinner();
      init_jsx_runtime();
      spinnerDemo = {
        id: "spinner-demo",
        text: "Spinner Demo",
        args: {
          size: "30px" /* Medium */,
          color: "#0a74c9"
        },
        argTypes: {
          size: {
            control: "select",
            options: Object.values(SpinnerSize),
            description: "Size of the spinner"
          },
          color: {
            control: "text",
            description: "Color of the spinner (Hex, RGB, or var)"
          }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { display: "flex", gap: "40px", alignItems: "center", padding: "20px" }, children: [
            /* @__PURE__ */ jsx("div", { style: { display: "flex", flexDirection: "column", alignItems: "center", gap: "10px" }, children: [
              /* @__PURE__ */ jsx(Spinner01, { size: args.size, color: args.color }),
              /* @__PURE__ */ jsx("span", { children: "Spinner01" })
            ] }),
            /* @__PURE__ */ jsx("div", { style: { display: "flex", flexDirection: "column", alignItems: "center", gap: "10px" }, children: [
              /* @__PURE__ */ jsx(Spinner02, { size: args.size, color: args.color }),
              /* @__PURE__ */ jsx("span", { children: "Spinner02" })
            ] }),
            /* @__PURE__ */ jsx("div", { style: { display: "flex", flexDirection: "column", alignItems: "center", gap: "10px" }, children: [
              /* @__PURE__ */ jsx(Spinner03, { size: args.size, colorRGB: "10 116 201" }),
              /* @__PURE__ */ jsx("span", { children: "Spinner03" })
            ] })
          ] });
        },
        code: `import { Spinner01, Spinner02, Spinner03, SpinnerSize } from 'lupine.components/components/spinner';

{/* Spinner01 */}
<Spinner01 size={SpinnerSize.Medium} color="#0a74c9" />

{/* Spinner02 */}
<Spinner02 size={SpinnerSize.Medium} color="#0a74c9" />

{/* Spinner03 expects an RGB tuple string without the rgb() wrapper */}
<Spinner03 size={SpinnerSize.Medium} colorRGB="10 116 201" />
`
      };
    }
  });

  // node_modules/lupine.components/src/components/stars-component-demo.tsx
  var starsDemo;
  var init_stars_component_demo = __esm({
    "node_modules/lupine.components/src/components/stars-component-demo.tsx"() {
      init_stars_component();
      init_jsx_runtime();
      starsDemo = {
        id: "stars-demo",
        text: "Stars Component Demo",
        args: {
          maxLength: 5,
          value: 3,
          fontSize: "30px",
          fullIcon: /* @__PURE__ */ jsx("div", { class: "ifc-icon full", children: "\u2605" }),
          outlineIcon: /* @__PURE__ */ jsx("div", { class: "ifc-icon outline", children: "\u2606" })
        },
        argTypes: {
          maxLength: { control: "number", description: "Total number of stars" },
          value: { control: "number", description: "Current rating value" },
          fontSize: { control: "text", description: "Size of the stars (e.g., 20px, 2rem)" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px" }, children: /* @__PURE__ */ jsx(StarsComponent, { ...args }) });
        },
        code: `import { StarsComponent } from 'lupine.components/components/stars-component';

<StarsComponent 
  maxLength={5} 
  value={3} 
  fontSize="30px" 
  fullIcon={<div class="ifc-icon full">\u2605</div>} 
  outlineIcon={<div class="ifc-icon outline">\u2606</div>} 
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/editable-label-demo.tsx
  var editableLabelDemo;
  var init_editable_label_demo = __esm({
    "node_modules/lupine.components/src/components/editable-label-demo.tsx"() {
      init_editable_label();
      init_html_var();
      init_jsx_runtime();
      editableLabelDemo = {
        id: "editable-label-demo",
        text: "Editable Label Demo",
        args: {
          text: "Double click to edit me!",
          mandtory: false
        },
        argTypes: {
          text: { control: "text", description: "Initial text content" },
          mandtory: { control: "boolean", description: "If true, value cannot be left empty" }
        },
        render: (args) => {
          const msg = new HtmlVar(args.text);
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px", width: "300px" }, children: [
            /* @__PURE__ */ jsx("p", { style: { color: "#666", fontSize: "13px", marginBottom: "10px" }, children: "Instructions: Double-click the text below to switch to edit mode. Press Enter to save, or Escape to cancel." }),
            /* @__PURE__ */ jsx(EditableLabel, { ...args, save: (val) => msg.value = val }),
            /* @__PURE__ */ jsx("p", { css: { fontSize: "13px", color: "var(--secondary-color, #999)" }, children: [
              "Saved: ",
              msg.node
            ] })
          ] });
        },
        code: `import { EditableLabel } from 'lupine.components/components/editable-label';

<EditableLabel 
  text="Double click to edit me!" 
  mandtory={false} 
  save={(val) => console.log('Saved:', val)} 
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/progress-demo.tsx
  var progressHook, progressDemo;
  var init_progress_demo = __esm({
    "node_modules/lupine.components/src/components/progress-demo.tsx"() {
      init_progress();
      init_button();
      init_jsx_runtime();
      progressHook = {};
      progressDemo = {
        id: "progress-demo",
        text: "Progress Demo",
        args: {},
        argTypes: {},
        render: (args) => {
          const ref = {};
          const startSimulation = () => {
            if (progressHook.onShow) {
              progressHook.onShow(true, "Simulating Upload...");
              let p = 0;
              const interval = setInterval(() => {
                p += 3;
                if (p > 100) {
                  clearInterval(interval);
                  progressHook.onShow(false);
                } else {
                  progressHook.onProgress(p / 100);
                }
              }, 100);
            }
          };
          return /* @__PURE__ */ jsx("div", { ref, style: { padding: "20px" }, children: [
            /* @__PURE__ */ jsx(Progress, { hook: progressHook }),
            /* @__PURE__ */ jsx("div", { style: { marginTop: "20px" }, children: /* @__PURE__ */ jsx(Button, { onClick: startSimulation, size: "button-l" /* Large */, text: "Start Upload/Download Simulation" }) })
          ] });
        },
        code: `import { Progress, ProgressHookProps } from 'lupine.components/components/progress';

const progressHook: ProgressHookProps = {};

// 1. Render the component somewhere in your app (usually near the root)
<Progress hook={progressHook} />

// 2. Control it via the hook
progressHook.onShow!(true, 'Uploading...'); // Show progress
progressHook.onProgress!(0.5);              // Set to 50%
progressHook.onShow!(false);                // Hide
`
      };
    }
  });

  // node_modules/lupine.components/src/components/radio-label-demo.tsx
  var radioLabelDemo;
  var init_radio_label_demo = __esm({
    "node_modules/lupine.components/src/components/radio-label-demo.tsx"() {
      init_radio_label_component();
      init_jsx_runtime();
      radioLabelDemo = {
        id: "radio-label-demo",
        text: "Radio Label Demo",
        args: {
          label: "Option A",
          name: "demo-radio-group",
          checked: true,
          disabled: false
        },
        argTypes: {
          label: { control: "text", description: "Label text" },
          name: { control: "text", description: "Radio group name" },
          checked: { control: "boolean", description: "Is checked?" },
          disabled: { control: "boolean", description: "Is disabled?" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px", display: "flex", flexDirection: "column", gap: "10px" }, children: [
            /* @__PURE__ */ jsx(RadioLabelComponent, { ...args }),
            /* @__PURE__ */ jsx(RadioLabelComponent, { label: "Option B", name: args.name, disabled: args.disabled })
          ] });
        },
        code: `import { RadioLabelComponent } from 'lupine.components/components/radio-label-component';

<RadioLabelComponent 
  label="Option A" 
  name="demo-radio-group" 
  checked={true} 
  disabled={false} 
/>
<RadioLabelComponent 
  label="Option B" 
  name="demo-radio-group" 
  disabled={false} 
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/select-angle-demo.tsx
  var selectAngleDemo;
  var init_select_angle_demo = __esm({
    "node_modules/lupine.components/src/components/select-angle-demo.tsx"() {
      init_select_angle_component();
      init_jsx_runtime();
      selectAngleDemo = {
        id: "select-angle-demo",
        text: "Select Angle Demo",
        args: {
          size: "100px",
          angle: 45,
          onChange: () => {
          }
        },
        argTypes: {
          size: { control: "text", description: "Size of the dial container" },
          angle: { control: "number", description: "Initial angle (0-360)" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px" }, children: [
            /* @__PURE__ */ jsx("p", { style: { color: "#666", marginBottom: "16px" }, children: "Drag the needle or click the edge dots to set the angle." }),
            /* @__PURE__ */ jsx(SelectAngleComponent, { ...args, onChange: (val) => console.log("Angle changed:", val) })
          ] });
        },
        code: `import { SelectAngleComponent } from 'lupine.components/components/select-angle-component';

<SelectAngleComponent 
  size="100px" 
  angle={45} 
  onChange={(val) => console.log('Angle changed:', val)} 
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/switch-option-demo.tsx
  var switchOptionDemo;
  var init_switch_option_demo = __esm({
    "node_modules/lupine.components/src/components/switch-option-demo.tsx"() {
      init_switch_option_component();
      init_jsx_runtime();
      switchOptionDemo = {
        id: "switch-option-demo",
        text: "Switch Option Demo",
        args: {
          option1: "On",
          option2: "Off",
          defaultOption: "On",
          fontSize: "14px"
        },
        argTypes: {
          option1: { control: "text", description: "First option text" },
          option2: { control: "text", description: "Second option text" },
          defaultOption: { control: "text", description: "Initial selected option" },
          fontSize: { control: "text", description: "Font size" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px" }, children: /* @__PURE__ */ jsx(SwitchOptionComponent, { ...args, onChange: (val) => console.log("Switched to:", val) }) });
        },
        code: `import { SwitchOptionComponent } from 'lupine.components/components/switch-option-component';

<SwitchOptionComponent 
  option1="Day" 
  option2="Night" 
  defaultOption="Day" 
  fontSize="14px" 
  onChange={(val) => console.log('Switched to:', val)} 
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/action-sheet-time.tsx
  var ActionSheetTimePicker;
  var init_action_sheet_time = __esm({
    "node_modules/lupine.components/src/components/action-sheet-time.tsx"() {
      init_action_sheet();
      init_jsx_runtime();
      ActionSheetTimePicker = async ({
        value = "",
        title = "",
        showSeconds = false,
        confirmButtonText = "OK",
        cancelButtonText = "Cancel",
        zIndex
      }) => {
        const parts = value.split(":");
        const initialHour = parseInt(parts[0] || "0", 10) || 0;
        const initialMinute = parseInt(parts[1] || "0", 10) || 0;
        const initialSecond = parseInt(parts[2] || "0", 10) || 0;
        const ITEM_H2 = 44;
        return new Promise(async (resolve) => {
          let handleClose;
          const hourRef = {};
          const minuteRef = {};
          const secondRef = {};
          const getIdx = (colRef) => Math.round(colRef.current.scrollTop / ITEM_H2);
          const onConfirm = () => {
            const h = String(getIdx(hourRef)).padStart(2, "0");
            const m = String(getIdx(minuteRef)).padStart(2, "0");
            const s = showSeconds ? String(getIdx(secondRef)).padStart(2, "0") : "00";
            const result = showSeconds ? `${h}:${m}:${s}` : `${h}:${m}`;
            resolve(result);
            handleClose("confirm");
          };
          const closeEvent = (reason) => {
            if (reason !== "confirm") resolve(void 0);
          };
          const buildColumn = (max, initial, colRef) => {
            colRef.onLoad = async () => {
              const el = colRef.current;
              const items = el.querySelectorAll(".tp-item");
              if (items[initial]) {
                el.scrollTop = items[initial].offsetTop - ITEM_H2;
              }
            };
            return /* @__PURE__ */ jsx("div", { class: "col", ref: colRef, children: [
              /* @__PURE__ */ jsx("div", { class: "tp-pad" }),
              Array.from({ length: max }, (_, i) => /* @__PURE__ */ jsx("div", { class: "tp-item", children: String(i).padStart(2, "0") })),
              /* @__PURE__ */ jsx("div", { class: "tp-pad" })
            ] });
          };
          const pickerBodyCss = {
            borderTop: "1px solid var(--primary-border-color)",
            overflow: "hidden",
            ".picker-body": {
              display: "flex",
              height: `${ITEM_H2 * 3}px`,
              minHeight: "100px",
              position: "relative",
              "&::before": {
                content: '""',
                position: "absolute",
                top: `${ITEM_H2}px`,
                left: 0,
                right: 0,
                height: `${ITEM_H2}px`,
                backgroundColor: "var(--activatable-bg-color-hover, rgba(0,0,0,0.05))",
                borderRadius: "6px",
                pointerEvents: "none",
                opacity: 0.4
              }
            },
            ".colon": {
              alignSelf: "center",
              fontSize: "20px",
              fontWeight: "bold",
              color: "var(--primary-color)",
              padding: "0 4px"
            },
            ".col": {
              flex: 1,
              overflowY: "scroll",
              scrollSnapType: "y mandatory",
              scrollbarWidth: "none",
              "&::-webkit-scrollbar": { display: "none" },
              ".tp-pad": { height: `${ITEM_H2}px` },
              ".tp-item": {
                scrollSnapAlign: "center",
                height: `${ITEM_H2}px`,
                lineHeight: `${ITEM_H2}px`,
                textAlign: "center",
                fontSize: "20px",
                cursor: "pointer",
                color: "var(--secondary-color, #aaa)"
              }
            }
          };
          const pickerBody = /* @__PURE__ */ jsx("div", { css: pickerBodyCss, children: /* @__PURE__ */ jsx("div", { class: "picker-body", children: [
            buildColumn(24, initialHour, hourRef),
            /* @__PURE__ */ jsx("div", { class: "colon", children: ":" }),
            buildColumn(60, initialMinute, minuteRef),
            showSeconds && /* @__PURE__ */ jsx(Fragment, { children: [
              /* @__PURE__ */ jsx("div", { class: "colon", children: ":" }),
              buildColumn(60, initialSecond, secondRef)
            ] })
          ] }) });
          handleClose = await ActionSheet.show({
            title,
            children: pickerBody,
            contentMaxHeight: "33vh",
            closeEvent,
            closeWhenClickOutside: true,
            zIndex,
            confirmButtonText,
            handleConfirmClicked: onConfirm,
            cancelButtonText,
            buttonsPosition: "header"
          });
        });
      };
    }
  });

  // node_modules/lupine.components/src/components/action-sheet-date.tsx
  var DEFAULT_MONTHS, CURRENT_YEAR, ITEM_H, VISIBLE, PAD, ActionSheetDatePicker;
  var init_action_sheet_date = __esm({
    "node_modules/lupine.components/src/components/action-sheet-date.tsx"() {
      init_action_sheet();
      init_jsx_runtime();
      DEFAULT_MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      CURRENT_YEAR = (/* @__PURE__ */ new Date()).getFullYear();
      ITEM_H = 44;
      VISIBLE = 5;
      PAD = Math.floor(VISIBLE / 2);
      ActionSheetDatePicker = async ({
        value = "",
        title = "",
        order = "YMD",
        months = DEFAULT_MONTHS,
        yearRange = 100,
        confirmButtonText = "OK",
        cancelButtonText = "Cancel",
        zIndex
      }) => {
        const today = /* @__PURE__ */ new Date();
        const parts = value.match(/^(\d{4})-(\d{2})-(\d{2})$/) ?? [];
        const initialYear = parts[1] ? parseInt(parts[1], 10) : today.getFullYear();
        const initialMonth = parts[2] ? parseInt(parts[2], 10) : today.getMonth() + 1;
        const initialDay = parts[3] ? parseInt(parts[3], 10) : today.getDate();
        const YEAR_COUNT = yearRange * 2 + 1;
        const START_YEAR = CURRENT_YEAR - yearRange;
        return new Promise(async (resolve) => {
          let handleClose;
          const yearRef = {};
          const monthRef = {};
          const dayRef = {};
          const getIdx = (colRef) => Math.round(colRef.current.scrollTop / ITEM_H);
          const onConfirm = () => {
            const year = START_YEAR + getIdx(yearRef);
            const month = 1 + getIdx(monthRef);
            const day = 1 + getIdx(dayRef);
            const result = [String(year).padStart(4, "0"), String(month).padStart(2, "0"), String(day).padStart(2, "0")].join(
              "-"
            );
            resolve(result);
            handleClose("confirm");
          };
          const closeEvent = (reason) => {
            if (reason !== "confirm") resolve(void 0);
          };
          const buildColumn = (labels, initialIdx, colRef) => {
            colRef.onLoad = async () => {
              const el = colRef.current;
              const items = el.querySelectorAll(".dp-item");
              if (items[initialIdx]) {
                el.scrollTop = items[initialIdx].offsetTop - PAD * ITEM_H;
              }
            };
            return /* @__PURE__ */ jsx("div", { class: "col", ref: colRef, children: [
              Array.from({ length: PAD }, (_, i) => /* @__PURE__ */ jsx("div", { class: "dp-pad" }, `t${i}`)),
              labels.map((label, i) => /* @__PURE__ */ jsx("div", { class: "dp-item", children: label }, i)),
              Array.from({ length: PAD }, (_, i) => /* @__PURE__ */ jsx("div", { class: "dp-pad" }, `b${i}`))
            ] });
          };
          const years = Array.from({ length: YEAR_COUNT }, (_, i) => String(START_YEAR + i));
          const days = Array.from({ length: 31 }, (_, i) => String(i + 1).padStart(2, "0"));
          const initialYearIdx = Math.max(0, Math.min(YEAR_COUNT - 1, initialYear - START_YEAR));
          const initialMonthIdx = Math.max(0, Math.min(months.length - 1, initialMonth - 1));
          const initialDayIdx = Math.max(0, Math.min(30, initialDay - 1));
          const yearCol = buildColumn(years, initialYearIdx, yearRef);
          const monthCol = buildColumn(months, initialMonthIdx, monthRef);
          const dayCol = buildColumn(days, initialDayIdx, dayRef);
          const orderedCols = order === "DMY" ? [dayCol, monthCol, yearCol] : [yearCol, monthCol, dayCol];
          const pickerBodyCss = {
            borderTop: "1px solid var(--primary-border-color)",
            overflow: "hidden",
            // prevent act-sheet-content from adding outer scrollbar
            ".picker-body": {
              display: "flex",
              height: `${ITEM_H * VISIBLE}px`,
              position: "relative",
              // Center-selection highlight band
              "&::before": {
                content: '""',
                position: "absolute",
                top: `${ITEM_H * PAD}px`,
                left: 0,
                right: 0,
                height: `${ITEM_H}px`,
                backgroundColor: "var(--activatable-bg-color-hover, rgba(0,0,0,0.05))",
                borderRadius: "6px",
                pointerEvents: "none",
                opacity: 0.4
              }
            },
            ".col": {
              flex: 1,
              overflowY: "scroll",
              scrollSnapType: "y mandatory",
              scrollbarWidth: "none",
              "&::-webkit-scrollbar": { display: "none" },
              ".dp-pad": { height: `${ITEM_H}px` },
              ".dp-item": {
                scrollSnapAlign: "center",
                height: `${ITEM_H}px`,
                lineHeight: `${ITEM_H}px`,
                textAlign: "center",
                fontSize: "18px",
                cursor: "pointer",
                color: "var(--secondary-color, #aaa)"
              }
            }
          };
          const pickerBody = /* @__PURE__ */ jsx("div", { css: pickerBodyCss, children: /* @__PURE__ */ jsx("div", { class: "picker-body", children: [
            orderedCols[0],
            orderedCols[1],
            orderedCols[2]
          ] }) });
          handleClose = await ActionSheet.show({
            title,
            children: pickerBody,
            contentMaxHeight: "33vh",
            closeEvent,
            closeWhenClickOutside: true,
            zIndex,
            confirmButtonText,
            handleConfirmClicked: onConfirm,
            cancelButtonText,
            buttonsPosition: "header"
          });
        });
      };
    }
  });

  // node_modules/lupine.components/src/components/action-sheet-color.tsx
  function hexToRgb(hex) {
    const h = hex.replace("#", "");
    if (/^[0-9a-f]{6}$/i.test(h)) {
      return [parseInt(h.slice(0, 2), 16), parseInt(h.slice(2, 4), 16), parseInt(h.slice(4, 6), 16)];
    }
    return [64, 128, 255];
  }
  function rgbToHex(r, g, b) {
    return "#" + [r, g, b].map((v) => Math.max(0, Math.min(255, v)).toString(16).padStart(2, "0")).join("");
  }
  var PRESET_COLORS, ActionSheetColorPicker;
  var init_action_sheet_color = __esm({
    "node_modules/lupine.components/src/components/action-sheet-color.tsx"() {
      init_action_sheet();
      init_media_query();
      init_jsx_runtime();
      PRESET_COLORS = [
        "#000000",
        "#ffffff",
        "#ff0000",
        "#00ff00",
        "#0000ff",
        "#ffff00",
        "#00ffff",
        "#ff00ff",
        "#808080",
        "#c0c0c0",
        "#800000",
        "#808000",
        "#008000",
        "#800080",
        "#008080",
        "#000080"
      ];
      ActionSheetColorPicker = async ({
        value = "#4080ff",
        title = "",
        confirmButtonText = "OK",
        cancelButtonText = "Cancel",
        showPresets = true,
        zIndex
      }) => {
        let [r, g, b] = hexToRgb(value);
        return new Promise(async (resolve) => {
          let handleClose;
          const onConfirm = () => {
            resolve(rgbToHex(r, g, b));
            handleClose("confirm");
          };
          const closeEvent = (reason) => {
            if (reason !== "confirm") resolve(void 0);
          };
          const swatchRef = {};
          const hexRef = {};
          const updatePreview = () => {
            const hex = rgbToHex(r, g, b);
            if (swatchRef.current) swatchRef.current.style.backgroundColor = hex;
            if (hexRef.current) hexRef.current.textContent = hex;
          };
          const css2 = {
            borderTop: "1px solid var(--primary-border-color)",
            overflow: "hidden",
            padding: "16px 20px",
            ".slider-row": {
              display: "flex",
              alignItems: "center",
              gap: "12px",
              marginBottom: "14px",
              ".ch": {
                width: "14px",
                fontWeight: "bold",
                fontSize: "13px",
                flexShrink: 0,
                textAlign: "center"
              },
              ".val": {
                width: "28px",
                textAlign: "right",
                fontSize: "12px",
                color: "var(--secondary-color, #aaa)",
                flexShrink: 0,
                fontFamily: "monospace"
              },
              // Range input track + thumb styling
              'input[type="range"]': {
                flex: 1,
                WebkitAppearance: "none",
                appearance: "none",
                height: "6px",
                borderRadius: "3px",
                outline: "none",
                border: "none",
                cursor: "pointer",
                background: "var(--primary-border-color)",
                "&::-webkit-slider-thumb": {
                  WebkitAppearance: "none",
                  width: "20px",
                  height: "20px",
                  borderRadius: "50%",
                  background: "var(--cover-bg-color, #fff)",
                  border: "2px solid var(--primary-border-color)",
                  cursor: "pointer",
                  boxShadow: "0 1px 4px rgba(0,0,0,0.2)"
                },
                "&::-moz-range-thumb": {
                  width: "20px",
                  height: "20px",
                  borderRadius: "50%",
                  background: "var(--cover-bg-color, #fff)",
                  border: "2px solid var(--primary-border-color)",
                  cursor: "pointer"
                }
              }
            },
            ".preview-row": {
              display: "flex",
              alignItems: "center",
              gap: "14px",
              marginTop: "4px",
              paddingTop: "14px",
              borderTop: "1px solid var(--primary-border-color)",
              ".swatch": {
                width: "44px",
                height: "44px",
                borderRadius: "50%",
                border: "2px solid var(--primary-border-color)",
                flexShrink: 0,
                boxShadow: "0 2px 6px rgba(0,0,0,0.15)"
              },
              ".hex-text": {
                fontSize: "22px",
                fontWeight: "bold",
                fontFamily: "monospace",
                letterSpacing: "1px",
                color: "var(--activatable-color-normal, #333)"
              }
            },
            ".presets": {
              display: "grid",
              gap: "8px",
              marginTop: "12px",
              paddingTop: "12px",
              borderTop: "1px solid var(--primary-border-color)",
              gridTemplateColumns: "repeat(16, 1fr)",
              [MediaQueryRange.ExtraSmallBelow]: {
                gridTemplateColumns: "repeat(8, 1fr)"
              },
              ".preset-dot": {
                aspectRatio: "1",
                borderRadius: "50%",
                border: "2px solid var(--primary-border-color)",
                cursor: "pointer",
                transition: "transform 0.15s",
                "&:hover": { transform: "scale(1.2)" }
              }
            }
          };
          const buildSlider = (label, initial, trackColor, onChange) => {
            const valRef = {};
            const inputRef = {
              onLoad: async () => {
                const el = inputRef.current;
                el.value = String(initial);
                const pct = initial / 255 * 100;
                el.style.background = `linear-gradient(to right, ${trackColor} ${pct}%, var(--primary-border-color) ${pct}%)`;
              }
            };
            return /* @__PURE__ */ jsx("div", { class: "slider-row", children: [
              /* @__PURE__ */ jsx("span", { class: "ch", style: { color: trackColor }, children: label }),
              /* @__PURE__ */ jsx(
                "input",
                {
                  ref: inputRef,
                  type: "range",
                  min: "0",
                  max: "255",
                  onInput: (e) => {
                    const v = parseInt(e.target.value, 10);
                    onChange(v);
                    const pct = v / 255 * 100;
                    e.target.style.background = `linear-gradient(to right, ${trackColor} ${pct}%, var(--primary-border-color) ${pct}%)`;
                    if (valRef.current) valRef.current.textContent = String(v);
                    updatePreview();
                  }
                }
              ),
              /* @__PURE__ */ jsx("span", { class: "val", ref: valRef, children: initial })
            ] });
          };
          const initialHex = rgbToHex(r, g, b);
          const pickerBody = /* @__PURE__ */ jsx("div", { css: css2, children: [
            buildSlider("R", r, "#ff4444", (v) => {
              r = v;
            }),
            buildSlider("G", g, "#22cc55", (v) => {
              g = v;
            }),
            buildSlider("B", b, "#4488ff", (v) => {
              b = v;
            }),
            /* @__PURE__ */ jsx("div", { class: "preview-row", children: [
              /* @__PURE__ */ jsx("div", { class: "swatch", ref: swatchRef, style: { backgroundColor: initialHex } }),
              /* @__PURE__ */ jsx("span", { class: "hex-text", ref: hexRef, children: initialHex })
            ] }),
            showPresets && /* @__PURE__ */ jsx("div", { class: "presets", children: PRESET_COLORS.map((hex) => /* @__PURE__ */ jsx(
              "div",
              {
                class: "preset-dot",
                style: { backgroundColor: hex },
                title: hex,
                onClick: () => {
                  resolve(hex);
                  handleClose("confirm");
                }
              }
            )) })
          ] });
          handleClose = await ActionSheet.show({
            title,
            children: pickerBody,
            closeEvent,
            closeWhenClickOutside: true,
            zIndex,
            confirmButtonText,
            handleConfirmClicked: onConfirm,
            cancelButtonText,
            buttonsPosition: "header"
          });
        });
      };
    }
  });

  // node_modules/lupine.components/src/components/action-sheet-demo.tsx
  var actionSheetDemo;
  var init_action_sheet_demo = __esm({
    "node_modules/lupine.components/src/components/action-sheet-demo.tsx"() {
      init_action_sheet();
      init_action_sheet_time();
      init_action_sheet_date();
      init_action_sheet_color();
      init_button();
      init_jsx_runtime();
      actionSheetDemo = {
        id: "action-sheet-demo",
        text: "Action Sheet Demo",
        args: {
          title: "Select an Action",
          confirmButtonText: "Confirm Option",
          cancelButtonText: "Cancel Action"
        },
        argTypes: {
          title: { control: "text", description: "Title of the action sheet" },
          confirmButtonText: { control: "text", description: "Confirm button text" },
          cancelButtonText: { control: "text", description: "Cancel button text" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { display: "flex", flexDirection: "column", gap: "20px", padding: "20px" }, children: [
            /* @__PURE__ */ jsx(
              Button,
              {
                text: "Show Simple Action Sheet",
                size: "button-m" /* Medium */,
                onClick: () => {
                  ActionSheet.show({
                    title: args.title,
                    children: /* @__PURE__ */ jsx("div", { style: { padding: "20px" }, children: "Custom Content Here" }),
                    confirmButtonText: args.confirmButtonText,
                    cancelButtonText: args.cancelButtonText,
                    handleConfirmClicked: (close) => close("confirm")
                  });
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Button,
              {
                text: "Show Action Sheet Select",
                size: "button-m" /* Medium */,
                onClick: () => {
                  ActionSheetSelect.show({
                    title: args.title,
                    options: ["Option A", "Option B", "Option C"],
                    confirmButtonText: args.confirmButtonText,
                    cancelButtonText: args.cancelButtonText,
                    handleClicked: (index, close) => {
                      console.log("Selected index:", index);
                      close("select");
                    }
                  });
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Button,
              {
                text: "Show Action Sheet Message",
                size: "button-m" /* Medium */,
                onClick: () => {
                  ActionSheetMessage.show({
                    title: args.title,
                    message: "This is a detailed message shown inside the action sheet.",
                    confirmButtonText: args.confirmButtonText,
                    cancelButtonText: args.cancelButtonText
                  });
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Button,
              {
                text: "Show Action Sheet Input",
                size: "button-m" /* Medium */,
                onClick: () => {
                  ActionSheetInput.show({
                    title: args.title,
                    defaultValue: "Default text",
                    confirmButtonText: args.confirmButtonText,
                    cancelButtonText: args.cancelButtonText,
                    handleConfirmValue: (val, close) => {
                      console.log("Input value:", val);
                      close("confirm");
                    }
                  });
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Button,
              {
                text: "Show Time Picker (HH:mm)",
                size: "button-m" /* Medium */,
                onClick: async () => {
                  const result = await ActionSheetTimePicker({
                    title: "Pick a time",
                    value: "09:30",
                    showSeconds: false
                  });
                  if (result) console.log("Time selected (HH:mm):", result);
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Button,
              {
                text: "Show Time Picker (HH:mm:ss)",
                size: "button-m" /* Medium */,
                onClick: async () => {
                  const result = await ActionSheetTimePicker({
                    title: "Pick a time",
                    value: "14:05:30",
                    showSeconds: true
                  });
                  if (result) console.log("Time selected (HH:mm:ss):", result);
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Button,
              {
                text: "Show Date Picker (Year-Month-Day)",
                size: "button-m" /* Medium */,
                onClick: async () => {
                  const result = await ActionSheetDatePicker({
                    title: "Pick a date",
                    value: "2026-02-24",
                    order: "YMD"
                  });
                  if (result) console.log("Date selected (YMD):", result);
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Button,
              {
                text: "Show Date Picker (Day-Month-Year)",
                size: "button-m" /* Medium */,
                onClick: async () => {
                  const result = await ActionSheetDatePicker({
                    title: "Pick a date",
                    value: "2026-02-24",
                    order: "DMY"
                  });
                  if (result) console.log("Date selected (DMY):", result);
                }
              }
            ),
            /* @__PURE__ */ jsx(
              Button,
              {
                text: "Show Color Picker",
                size: "button-m" /* Medium */,
                onClick: async () => {
                  const result = await ActionSheetColorPicker({
                    title: "Pick a color",
                    value: "#4080ff"
                  });
                  if (result) console.log("Color selected:", result);
                }
              }
            )
          ] });
        },
        code: `import { ActionSheet, ActionSheetSelect, ActionSheetMessage, ActionSheetInput } from 'lupine.components/components/action-sheet';

// Simple Action Sheet
ActionSheet.show({
  title: 'Select an Action',
  children: <div style={{ padding: '20px' }}>Custom Content Here</div>,
  confirmButtonText: 'Confirm Option',
  cancelButtonText: 'Cancel Action',
  handleConfirmClicked: (close) => close('confirm'),
});

// Action Sheet Select
ActionSheetSelect.show({
  title: 'Select an Action',
  options: ['Option A', 'Option B', 'Option C'],
  handleClicked: (index, close) => close('select'),
});
`
      };
    }
  });

  // node_modules/lupine.components/src/components/select-with-title-demo.tsx
  var selectWithTitleDemo;
  var init_select_with_title_demo = __esm({
    "node_modules/lupine.components/src/components/select-with-title-demo.tsx"() {
      init_select_with_title();
      init_jsx_runtime();
      selectWithTitleDemo = {
        id: "select-with-title-demo",
        text: "Select With Title Demo",
        args: {
          title: "Choose a fruit",
          size: 1,
          width: "200px"
        },
        argTypes: {
          title: { control: "text", description: "Title text shown above" },
          size: { control: "number", description: "HTML select size attribute" },
          width: { control: "text", description: "Width of the select" }
        },
        render: (args) => {
          const options3 = [
            { option: "Apple", value: "apple" },
            { option: "Banana", value: "banana", selected: true },
            { option: "Cherry", value: "cherry" }
          ];
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px" }, children: SelectWithTitle(
            args.title,
            options3,
            (val) => console.log("Selected:", val),
            args.size,
            "input-base",
            args.width
          ) });
        },
        code: `import { SelectWithTitle, SelectOptionProps } from 'lupine.components/components/select-with-title';

const options: SelectOptionProps[] = [
  { option: 'Apple', value: 'apple' },
  { option: 'Banana', value: 'banana', selected: true },
  { option: 'Cherry', value: 'cherry' },
];

{SelectWithTitle(
  'Choose a fruit', // title
  options,          // options array
  (val) => console.log('Selected:', val), // onChange
  1,                // size
  'input-base',     // className
  '200px'           // width
)}
`
      };
    }
  });

  // node_modules/lupine.components/src/components/input-with-title-demo.tsx
  var inputWithTitleDemo;
  var init_input_with_title_demo = __esm({
    "node_modules/lupine.components/src/components/input-with-title-demo.tsx"() {
      init_input_with_title();
      init_jsx_runtime();
      inputWithTitleDemo = {
        id: "input-with-title-demo",
        text: "Input With Title Demo",
        args: {
          title: "Enter your name",
          defaultValue: "John Doe",
          width: "250px"
        },
        argTypes: {
          title: { control: "text", description: "Title text shown above input" },
          defaultValue: { control: "text", description: "Initial default value" },
          width: { control: "text", description: "Width of the input container" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px" }, children: InputWithTitle(
            args.title,
            args.defaultValue,
            (val) => console.log("Input onChange:", val),
            (val) => console.log("Input onInput:", val),
            "input-base",
            args.width
          ) });
        },
        code: `import { InputWithTitle } from 'lupine.components/components/input-with-title';

{InputWithTitle(
  'Enter your name', // title
  'John Doe',        // defaultValue
  (val) => console.log('onChange:', val),
  (val) => console.log('onInput:', val),
  'input-base',      // className
  '250px'            // width
)}
`
      };
    }
  });

  // node_modules/lupine.components/src/components/tabs-demo.tsx
  var tabsDemo;
  var init_tabs_demo = __esm({
    "node_modules/lupine.components/src/components/tabs-demo.tsx"() {
      init_tabs();
      init_jsx_runtime();
      tabsDemo = {
        id: "tabs-demo",
        text: "Tabs Demo",
        args: {
          defaultIndex: 0,
          pagePadding: "16px"
        },
        argTypes: {
          defaultIndex: { control: "number", description: "Index of the active tab on load" },
          pagePadding: { control: "text", description: "Padding inside each tab page" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { height: "300px", width: "500px", border: "1px solid #ccc" }, children: /* @__PURE__ */ jsx(
            Tabs,
            {
              defaultIndex: args.defaultIndex,
              pagePadding: args.pagePadding,
              pages: [
                { title: "Tab 1", page: /* @__PURE__ */ jsx("div", { children: "Content for Tab 1" }) },
                { title: "Tab 2", page: /* @__PURE__ */ jsx("div", { children: "Content for Tab 2" }) },
                { title: "Tab 3", page: /* @__PURE__ */ jsx("div", { style: { color: "red" }, children: "Content for Tab 3" }) }
              ]
            }
          ) });
        },
        code: `import { Tabs } from 'lupine.components/components/tabs';

<Tabs 
  defaultIndex={0} 
  pagePadding="16px" 
  pages={[
    { title: 'Tab 1', page: <div>Content for Tab 1</div> },
    { title: 'Tab 2', page: <div>Content for Tab 2</div> },
    { title: 'Tab 3', page: <div style={{ color: 'red' }}>Content for Tab 3</div> },
  ]} 
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/modal-demo.tsx
  var modalDemo;
  var init_modal_demo = __esm({
    "node_modules/lupine.components/src/components/modal-demo.tsx"() {
      init_modal();
      init_button();
      init_jsx_runtime();
      modalDemo = {
        id: "modal-demo",
        text: "Modal Window Demo",
        args: {
          title: "Example Modal",
          noMoving: true,
          noModal: false,
          contentMinWidth: "300px"
        },
        argTypes: {
          title: { control: "text", description: "Title of the modal" },
          noMoving: { control: "boolean", description: "Disable dragging?" },
          noModal: { control: "boolean", description: "If true, it won't block background interaction" },
          contentMinWidth: { control: "text", description: "Minimum width of modal" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px" }, children: /* @__PURE__ */ jsx(
            Button,
            {
              text: "Open Modal",
              size: "button-m" /* Medium */,
              onClick: () => {
                ModalWindow.show({
                  title: args.title,
                  children: /* @__PURE__ */ jsx("div", { style: { padding: "20px" }, children: "This is the modal content!" }),
                  noMoving: args.noMoving,
                  noModal: args.noModal,
                  contentMinWidth: args.contentMinWidth,
                  buttons: ["Cancel", "Confirm"],
                  handleClicked: (ind, close) => {
                    console.log("Clicked button:", ind);
                    close();
                  }
                });
              }
            }
          ) });
        },
        code: `import { ModalWindow } from 'lupine.components/components/modal';

ModalWindow.show({
  title: 'Example Modal',
  children: <div style={{ padding: '20px' }}>This is the modal content!</div>,
  buttons: ['Cancel', 'Confirm'],
  handleClicked: (ind, close) => {
    console.log('Clicked button:', ind);
    close();
  },
});
`
      };
    }
  });

  // node_modules/lupine.components/src/components/popup-menu-demo.tsx
  var popupMenuDemo;
  var init_popup_menu_demo = __esm({
    "node_modules/lupine.components/src/components/popup-menu-demo.tsx"() {
      init_popup_menu();
      init_jsx_runtime();
      popupMenuDemo = {
        id: "popup-menu-demo",
        text: "Popup Menu Demo",
        args: {
          label: "Actions",
          defaultValue: "Select...",
          align: "right"
        },
        argTypes: {
          label: { control: "text", description: "Label for button/text triggers" },
          defaultValue: { control: "text", description: "Default selected text" },
          align: { control: "select", options: ["left", "right"], description: "Menu drop alignment" }
        },
        render: (args) => {
          const list2 = ["Edit Profile", "Settings", "", "Log Out"];
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px", display: "flex", gap: "40px", alignItems: "flex-start" }, children: [
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { children: "With Button" }),
              /* @__PURE__ */ jsx(
                PopupMenuWithButton,
                {
                  label: args.label,
                  list: list2,
                  defaultValue: args.defaultValue,
                  align: args.align,
                  handleSelected: (val) => console.log("Selected:", val)
                }
              )
            ] }),
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { children: "With Label" }),
              /* @__PURE__ */ jsx(PopupMenuWithLabel, { label: args.label, list: list2, defaultValue: args.defaultValue, align: args.align })
            ] }),
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { children: "With Icon" }),
              /* @__PURE__ */ jsx(
                PopupMenuWithIcon,
                {
                  list: list2,
                  defaultValue: args.defaultValue,
                  align: args.align,
                  icon: /* @__PURE__ */ jsx("span", { style: { fontSize: "24px" }, children: "\u2699\uFE0F" })
                }
              )
            ] })
          ] });
        },
        code: `import { PopupMenuWithButton, PopupMenuWithLabel, PopupMenuWithIcon } from 'lupine.components/components/popup-menu';

const list = ['Edit Profile', 'Settings', '', 'Log Out'];

{/* With Button */}
<PopupMenuWithButton
  label="Actions"
  list={list}
  defaultValue="Select..."
  align="right"
  handleSelected={(val: string) => console.log('Selected:', val)}
/>

{/* With Icon */}
<PopupMenuWithIcon
  list={list}
  icon={<span style={{ fontSize: '24px' }}>\u2699\uFE0F</span>}
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/notice-message-demo.tsx
  var noticeMessageDemo;
  var init_notice_message_demo = __esm({
    "node_modules/lupine.components/src/components/notice-message-demo.tsx"() {
      init_notice_message();
      init_button();
      init_jsx_runtime();
      noticeMessageDemo = {
        id: "notice-message-demo",
        text: "Notice Message Demo",
        args: {
          message: "Action completed successfully!",
          permanent: false,
          showTime: 3e3
        },
        argTypes: {
          message: { control: "text", description: "Message content" },
          permanent: { control: "boolean", description: "If true, stays until manually closed" },
          showTime: { control: "number", description: "Time in ms to show (if not permanent)" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px", display: "flex", gap: "10px", flexWrap: "wrap" }, children: [
            /* @__PURE__ */ jsx(
              Button,
              {
                text: "Show Info",
                size: "button-m" /* Medium */,
                onClick: () => NotificationMessage.sendMessage(args.message, "var(--info-bg-color)" /* Info */, args.permanent, args.showTime)
              }
            ),
            /* @__PURE__ */ jsx(
              Button,
              {
                text: "Show Success",
                size: "button-m" /* Medium */,
                onClick: () => NotificationMessage.sendMessage(args.message, "var(--success-bg-color)" /* Success */, args.permanent, args.showTime)
              }
            ),
            /* @__PURE__ */ jsx(
              Button,
              {
                text: "Show Warning",
                size: "button-m" /* Medium */,
                onClick: () => NotificationMessage.sendMessage(args.message, "var(--warning-bg-color)" /* Warning */, args.permanent, args.showTime)
              }
            ),
            /* @__PURE__ */ jsx(
              Button,
              {
                text: "Show Error",
                size: "button-m" /* Medium */,
                onClick: () => NotificationMessage.sendMessage(args.message, "var(--error-bg-color)" /* Error */, args.permanent, args.showTime)
              }
            )
          ] });
        },
        code: `import { NotificationMessage, NotificationColor } from 'lupine.components/components/notice-message';

// Show Info
NotificationMessage.sendMessage('Action completed successfully!', NotificationColor.Info);

// Show Success (permanent)
NotificationMessage.sendMessage('Action completed successfully!', NotificationColor.Success, true);
`
      };
    }
  });

  // node_modules/lupine.components/src/components/resizable-splitter-demo.tsx
  var resizableSplitterDemo;
  var init_resizable_splitter_demo = __esm({
    "node_modules/lupine.components/src/components/resizable-splitter-demo.tsx"() {
      init_resizable_splitter();
      init_jsx_runtime();
      resizableSplitterDemo = {
        id: "resizable-splitter-demo",
        text: "Resizable Splitter Demo",
        args: {
          isVertical: true
        },
        argTypes: {
          isVertical: { control: "boolean", description: "If true, splits left/right. If false, splits top/bottom" }
        },
        render: (args) => {
          const containerId = "splitter-demo-box";
          if (args.isVertical) {
            return /* @__PURE__ */ jsx("div", { style: { display: "flex", width: "600px", height: "400px", border: "1px solid #999", padding: "20px" }, children: [
              /* @__PURE__ */ jsx(
                "div",
                {
                  id: containerId,
                  style: {
                    width: "200px",
                    height: "100%",
                    backgroundColor: "#eee",
                    position: "relative"
                  },
                  children: [
                    /* @__PURE__ */ jsx("div", { style: { padding: "10px" }, children: "Left Panel (Drag right edge)" }),
                    ResizableSplitter.getSplitter(`#${containerId}`, true, true)
                  ]
                }
              ),
              /* @__PURE__ */ jsx("div", { style: { flex: 1, backgroundColor: "#ddd", padding: "10px" }, children: "Right Panel (Flex 1)" })
            ] });
          } else {
            return /* @__PURE__ */ jsx(
              "div",
              {
                style: {
                  display: "flex",
                  flexDirection: "column",
                  width: "600px",
                  height: "400px",
                  border: "1px solid #999",
                  padding: "20px"
                },
                children: [
                  /* @__PURE__ */ jsx(
                    "div",
                    {
                      id: containerId,
                      style: {
                        height: "150px",
                        width: "100%",
                        backgroundColor: "#eee",
                        position: "relative"
                      },
                      children: [
                        /* @__PURE__ */ jsx("div", { style: { padding: "10px" }, children: "Top Panel (Drag bottom edge)" }),
                        ResizableSplitter.getSplitter(`#${containerId}`, false, false)
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsx("div", { style: { flex: 1, backgroundColor: "#ddd", padding: "10px" }, children: "Bottom Panel (Flex 1)" })
                ]
              }
            );
          }
        },
        code: `import { ResizableSplitter } from 'lupine.components/components/resizable-splitter';

{/* Left/Right Splitter (isVertical=true means the divider line is vertical) */}
<div id="splitter-demo-box" style={{ width: '200px', height: '100%', position: 'relative' }}>
  <div style={{ padding: '10px' }}>Left Panel (Drag right edge)</div>
  {ResizableSplitter.getSplitter('#splitter-demo-box', true, true)}
</div>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/redirect-demo.tsx
  var redirectDemo;
  var init_redirect_demo = __esm({
    "node_modules/lupine.components/src/components/redirect-demo.tsx"() {
      init_redirect();
      init_jsx_runtime();
      redirectDemo = {
        id: "redirect-demo",
        text: "Redirect Demo",
        args: {
          title: "Redirecting you soon..." + (/* @__PURE__ */ new Date()).toISOString(),
          url: "#test-redirect",
          delaySeconds: 3
        },
        argTypes: {
          title: { control: "text", description: "Text shown while waiting" },
          url: { control: "text", description: "URL to redirect to" },
          delaySeconds: { control: "number", description: "Delay before redirecting" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px", border: "1px solid #ccc", backgroundColor: "#f9f9f9" }, children: [
            /* @__PURE__ */ jsx("p", { style: { color: "#666", marginBottom: "16px" }, children: [
              "This component automatically changes the `window.location.href` after the specified delay. In this demo, the iframe will redirect itself to `",
              args.url,
              "` after ",
              args.delaySeconds,
              " seconds."
            ] }),
            /* @__PURE__ */ jsx(Redirect, { ...args })
          ] });
        },
        code: `import { Redirect } from 'lupine.components/components/redirect';

<Redirect 
  title="Redirecting you soon..." 
  url="https://example.com" 
  delaySeconds={3} 
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/text-wave-demo.tsx
  var textWaveDemo;
  var init_text_wave_demo = __esm({
    "node_modules/lupine.components/src/components/text-wave-demo.tsx"() {
      init_text_wave();
      init_jsx_runtime();
      textWaveDemo = {
        id: "text-wave-demo",
        text: "Text Wave Demo",
        args: {
          text: "Loading...",
          color: "#22b8ff",
          fontSize: "30px",
          padding: "20px",
          fontWeight: "bold"
        },
        argTypes: {
          text: { control: "text", description: "The text to animate" },
          color: { control: "text", description: "Color of the text" },
          fontSize: { control: "text", description: "Font size" },
          padding: { control: "text", description: "Padding around text" },
          fontWeight: { control: "text", description: "Font weight" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx(
            "div",
            {
              style: {
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                height: "200px",
                backgroundColor: "#f0f0f0"
              },
              children: /* @__PURE__ */ jsx(TextWave, { ...args })
            }
          );
        },
        code: `import { TextWave } from 'lupine.components/components/text-wave';

<TextWave 
  text="Loading..." 
  color="#22b8ff" 
  fontSize="30px" 
  padding="20px" 
  fontWeight="bold" 
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/text-scale-demo.tsx
  var textScaleDemo;
  var init_text_scale_demo = __esm({
    "node_modules/lupine.components/src/components/text-scale-demo.tsx"() {
      init_text_scale();
      init_jsx_runtime();
      textScaleDemo = {
        id: "text-scale-demo",
        text: "Text Scale Demo",
        args: {
          text: "Scaling Text!!!",
          color: "#22b8ff",
          backgroundColor: "#a1ffe8",
          fontSize: "35px",
          padding: "15px 30px",
          fontWeight: "bold"
        },
        argTypes: {
          text: { control: "text", description: "The text to animate" },
          color: { control: "text", description: "Color of the text" },
          backgroundColor: { control: "text", description: "Background color behind text" },
          fontSize: { control: "text", description: "Font size" },
          padding: { control: "text", description: "Padding around background" },
          fontWeight: { control: "text", description: "Font weight" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { display: "flex", justifyContent: "center", alignItems: "center", height: "200px" }, children: /* @__PURE__ */ jsx(TextScale, { ...args }) });
        },
        code: `import { TextScale } from 'lupine.components/components/text-scale';

<TextScale 
  text="Scaling Text!!!" 
  color="#22b8ff" 
  backgroundColor="#a1ffe8" 
  fontSize="35px" 
  padding="15px 30px" 
  fontWeight="bold" 
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/text-glow-demo.tsx
  var textGlowDemo;
  var init_text_glow_demo = __esm({
    "node_modules/lupine.components/src/components/text-glow-demo.tsx"() {
      init_text_glow();
      init_jsx_runtime();
      textGlowDemo = {
        id: "text-glow-demo",
        text: "Text Glow Demo",
        args: {
          text: "NEON GLOW",
          color: "#ffffff",
          fontSize: "40px",
          padding: "30px",
          fontWeight: "bold"
        },
        argTypes: {
          text: { control: "text", description: "The text to animate" },
          color: { control: "text", description: "Color of the base text" },
          fontSize: { control: "text", description: "Font size" },
          padding: { control: "text", description: "Padding around text" },
          fontWeight: { control: "text", description: "Font weight" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx(
            "div",
            {
              style: {
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                height: "200px",
                backgroundColor: "#111"
              },
              children: /* @__PURE__ */ jsx(TextGlow, { ...args })
            }
          );
        },
        code: `import { TextGlow } from 'lupine.components/components/text-glow';

<TextGlow 
  text="NEON GLOW" 
  color="#ffffff" 
  fontSize="40px" 
  padding="30px" 
  fontWeight="bold" 
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/toggle-play-button-demo.tsx
  var togglePlayButtonDemo;
  var init_toggle_play_button_demo = __esm({
    "node_modules/lupine.components/src/components/toggle-play-button-demo.tsx"() {
      init_toggle_base();
      init_jsx_runtime();
      togglePlayButtonDemo = {
        id: "toggle-play-button-demo",
        text: "Toggle Play Button Demo",
        args: {
          size: "Medium",
          disabled: false,
          checked: false,
          textColor: "#ffffff",
          backgroundColor: "#3b29cc",
          noWave: false
        },
        argTypes: {
          size: { control: "select", options: ["Small", "Medium", "Large"], description: "Size preset" },
          disabled: { control: "boolean", description: "Disabled state" },
          checked: { control: "boolean", description: "Is playing?" },
          textColor: { control: "text", description: "Color of the play icon" },
          backgroundColor: { control: "text", description: "Background color of the button" },
          noWave: { control: "boolean", description: "Disable the background wave animation" }
        },
        render: (args) => {
          const sizeMap = {
            Small: TogglePlayButtonSize.Small,
            Medium: TogglePlayButtonSize.Medium,
            Large: TogglePlayButtonSize.Large
          };
          return /* @__PURE__ */ jsx("div", { style: { display: "flex", justifyContent: "center", alignItems: "center", height: "200px" }, children: /* @__PURE__ */ jsx(
            TogglePlayButton,
            {
              size: sizeMap[args.size],
              disabled: args.disabled,
              checked: args.checked,
              textColor: args.textColor,
              backgroundColor: args.backgroundColor,
              noWave: args.noWave,
              onClick: (val) => console.log("Playing:", val)
            }
          ) });
        },
        code: `import { TogglePlayButton, TogglePlayButtonSize } from 'lupine.components/components/toggle-base';

<TogglePlayButton 
  size={TogglePlayButtonSize.Medium} 
  disabled={false} 
  checked={false} 
  textColor="#ffffff" 
  backgroundColor="#3b29cc" 
  noWave={false} 
  onClick={(val) => console.log('Playing:', val)} 
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/toggle-button-demo.tsx
  var toggleButtonDemo;
  var init_toggle_button_demo = __esm({
    "node_modules/lupine.components/src/components/toggle-button-demo.tsx"() {
      init_toggle_base();
      init_jsx_runtime();
      toggleButtonDemo = {
        id: "toggle-button-demo",
        text: "Toggle Button Demo",
        args: {
          onText: "Turn Off",
          offText: "Turn On",
          disabled: false,
          checked: false
        },
        argTypes: {
          onText: { control: "text", description: "Text shown when ON" },
          offText: { control: "text", description: "Text shown when OFF" },
          disabled: { control: "boolean", description: "Disabled state" },
          checked: { control: "boolean", description: "Initial state" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px" }, children: /* @__PURE__ */ jsx(
            ToggleButton,
            {
              onText: args.onText,
              offText: args.offText,
              disabled: args.disabled,
              checked: args.checked,
              onClick: (val) => console.log("Toggled:", val)
            }
          ) });
        },
        code: `import { ToggleButton } from 'lupine.components/components/toggle-base';

<ToggleButton 
  onText="Turn Off" 
  offText="Turn On" 
  disabled={false} 
  checked={false} 
  onClick={(val) => console.log('Toggled:', val)} 
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/message-box-demo.tsx
  var messageBoxDemo;
  var init_message_box_demo = __esm({
    "node_modules/lupine.components/src/components/message-box-demo.tsx"() {
      init_src2();
      init_message_box();
      init_button();
      init_jsx_runtime();
      messageBoxDemo = {
        id: "message-box-demo",
        text: "MessageBox Demo",
        args: {
          title: "System Alert",
          contentMinWidth: "300px"
        },
        argTypes: {
          title: { control: "text", description: "Title of the MessageBox" },
          contentMinWidth: { control: "text", description: "Minimum width of MessageBox" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px" }, children: [
            /* @__PURE__ */ jsx("p", { style: { color: "#666", marginBottom: "20px" }, children: "Test different button configurations for MessageBox." }),
            /* @__PURE__ */ jsx("div", { style: { display: "flex", gap: "10px", flexWrap: "wrap" }, children: [
              /* @__PURE__ */ jsx(
                Button,
                {
                  text: "Yes / No Dialog",
                  size: "button-m" /* Medium */,
                  onClick: () => {
                    MessageBox.show({
                      title: args.title,
                      buttonType: "yesno" /* YesNo */,
                      contentMinWidth: args.contentMinWidth,
                      children: /* @__PURE__ */ jsx("div", { style: { padding: "20px" }, children: "Are you sure you want to proceed?" }),
                      handleClicked: (index, close) => {
                        const result = index === 0 ? "Yes" : "No";
                        NotificationMessage.sendMessage("You clicked: " + result, "var(--info-bg-color)" /* Info */);
                        close();
                      }
                    });
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Button,
                {
                  text: "Ok / Cancel Dialog",
                  size: "button-m" /* Medium */,
                  onClick: () => {
                    MessageBox.show({
                      title: args.title,
                      buttonType: "okcancel" /* OkCancel */,
                      contentMinWidth: args.contentMinWidth,
                      children: /* @__PURE__ */ jsx("div", { style: { padding: "20px" }, children: "Please confirm this action." }),
                      handleClicked: (index, close) => {
                        const result = index === 0 ? "OK" : "Cancel";
                        const level = index === 0 ? "var(--success-bg-color)" /* Success */ : "var(--warning-bg-color)" /* Warning */;
                        NotificationMessage.sendMessage("You clicked: " + result, level);
                        close();
                      }
                    });
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Button,
                {
                  text: "Ok Only",
                  size: "button-m" /* Medium */,
                  onClick: () => {
                    MessageBox.show({
                      title: args.title,
                      buttonType: "ok" /* Ok */,
                      contentMinWidth: args.contentMinWidth,
                      children: /* @__PURE__ */ jsx("div", { style: { padding: "20px" }, children: "Operation completed successfully!" }),
                      handleClicked: (index, close) => {
                        NotificationMessage.sendMessage("Dialog dismissed", "var(--success-bg-color)" /* Success */);
                        close();
                      }
                    });
                  }
                }
              )
            ] })
          ] });
        },
        code: `import { MessageBox, MessageBoxButtonProps } from 'lupine.components/components/message-box';

// Quick Alert
MessageBox.show({
  title: 'System Alert',
  buttonType: MessageBoxButtonProps.Ok,
  children: <div style={{ padding: '20px' }}>Operation completed successfully!</div>,
  handleClicked: (index, close) => {
    close();
  }
});

// Confirmation Dialog
MessageBox.show({
  title: 'Confirm Action',
  buttonType: MessageBoxButtonProps.OkCancel,
  children: <div style={{ padding: '20px' }}>Are you sure you want to proceed?</div>,
  handleClicked: (index, close) => {
    if (index === 0) {
      console.log('User clicked OK');
    } else {
      console.log('User clicked Cancel');
    }
    close();
  }
});
`
      };
    }
  });

  // node_modules/lupine.components/src/demo/mock/side-menu-mock.tsx
  var sideMenuMockCss, SideMenuMock;
  var init_side_menu_mock = __esm({
    "node_modules/lupine.components/src/demo/mock/side-menu-mock.tsx"() {
      init_src();
      init_mobile_side_menu();
      init_components();
      init_jsx_runtime();
      sideMenuMockCss = {
        ".msm-header": {
          display: "flex",
          alignItems: "center",
          padding: "16px",
          borderBottom: "1px solid var(--primary-border-color)"
        },
        ".msm-header-icon": {
          width: "32px",
          height: "32px",
          marginRight: "12px",
          borderRadius: "4px",
          backgroundColor: "var(--primary-color)"
        },
        ".msm-header-title": {
          fontSize: "18px",
          fontWeight: "bold",
          color: "var(--primary-color)"
        },
        ".msm-content": {
          flex: "1",
          overflowY: "auto",
          padding: "12px 0"
        },
        ".msm-item": {
          padding: "12px 0px",
          fontSize: "16px",
          cursor: "pointer",
          transition: "background-color 0.2s",
          display: "flex",
          alignItems: "center",
          gap: "12px",
          "&:hover": {
            backgroundColor: "var(--activatable-bg-color-hover, rgba(0,0,0,0.04))"
          }
        },
        ".msm-footer": {
          borderTop: "1px solid var(--primary-border-color)",
          padding: "16px 0"
        },
        ".msm-footer-cfg": {
          display: "flex",
          flexDirection: "row",
          justifyContent: "space-between"
        },
        ".msm-footer-cfg .msm-item": {
          padding: "12px 0px"
        },
        ".msm-footer-version": {
          textAlign: "center",
          fontSize: "12px",
          color: "var(--secondary-color, #999)",
          marginTop: "16px"
        }
      };
      SideMenuMock = ({
        menuItems = ["Home", "Profile", "Messages", "Settings"],
        title = "My App Menu",
        version = "1.0.0",
        onAction
      }) => {
        const globalCssId = getGlobalStylesId(sideMenuMockCss);
        bindGlobalStyle(globalCssId, sideMenuMockCss);
        const ref = {
          globalCssId
        };
        const handleAction = (item) => {
          if (onAction) {
            onAction(item);
          } else {
            NotificationMessage.sendMessage(`Action: ${item}`, "var(--info-bg-color)" /* Info */);
            MobileSideMenuHelper.hide();
          }
        };
        return /* @__PURE__ */ jsx("div", { ref, style: { display: "flex", flexDirection: "column", flex: 1, height: "100%" }, children: [
          /* @__PURE__ */ jsx("div", { class: "msm-header", children: [
            /* @__PURE__ */ jsx("div", { class: "msm-header-icon" }),
            /* @__PURE__ */ jsx("div", { class: "msm-header-title", children: title })
          ] }),
          /* @__PURE__ */ jsx("div", { class: "msm-content", children: menuItems.map((item) => /* @__PURE__ */ jsx("div", { class: "msm-item", onClick: () => handleAction(item), children: item })) }),
          /* @__PURE__ */ jsx("div", { class: "msm-footer", children: [
            /* @__PURE__ */ jsx("div", { class: "msm-footer-cfg", children: [
              /* @__PURE__ */ jsx("div", { class: "msm-item", onClick: () => handleAction("Account Settings"), children: [
                /* @__PURE__ */ jsx("i", { class: "ifc-icon ma-cog-outline" }),
                "Account"
              ] }),
              /* @__PURE__ */ jsx("div", { class: "msm-item", onClick: () => handleAction("Logout"), style: { color: "var(--error-color, #ff4d4f)" }, children: [
                /* @__PURE__ */ jsx("i", { class: "ifc-icon ma-logout" }),
                "Logout"
              ] })
            ] }),
            /* @__PURE__ */ jsx("div", { class: "msm-footer-version", children: [
              "Version: ",
              version
            ] })
          ] })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/components/mobile-components/mobile-side-menu-demo.tsx
  var mobileSideMenuDemo;
  var init_mobile_side_menu_demo = __esm({
    "node_modules/lupine.components/src/components/mobile-components/mobile-side-menu-demo.tsx"() {
      init_mobile_side_menu();
      init_side_menu_mock();
      init_jsx_runtime();
      mobileSideMenuDemo = {
        id: "mobile-side-menu-demo",
        text: "Mobile Side Menu",
        args: {},
        argTypes: {},
        render: () => {
          const css2 = {
            ".demo-content": {
              padding: "20px",
              textAlign: "center"
            },
            ".demo-btn": {
              padding: "10px 20px",
              backgroundColor: "var(--primary-color, #4080ff)",
              color: "white",
              border: "none",
              borderRadius: "8px",
              cursor: "pointer",
              fontSize: "16px",
              marginTop: "20px"
            }
          };
          return /* @__PURE__ */ jsx("div", { css: css2, style: { width: "100%", height: "100%", position: "relative" }, children: [
            /* @__PURE__ */ jsx("div", { class: "demo-content", children: [
              /* @__PURE__ */ jsx("h3", { children: "Mobile Side Menu Demo" }),
              /* @__PURE__ */ jsx("p", { children: "You can open the menu by clicking the button below," }),
              /* @__PURE__ */ jsx("p", { children: /* @__PURE__ */ jsx("strong", { children: "OR by swiping from the left edge of the screen to the right." }) }),
              /* @__PURE__ */ jsx("button", { class: "demo-btn", onClick: () => MobileSideMenuHelper.show(), children: "Open Side Menu" })
            ] }),
            /* @__PURE__ */ jsx(MobileSideMenu, { children: /* @__PURE__ */ jsx(SideMenuMock, {}) })
          ] });
        },
        code: `// Show using method:
MobileSideMenuHelper.show();

<MobileSideMenu>
  {/* Add your custom content directly here */}
  <div>My Menu Content</div>
</MobileSideMenu>
`
      };
    }
  });

  // node_modules/lupine.components/src/components/slider-frame-demo.tsx
  var DummyInnerPage, sliderFrameDemo;
  var init_slider_frame_demo = __esm({
    "node_modules/lupine.components/src/components/slider-frame-demo.tsx"() {
      init_slider_frame();
      init_mobile_header_with_back();
      init_button();
      init_jsx_runtime();
      DummyInnerPage = ({ hook }) => {
        return /* @__PURE__ */ jsx(HeaderWithBackFrame, { title: "Slider Inner Page", onBack: (e) => hook.close(e), children: /* @__PURE__ */ jsx("div", { style: { padding: "20px", display: "flex", flexDirection: "column", gap: "20px" }, children: [
          /* @__PURE__ */ jsx("h3", { children: "This is the inner page content!" }),
          /* @__PURE__ */ jsx("p", { children: "You can put any scrollable content here. Click the back arrow in the header to close." }),
          /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(Button, { text: "Close Slider via Button", size: "button-m" /* Medium */, onClick: () => hook.close(null) }) })
        ] }) });
      };
      sliderFrameDemo = {
        id: "slider-frame-demo",
        text: "Slider Frame Demo",
        args: {
          direction: "right"
        },
        argTypes: {
          direction: {
            control: "select",
            options: ["right", "bottom"],
            description: "Direction the slider enters from"
          }
        },
        render: (args) => {
          const sliderHook = {};
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px", height: "100%", position: "relative" }, children: [
            /* @__PURE__ */ jsx("p", { style: { color: "#666", marginBottom: "20px" }, children: "This demo shows how to use SliderFrame to slide in a new full-cover page over the current view." }),
            /* @__PURE__ */ jsx(
              Button,
              {
                text: "Open Slider",
                size: "button-m" /* Medium */,
                onClick: () => {
                  sliderHook.load(/* @__PURE__ */ jsx(DummyInnerPage, { hook: sliderHook }));
                }
              }
            ),
            /* @__PURE__ */ jsx(SliderFrame2, { hook: sliderHook, direction: args.direction, defaultContent: "" })
          ] });
        },
        code: `import { SliderFrame, SliderFrameHookProps } from 'lupine.components/frames/slider-frame';
import { HeaderWithBackFrame } from 'lupine.components/components/mobile-components/mobile-header-with-back';
import { Button, ButtonSize } from 'lupine.components/components/button';

// 1. Define your inner page component
const InnerPage = ({ hook }: { hook: SliderFrameHookProps }) => {
  return (
    <HeaderWithBackFrame 
      title="Inner Page" 
      onBack={(e) => hook.close!(e)}
    >
      <div style={{ padding: '20px' }}>Content goes here</div>
    </HeaderWithBackFrame>
  );
};

// 2. Setup the hook and frame in your main page
const MyPage = () => {
  const sliderHook: SliderFrameHookProps = {};

  return (
    <div>
      <Button 
        text="Open Slider" 
        onClick={() => sliderHook.load!(<InnerPage hook={sliderHook} />)} 
      />
      
      {/* SliderFrame container */}
      <SliderFrame hook={sliderHook} direction="right" />
    </div>
  );
};
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/range/range.tsx
  var rangeCss, Range;
  var init_range = __esm({
    "node_modules/lupine.components/src/component-pool/range/range.tsx"() {
      init_src();
      init_jsx_runtime();
      rangeCss = {
        position: "relative",
        display: "flex",
        alignItems: "center",
        userSelect: "none",
        "&.horizontal": {
          flexDirection: "column",
          padding: "var(--space-m, 8px) 0",
          width: "100%",
          height: "auto",
          minWidth: "100%",
          minHeight: "40px"
        },
        "&.vertical": {
          flexDirection: "row",
          padding: "0 var(--space-m, 8px)",
          width: "auto",
          height: "100%",
          minWidth: "40px",
          minHeight: "200px"
        },
        "&.disabled": {
          opacity: "var(--primary-disabled-opacity, 0.5)",
          pointerEvents: "none"
        },
        ".&-wrapper": {
          position: "relative",
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        },
        "&.horizontal .&-wrapper": {
          width: "100%",
          height: "20px"
        },
        "&.vertical .&-wrapper": {
          width: "20px",
          height: "100%"
        },
        ".&-track": {
          position: "relative",
          backgroundColor: "var(--secondary-bg-color, #eee)",
          borderRadius: "999px"
        },
        "&.horizontal .&-track": {
          width: "100%",
          height: "8px"
        },
        "&.vertical .&-track": {
          width: "8px",
          height: "100%"
        },
        ".&-fill": {
          position: "absolute",
          backgroundColor: "var(--primary-accent-color, #0a74c9)",
          borderRadius: "999px"
        },
        "&.horizontal .&-fill": {
          left: "var(--range-fill-start, 0%)",
          width: "var(--range-fill-size, 0%)",
          top: 0,
          height: "100%"
        },
        "&.vertical .&-fill": {
          bottom: "var(--range-fill-start, 0%)",
          height: "var(--range-fill-size, 0%)",
          left: 0,
          width: "100%"
        },
        ".&-input": {
          position: "absolute",
          margin: 0,
          appearance: "none",
          WebkitAppearance: "none",
          background: "transparent",
          outline: "none",
          pointerEvents: "none",
          zIndex: 2
        },
        "&.horizontal .&-input": {
          width: "100%",
          height: "100%",
          top: 0,
          left: 0,
          transformOrigin: "none",
          transform: "none"
        },
        "&.vertical .&-input": {
          height: "20px",
          top: "100%",
          left: 0,
          transformOrigin: "0 0",
          transform: "rotate(-90deg)"
        },
        ".&-input::-webkit-slider-thumb": {
          appearance: "none",
          WebkitAppearance: "none",
          pointerEvents: "auto",
          width: "20px",
          height: "20px",
          backgroundColor: "#fff",
          border: "2px solid var(--primary-accent-color, #0a74c9)",
          borderRadius: "50%",
          cursor: "pointer",
          boxShadow: "0 1px 3px rgba(0,0,0,0.3)",
          transition: "transform 0.1s"
        },
        ".&-input::-webkit-slider-thumb:hover": {
          transform: "scale(1.15)"
        },
        ".&-input::-webkit-slider-thumb:active": {
          transform: "scale(0.95)"
        },
        ".&-input::-moz-range-thumb": {
          pointerEvents: "auto",
          width: "20px",
          height: "20px",
          backgroundColor: "#fff",
          border: "2px solid var(--primary-accent-color, #0a74c9)",
          borderRadius: "50%",
          cursor: "pointer",
          boxShadow: "0 1px 3px rgba(0,0,0,0.3)",
          transition: "transform 0.1s"
        },
        ".&-ticks": {
          position: "absolute",
          display: "flex",
          justifyContent: "space-between",
          pointerEvents: "none",
          fontSize: "12px",
          color: "var(--secondary-color, #818181)"
        },
        "&.horizontal .&-ticks": {
          top: "50%",
          bottom: "auto",
          left: 0,
          right: 0,
          marginTop: "4px",
          marginLeft: "4px",
          flexDirection: "row",
          height: "auto"
        },
        "&.vertical .&-ticks": {
          top: 0,
          bottom: 0,
          left: "20%",
          right: "auto",
          marginLeft: "8px",
          marginTop: 0,
          flexDirection: "column-reverse",
          height: "100%"
        },
        ".&-tick": {
          display: "flex",
          alignItems: "center"
        },
        "&.horizontal .&-tick": {
          flexDirection: "column"
        },
        "&.vertical .&-tick": {
          flexDirection: "row"
        },
        ".&-tick-mark": {
          backgroundColor: "var(--secondary-border-color, #a0a0a0)"
        },
        "&.horizontal .&-tick-mark": {
          width: "2px",
          height: "8px",
          marginBottom: "4px",
          marginRight: 0
        },
        "&.vertical .&-tick-mark": {
          width: "8px",
          height: "2px",
          marginBottom: 0,
          marginRight: "4px"
        }
      };
      Range = (props) => {
        const min = props.min ?? 0;
        const max = props.max ?? 100;
        const step = props.step ?? 1;
        const isRangeMode = !!props.range;
        const isVertical = !!props.vertical;
        const globalCssId = getGlobalStylesId(rangeCss);
        bindGlobalStyle(globalCssId, rangeCss);
        let val1 = 0;
        let val2 = 100;
        if (isRangeMode) {
          if (Array.isArray(props.value)) {
            val1 = props.value[0];
            val2 = props.value[1];
          } else {
            val1 = min;
            val2 = max;
          }
          if (val1 > val2) {
            const temp = val1;
            val1 = val2;
            val2 = temp;
          }
        } else {
          val1 = props.value ?? min;
        }
        let currentVal1 = val1;
        let currentVal2 = val2;
        const updateVisuals = () => {
          const fill = ref.$(".&-fill");
          if (!fill) return;
          if (isRangeMode) {
            const minPercent = (currentVal1 - min) / (max - min) * 100;
            const maxPercent = (currentVal2 - min) / (max - min) * 100;
            fill.style.setProperty("--range-fill-start", `${minPercent}%`);
            fill.style.setProperty("--range-fill-size", `${maxPercent - minPercent}%`);
            const inputMin = ref.$(".input-min");
            const inputMax = ref.$(".input-max");
            if (inputMin && inputMax) {
              if (minPercent > 50) {
                inputMin.style.zIndex = "3";
                inputMax.style.zIndex = "2";
              } else {
                inputMin.style.zIndex = "2";
                inputMax.style.zIndex = "3";
              }
            }
          } else {
            const percent = (currentVal1 - min) / (max - min) * 100;
            fill.style.setProperty("--range-fill-start", "0%");
            fill.style.setProperty("--range-fill-size", `${percent}%`);
          }
        };
        const handleInput = (e, isThumb2) => {
          const val = parseFloat(e.target.value);
          if (isRangeMode) {
            if (isThumb2) {
              currentVal2 = Math.max(val, currentVal1);
              e.target.value = currentVal2.toString();
              e.target.style.zIndex = "4";
              const sibling = ref.$(".input-min");
              if (sibling) sibling.style.zIndex = "3";
            } else {
              currentVal1 = Math.min(val, currentVal2);
              e.target.value = currentVal1.toString();
              e.target.style.zIndex = "4";
              const sibling = ref.$(".input-max");
              if (sibling) sibling.style.zIndex = "3";
            }
          } else {
            currentVal1 = val;
          }
          updateVisuals();
        };
        const handleChange = () => {
          if (props.onChange) {
            if (isRangeMode) {
              props.onChange([currentVal1, currentVal2]);
            } else {
              props.onChange(currentVal1);
            }
          }
        };
        if (props.hook) {
          props.hook.setValue = (val) => {
            if (isRangeMode && Array.isArray(val)) {
              currentVal1 = Math.min(Math.max(val[0], min), max);
              currentVal2 = Math.max(Math.min(val[1], max), currentVal1);
              const inputMin = ref.$(".input-min");
              const inputMax = ref.$(".input-max");
              if (inputMin) inputMin.value = currentVal1.toString();
              if (inputMax) inputMax.value = currentVal2.toString();
            } else if (!isRangeMode && typeof val === "number") {
              currentVal1 = Math.min(Math.max(val, min), max);
              const input = ref.$(".input-single");
              if (input) input.value = currentVal1.toString();
            }
            updateVisuals();
          };
          props.hook.getValue = () => isRangeMode ? [currentVal1, currentVal2] : currentVal1;
        }
        const ref = {
          globalCssId,
          onLoad: async () => {
            if (isVertical) {
              const wrapper = ref.$(".&-wrapper");
              const inputs = ref.$all(".&-input");
              if (wrapper && inputs) {
                const ro = new ResizeObserver(() => {
                  const height = wrapper.clientHeight;
                  inputs.forEach((input) => {
                    input.style.width = `${height}px`;
                  });
                });
                ro.observe(wrapper);
                ref._resizeObserver = ro;
              }
            }
            updateVisuals();
          },
          onUnload: async (el) => {
            if (ref._resizeObserver) {
              ref._resizeObserver.disconnect();
            }
          }
        };
        const ticks = [];
        if (props.showTicks || props.showTickLabels) {
          const tStep = props.tickStep || max - min;
          for (let i = min; i <= max; i += tStep) {
            ticks.push(i);
          }
          if (ticks[ticks.length - 1] !== max) {
            ticks.push(max);
          }
        }
        return /* @__PURE__ */ jsx(
          "div",
          {
            class: ["&-container", props.class, props.disabled ? "disabled" : "", isVertical ? "vertical" : "horizontal"].join(" ").trim(),
            ref,
            css: props.style,
            children: [
              /* @__PURE__ */ jsx("div", { class: "&-wrapper", children: [
                /* @__PURE__ */ jsx("div", { class: "&-track", children: /* @__PURE__ */ jsx("div", { class: "&-fill" }) }),
                isRangeMode ? /* @__PURE__ */ jsx(Fragment, { children: [
                  /* @__PURE__ */ jsx(
                    "input",
                    {
                      type: "range",
                      class: "&-input input-min",
                      min,
                      max,
                      step,
                      value: val1,
                      onInput: (e) => handleInput(e, false),
                      onChange: handleChange,
                      disabled: props.disabled
                    }
                  ),
                  /* @__PURE__ */ jsx(
                    "input",
                    {
                      type: "range",
                      class: "&-input input-max",
                      min,
                      max,
                      step,
                      value: val2,
                      onInput: (e) => handleInput(e, true),
                      onChange: handleChange,
                      disabled: props.disabled
                    }
                  )
                ] }) : /* @__PURE__ */ jsx(
                  "input",
                  {
                    type: "range",
                    class: "&-input input-single",
                    min,
                    max,
                    step,
                    value: val1,
                    onInput: (e) => handleInput(e, false),
                    onChange: handleChange,
                    disabled: props.disabled
                  }
                )
              ] }),
              (props.showTicks || props.showTickLabels) && /* @__PURE__ */ jsx("div", { class: "&-ticks", children: ticks.map((t) => /* @__PURE__ */ jsx("div", { class: "&-tick", children: [
                props.showTicks && /* @__PURE__ */ jsx("div", { class: "&-tick-mark" }),
                props.showTickLabels && /* @__PURE__ */ jsx("span", { children: t })
              ] })) })
            ]
          }
        );
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/svg-props.tsx
  var SvgSvg, SvgPath, SvgLine, SvgText, SvgCircle, SvgG, SvgRect, SvgPolyline, ClockIcon, ClearIcon, CheckIcon, IncompleteIcon, CalendarIcon, ChevronRightIcon, DotsIcon, CopyIcon, RefreshIcon;
  var init_svg_props = __esm({
    "node_modules/lupine.components/src/component-pool/svg-props.tsx"() {
      init_jsx_runtime();
      SvgSvg = "svg";
      SvgPath = "path";
      SvgLine = "line";
      SvgText = "text";
      SvgCircle = "circle";
      SvgG = "g";
      SvgRect = "rect";
      SvgPolyline = "polyline";
      ClockIcon = (props = {}) => /* @__PURE__ */ jsx(
        SvgSvg,
        {
          width: props.width || "14",
          height: props.height || "14",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: props.strokeWidth || "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: [
            /* @__PURE__ */ jsx(SvgCircle, { cx: "12", cy: "12", r: "10" }),
            /* @__PURE__ */ jsx(SvgPolyline, { points: "12 6 12 12 16 14" })
          ]
        }
      );
      ClearIcon = (props = {}) => /* @__PURE__ */ jsx(
        SvgSvg,
        {
          width: props.width || "12",
          height: props.height || "12",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: props.strokeWidth || "3",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: [
            /* @__PURE__ */ jsx(SvgLine, { x1: "18", y1: "6", x2: "6", y2: "18" }),
            /* @__PURE__ */ jsx(SvgLine, { x1: "6", y1: "6", x2: "18", y2: "18" })
          ]
        }
      );
      CheckIcon = (props = {}) => /* @__PURE__ */ jsx(
        SvgSvg,
        {
          width: props.width || "16",
          height: props.height || "16",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: props.strokeWidth || "3",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: /* @__PURE__ */ jsx(SvgPolyline, { points: "20 6 9 17 4 12" })
        }
      );
      IncompleteIcon = (props = {}) => /* @__PURE__ */ jsx(
        SvgSvg,
        {
          width: props.width || "16",
          height: props.height || "16",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: props.strokeWidth || "4",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: /* @__PURE__ */ jsx(SvgPath, { d: "M20 6L9 17l-5-5" })
        }
      );
      CalendarIcon = (props = {}) => /* @__PURE__ */ jsx(
        SvgSvg,
        {
          width: props.width || "14",
          height: props.height || "14",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: props.strokeWidth || "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: [
            /* @__PURE__ */ jsx(SvgRect, { x: "3", y: "4", width: "18", height: "18", rx: "2", ry: "2" }),
            /* @__PURE__ */ jsx(SvgLine, { x1: "16", y1: "2", x2: "16", y2: "6" }),
            /* @__PURE__ */ jsx(SvgLine, { x1: "8", y1: "2", x2: "8", y2: "6" }),
            /* @__PURE__ */ jsx(SvgLine, { x1: "3", y1: "10", x2: "21", y2: "10" })
          ]
        }
      );
      ChevronRightIcon = (props = {}) => /* @__PURE__ */ jsx(
        SvgSvg,
        {
          width: props.width || "14",
          height: props.height || "14",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: props.strokeWidth || "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: /* @__PURE__ */ jsx(SvgPath, { d: "M9 18l6-6-6-6" })
        }
      );
      DotsIcon = (props = {}) => /* @__PURE__ */ jsx(SvgSvg, { width: props.width || "16", height: props.height || "16", viewBox: "0 0 24 24", fill: "currentColor", children: [
        /* @__PURE__ */ jsx(SvgCircle, { cx: "5", cy: "12", r: "2" }),
        /* @__PURE__ */ jsx(SvgCircle, { cx: "12", cy: "12", r: "2" }),
        /* @__PURE__ */ jsx(SvgCircle, { cx: "19", cy: "12", r: "2" })
      ] });
      CopyIcon = (props = {}) => /* @__PURE__ */ jsx(
        SvgSvg,
        {
          width: props.width || "16",
          height: props.height || "16",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: props.strokeWidth || "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: [
            /* @__PURE__ */ jsx(SvgRect, { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }),
            /* @__PURE__ */ jsx(SvgPath, { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })
          ]
        }
      );
      RefreshIcon = (props = {}) => /* @__PURE__ */ jsx(
        SvgSvg,
        {
          width: props.width || "16",
          height: props.height || "16",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: props.strokeWidth || "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: [
            /* @__PURE__ */ jsx(SvgPolyline, { points: "23 4 23 10 17 10" }),
            /* @__PURE__ */ jsx(SvgPath, { d: "M20.49 15a9 9 0 1 1-2.12-9.36L23 10" })
          ]
        }
      );
    }
  });

  // node_modules/lupine.components/src/component-pool/range/gauge.tsx
  function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
    const angleInRadians = (angleInDegrees + 180) * (Math.PI / 180);
    return {
      x: centerX + radius * Math.cos(angleInRadians),
      y: centerY + radius * Math.sin(angleInRadians)
    };
  }
  function describeArc(x, y, radius, startAngle, endAngle) {
    if (Math.abs(endAngle - startAngle) < 0.1) return "";
    const start = polarToCartesian(x, y, radius, endAngle);
    const end = polarToCartesian(x, y, radius, startAngle);
    const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
    return ["M", start.x, start.y, "A", radius, radius, 0, largeArcFlag, 0, end.x, end.y].join(" ");
  }
  var gaugeCss, Gauge;
  var init_gauge = __esm({
    "node_modules/lupine.components/src/component-pool/range/gauge.tsx"() {
      init_src();
      init_svg_props();
      init_jsx_runtime();
      gaugeCss = {
        position: "relative",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        userSelect: "none",
        "&.disabled": {
          opacity: "var(--primary-disabled-opacity, 0.5)",
          pointerEvents: "none"
        },
        ".&-svg": {
          width: "100%",
          height: "auto",
          maxWidth: "300px",
          overflow: "visible",
          cursor: "pointer",
          touchAction: "none"
          // Prevent scrolling on touch devices while dragging
        },
        "&.readonly .&-svg": {
          cursor: "default"
        },
        ".&-track": {
          fill: "none",
          stroke: "var(--secondary-bg-color, #eee)",
          strokeWidth: 10,
          strokeLinecap: "round"
        },
        ".&-active-track": {
          fill: "none",
          /* We'll set stroke dynamically via style mapping to activeTrackColor */
          strokeWidth: 16,
          strokeLinecap: "round",
          opacity: 0.5
        },
        ".&-highlight": {
          fill: "none",
          strokeWidth: 10,
          strokeLinecap: "round"
        },
        ".&-needle": {
          fill: "var(--primary-accent-color, #0a74c9)",
          filter: "drop-shadow(0px 2px 4px rgba(0,0,0,0.3))",
          cursor: "grab",
          transition: "transform 0.1s ease-out"
        },
        ".&-needle:active": {
          cursor: "grabbing"
        },
        ".&-tick-mark": {
          stroke: "var(--secondary-border-color, #a0a0a0)",
          strokeWidth: 2
        },
        ".&-tick-label": {
          fill: "var(--secondary-color, #818181)",
          fontSize: "10px",
          textAnchor: "middle",
          dominantBaseline: "hanging",
          // Hangs below the anchor
          pointerEvents: "none"
        },
        ".&-value-display": {
          marginTop: "-10px",
          fontWeight: "bold",
          fontSize: "18px",
          color: "var(--primary-text-color, #000)",
          textAlign: "center"
        }
      };
      Gauge = (props) => {
        const min = props.min ?? 0;
        const max = props.max ?? 100;
        const step = props.step ?? 1;
        const isRange = !!props.range;
        const isReadonly = !!props.readonly;
        const showActiveTrack = props.showActiveTrack !== false;
        const activeColor = props.activeTrackColor || "var(--success-color, #2ecc71)";
        const globalCssId = getGlobalStylesId(gaugeCss);
        bindGlobalStyle(globalCssId, gaugeCss);
        let val1 = 0;
        let val2 = 100;
        if (isRange) {
          if (Array.isArray(props.value)) {
            val1 = props.value[0];
            val2 = props.value[1];
          } else {
            val1 = min;
            val2 = max;
          }
          if (val1 > val2) {
            const temp = val1;
            val1 = val2;
            val2 = temp;
          }
        } else {
          val1 = props.value ?? min;
        }
        let currentVal1 = val1;
        let currentVal2 = val2;
        let mv = false;
        const getPercent = (v) => {
          return Math.max(0, Math.min(1, (v - min) / (max - min)));
        };
        const updateVisuals = () => {
          const needle1 = ref.$(".needle-1");
          const needle2 = ref.$(".needle-2");
          const valDisplay = ref.$(".&-value-display");
          if (needle1) {
            const angle = getPercent(currentVal1) * 180;
            needle1.setAttribute("transform", `translate(100, 100) rotate(${angle})`);
          }
          if (isRange && needle2) {
            const angle = getPercent(currentVal2) * 180;
            needle2.setAttribute("transform", `translate(100, 100) rotate(${angle})`);
          }
          const activeTrack = ref.$(".&-active-track");
          if (activeTrack) {
            const startP = getPercent(isRange ? currentVal1 : min) * 180;
            const endP = getPercent(isRange ? currentVal2 : currentVal1) * 180;
            const d = describeArc(100, 100, 80, startP, endP);
            activeTrack.setAttribute("d", d);
          }
          if (valDisplay) {
            valDisplay.innerText = isRange ? `${currentVal1} - ${currentVal2}` : `${currentVal1}`;
          }
        };
        let draggingNeedle = null;
        const onPointerDown = (ev) => {
          if (props.disabled || isReadonly) return;
          const svg = ref.$(".&-svg");
          if (!svg) return;
          svg.setPointerCapture(ev.pointerId);
          mv = true;
          updatePosition(ev.clientX, ev.clientY);
        };
        const onPointerMove = (ev) => {
          if (!mv) return;
          updatePosition(ev.clientX, ev.clientY);
        };
        const onPointerUp = (ev) => {
          const svg = ref.$(".&-svg");
          if (svg) {
            svg.releasePointerCapture(ev.pointerId);
          }
          mv = false;
          draggingNeedle = null;
          if (props.onChange) {
            props.onChange(isRange ? [currentVal1, currentVal2] : currentVal1);
          }
        };
        const updatePosition = (cx, cy) => {
          const svg = ref.$(".&-svg");
          if (!svg) return;
          const rect = svg.getBoundingClientRect();
          const scaleX = rect.width / 200;
          const scaleY = rect.height / 120;
          const centerX = rect.left + 100 * scaleX;
          const centerY = rect.top + 100 * scaleY;
          const dx = cx - centerX;
          const dy = cy - centerY;
          let angle = Math.atan2(dy, dx);
          if (angle >= 0) {
            if (angle > Math.PI / 2) angle = -Math.PI;
            else angle = 0;
          }
          const percent = angle / Math.PI + 1;
          let val = min + percent * (max - min);
          if (step > 0) {
            val = Math.round((val - min) / step) * step + min;
          }
          val = Math.max(min, Math.min(max, val));
          if (isRange) {
            if (!draggingNeedle) {
              const dist1 = Math.abs(val - currentVal1);
              const dist2 = Math.abs(val - currentVal2);
              if (dist1 <= dist2) draggingNeedle = 1;
              else draggingNeedle = 2;
            }
            if (draggingNeedle === 1) {
              currentVal1 = Math.min(val, currentVal2);
            } else {
              currentVal2 = Math.max(val, currentVal1);
            }
          } else {
            currentVal1 = val;
          }
          updateVisuals();
        };
        if (props.hook) {
          props.hook.setValue = (val) => {
            if (isRange && Array.isArray(val)) {
              currentVal1 = Math.min(Math.max(val[0], min), max);
              currentVal2 = Math.max(Math.min(val[1], max), currentVal1);
            } else if (!isRange && typeof val === "number") {
              currentVal1 = Math.min(Math.max(val, min), max);
            }
            updateVisuals();
          };
          props.hook.getValue = () => isRange ? [currentVal1, currentVal2] : currentVal1;
        }
        const ref = {
          globalCssId,
          onLoad: async () => {
            updateVisuals();
          },
          onUnload: async (el) => {
            return Promise.resolve();
          }
        };
        const ticks = [];
        if (props.showTicks || props.showTickLabels) {
          const tStep = props.tickStep || max - min;
          const tickValues = [];
          for (let i = min; i <= max; i += tStep) {
            tickValues.push(i);
          }
          if (tickValues[tickValues.length - 1] !== max) {
            tickValues.push(max);
          }
          tickValues.forEach((t) => {
            const p = getPercent(t);
            const angle = p * 180;
            if (props.showTicks) {
              const start = polarToCartesian(100, 100, 72, angle);
              const end = polarToCartesian(100, 100, 65, angle);
              ticks.push(/* @__PURE__ */ jsx(SvgLine, { class: "&-tick-mark", x1: start.x, y1: start.y, x2: end.x, y2: end.y }));
            }
            if (props.showTickLabels) {
              const pos = polarToCartesian(100, 100, 52, angle);
              ticks.push(
                /* @__PURE__ */ jsx(SvgText, { class: "&-tick-label", x: pos.x, y: pos.y + 2, children: t })
              );
            }
          });
        }
        const highlightPaths = (props.highlights || []).map((h) => {
          const startP = getPercent(h.start) * 180;
          const endP = getPercent(h.end) * 180;
          const d = describeArc(100, 100, 80, startP, endP);
          return /* @__PURE__ */ jsx(SvgPath, { class: "&-highlight", d, style: { stroke: h.color || "var(--warning-color, #f39c12)" } });
        });
        return /* @__PURE__ */ jsx(
          "div",
          {
            class: ["&-container", props.class, props.disabled ? "disabled" : "", isReadonly ? "readonly" : ""].join(" ").trim(),
            ref,
            css: props.style,
            children: [
              /* @__PURE__ */ jsx(
                SvgSvg,
                {
                  class: "&-svg",
                  viewBox: "0 0 200 120",
                  onPointerDown,
                  onPointerMove,
                  onPointerUp,
                  children: [
                    showActiveTrack && /* @__PURE__ */ jsx(SvgPath, { class: "&-active-track", d: "", style: { stroke: activeColor } }),
                    /* @__PURE__ */ jsx(SvgPath, { class: "&-track", d: "M 20 100 A 80 80 0 0 1 180 100" }),
                    highlightPaths,
                    ticks,
                    !isRange ? /* @__PURE__ */ jsx(SvgG, { class: "&-needle needle-1", transform: "translate(100, 100) rotate(0)", children: [
                      /* @__PURE__ */ jsx(SvgPath, { d: "M 0 -8 L 0 8 L -82 2 L -82 -2 Z" }),
                      /* @__PURE__ */ jsx(SvgCircle, { cx: "0", cy: "0", r: "10" })
                    ] }) : /* @__PURE__ */ jsx(Fragment, { children: [
                      /* @__PURE__ */ jsx(SvgG, { class: "&-needle needle-1", transform: "translate(100, 100) rotate(0)", children: [
                        /* @__PURE__ */ jsx(SvgPath, { d: "M 0 -8 L 0 8 L -82 2 L -82 -2 Z" }),
                        /* @__PURE__ */ jsx(SvgCircle, { cx: "0", cy: "0", r: "10" })
                      ] }),
                      /* @__PURE__ */ jsx(SvgG, { class: "&-needle needle-2", transform: "translate(100, 100) rotate(180)", children: [
                        /* @__PURE__ */ jsx(SvgPath, { d: "M 0 -8 L 0 8 L -82 2 L -82 -2 Z" }),
                        /* @__PURE__ */ jsx(SvgCircle, { cx: "0", cy: "0", r: "10" })
                      ] })
                    ] })
                  ]
                }
              ),
              /* @__PURE__ */ jsx("div", { class: "&-value-display", children: isRange ? `${currentVal1} - ${currentVal2}` : currentVal1 })
            ]
          }
        );
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/range/range-demo.tsx
  var rangeDemo;
  var init_range_demo = __esm({
    "node_modules/lupine.components/src/component-pool/range/range-demo.tsx"() {
      init_range();
      init_jsx_runtime();
      rangeDemo = {
        id: "rangeDemo",
        text: "Range",
        args: {
          min: 0,
          max: 100,
          vertical: false,
          range: true,
          showTicks: true,
          showTickLabels: true,
          tickStep: 20,
          disabled: false
        },
        argTypes: {
          min: { control: "number" },
          max: { control: "number" },
          vertical: { control: "boolean" },
          range: { control: "boolean" },
          showTicks: { control: "boolean" },
          showTickLabels: { control: "boolean" },
          tickStep: { control: "number" },
          disabled: { control: "boolean" }
        },
        render: (args) => {
          const css2 = {
            display: "flex",
            flexDirection: "column",
            gap: "30px",
            padding: "20px",
            ".range-section": {
              display: "flex",
              flexDirection: "column",
              gap: "10px"
            },
            ".section-title": {
              fontWeight: "bold",
              fontSize: "16px",
              color: "var(--primary-color)"
            }
          };
          return /* @__PURE__ */ jsx("div", { css: css2, children: [
            /* @__PURE__ */ jsx("div", { class: "range-section", children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Interactive Range (Controlled by Panel)" }),
              /* @__PURE__ */ jsx(Range, { ...args, style: args.vertical ? { height: "300px" } : {} })
            ] }),
            !args.vertical && /* @__PURE__ */ jsx(Fragment, { children: [
              /* @__PURE__ */ jsx("div", { class: "range-section", children: [
                /* @__PURE__ */ jsx("div", { class: "section-title", children: "Standard Range (Single Thumb)" }),
                /* @__PURE__ */ jsx(Range, { min: 0, max: 100, value: 30, showTicks: true, showTickLabels: true, tickStep: 10 })
              ] }),
              /* @__PURE__ */ jsx("div", { class: "range-section", children: [
                /* @__PURE__ */ jsx("div", { class: "section-title", children: "Range Selector (Dual Thumbs)" }),
                /* @__PURE__ */ jsx(Range, { min: 0, max: 100, value: [20, 80], range: true, showTicks: true, showTickLabels: true, tickStep: 20 })
              ] }),
              /* @__PURE__ */ jsx("div", { class: "range-section", children: [
                /* @__PURE__ */ jsx("div", { class: "section-title", children: "Disabled State" }),
                /* @__PURE__ */ jsx(Range, { min: 0, max: 100, value: 50, disabled: true, showTicks: true, showTickLabels: true })
              ] })
            ] }),
            args.vertical && /* @__PURE__ */ jsx("div", { style: { display: "flex", gap: "40px", height: "300px" }, children: [
              /* @__PURE__ */ jsx("div", { class: "range-section", children: [
                /* @__PURE__ */ jsx("div", { class: "section-title", children: "Vertical Single" }),
                /* @__PURE__ */ jsx(Range, { vertical: true, min: 0, max: 100, value: 60, showTicks: true, showTickLabels: true, tickStep: 20 })
              ] }),
              /* @__PURE__ */ jsx("div", { class: "range-section", children: [
                /* @__PURE__ */ jsx("div", { class: "section-title", children: "Vertical Dual" }),
                /* @__PURE__ */ jsx(Range, { vertical: true, range: true, min: 0, max: 100, value: [25, 75], showTicks: true, showTickLabels: true, tickStep: 25 })
              ] })
            ] })
          ] });
        },
        code: `import { Range } from 'lupine.components/component-pool';

// Single thumb
<Range min={0} max={100} value={30} showTicks showTickLabels tickStep={10} />

// Dual thumbs (range)
<Range min={0} max={100} value={[20, 80]} range showTicks showTickLabels />

// Vertical
<Range vertical min={0} max={100} value={50} />
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/range/gauge-demo.tsx
  var gaugeDemo;
  var init_gauge_demo = __esm({
    "node_modules/lupine.components/src/component-pool/range/gauge-demo.tsx"() {
      init_gauge();
      init_jsx_runtime();
      gaugeDemo = {
        id: "gauge-demo",
        text: "Gauge / Dial Demo",
        args: {
          min: 0,
          max: 100,
          step: 1,
          value: 30,
          rangeValue: [20, 80],
          disabled: false,
          readonly: false,
          showTicks: true,
          showTickLabels: true,
          showActiveTrack: true,
          activeTrackColor: "#2ecc71",
          tickStep: 10
        },
        argTypes: {
          min: { control: "number" },
          max: { control: "number" },
          step: { control: "number" },
          value: { control: "number", description: "Single Dial Value" },
          disabled: { control: "boolean" },
          readonly: { control: "boolean" },
          showTicks: { control: "boolean" },
          showTickLabels: { control: "boolean" },
          showActiveTrack: { control: "boolean" },
          activeTrackColor: { control: "color" },
          tickStep: { control: "number" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px", display: "flex", flexDirection: "column", gap: "40px" }, children: [
            /* @__PURE__ */ jsx("div", { style: { display: "flex", flexDirection: "column", alignItems: "center", gap: "10px" }, children: [
              /* @__PURE__ */ jsx("h3", { children: "Standard Dashboard Gauge" }),
              /* @__PURE__ */ jsx(
                Gauge,
                {
                  min: args.min,
                  max: args.max,
                  step: args.step,
                  value: args.value,
                  disabled: args.disabled,
                  readonly: args.readonly,
                  showTicks: args.showTicks,
                  showTickLabels: args.showTickLabels,
                  showActiveTrack: args.showActiveTrack,
                  activeTrackColor: args.activeTrackColor,
                  tickStep: args.tickStep,
                  highlights: [
                    { start: 0, end: 40, color: "var(--success-color, #2ecc71)" },
                    // Safe zone
                    { start: 40, end: 80, color: "var(--warning-color, #f39c12)" },
                    // Warning zone
                    { start: 80, end: 100, color: "var(--danger-color, #e74c3c)" }
                    // Danger zone
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsx("div", { style: { display: "flex", flexDirection: "column", alignItems: "center", gap: "10px" }, children: [
              /* @__PURE__ */ jsx("h3", { children: "Dual Range Frequency Selector" }),
              /* @__PURE__ */ jsx(
                Gauge,
                {
                  min: args.min,
                  max: args.max,
                  step: args.step,
                  value: args.rangeValue,
                  range: true,
                  disabled: args.disabled,
                  readonly: args.readonly,
                  showTicks: args.showTicks,
                  showTickLabels: args.showTickLabels,
                  showActiveTrack: args.showActiveTrack,
                  activeTrackColor: args.activeTrackColor,
                  tickStep: args.tickStep,
                  highlights: [
                    // Highlight the selected range directly!
                    { start: args.rangeValue[0], end: args.rangeValue[1], color: "rgba(10, 116, 201, 0.4)" }
                  ]
                }
              ),
              /* @__PURE__ */ jsx("p", { style: { color: "var(--secondary-color)", fontSize: "14px" }, children: "Note: The highlighted region statically binds to initial Props (doesn't hook reactively inside demo loop)." })
            ] })
          ] });
        },
        code: `import { Gauge } from 'lupine.components/component-pool';

// Single Gauge with Danger Zones
<Gauge 
  min={0} max={100} value={85} 
  showTicks={true}
  showTickLabels={true}
  tickStep={10}
  highlights={[
    { start: 0, end: 60, color: 'green' },
    { start: 60, end: 80, color: 'yellow' },
    { start: 80, end: 100, color: 'red' },
  ]}
  onChange={(v) => console.log(v)} 
/>

// Dual Range Frequency Selector
<Gauge 
  range={true}
  min={0} max={100} value={[20, 80]}
  showTicks={true}
  showTickLabels={true}
  tickStep={20}
  onChange={(v) => console.log('Range Selected:', v)}
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/range/index.ts
  var init_range2 = __esm({
    "node_modules/lupine.components/src/component-pool/range/index.ts"() {
      init_range();
      init_gauge();
      init_range_demo();
      init_gauge_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/badge/badge.tsx
  var badgeCss, Badge;
  var init_badge = __esm({
    "node_modules/lupine.components/src/component-pool/badge/badge.tsx"() {
      init_src();
      init_jsx_runtime();
      badgeCss = {
        display: "inline-flex",
        position: "relative",
        verticalAlign: "middle",
        ".&-bubble": {
          position: "absolute",
          top: 0,
          right: 0,
          transform: "translate(50%, -50%)",
          transformOrigin: "100% 0%",
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          padding: "0 6px",
          height: "20px",
          minWidth: "20px",
          borderRadius: "10px",
          fontSize: "12px",
          fontWeight: "bold",
          lineHeight: "1",
          whiteSpace: "nowrap",
          backgroundColor: "var(--danger-color, #e74c3c)",
          color: "#ffffff",
          boxShadow: "0 0 0 1px var(--primary-bg-color, #ffffff)",
          zIndex: 10
        },
        ".&-bubble.is-dot": {
          padding: 0,
          height: "8px",
          minWidth: "8px",
          width: "8px",
          borderRadius: "50%"
        },
        ".&-bubble.is-standalone": {
          position: "relative",
          transform: "none"
        }
      };
      Badge = (props) => {
        const globalCssId = getGlobalStylesId(badgeCss);
        bindGlobalStyle(globalCssId, badgeCss);
        const ref = {
          globalCssId
        };
        let displayContent = props.content;
        if (typeof displayContent === "number" && props.max && displayContent > props.max) {
          displayContent = `${props.max}+`;
        }
        const bubbleStyle = {};
        if (props.bgColor) bubbleStyle.backgroundColor = props.bgColor;
        if (props.color) bubbleStyle.color = props.color;
        const hasChildren = props.children && (Array.isArray(props.children) ? props.children.length > 0 : true);
        const isSup = !props.dot && displayContent !== void 0 && displayContent !== null && displayContent !== "";
        const showBubble = props.dot || isSup;
        return /* @__PURE__ */ jsx("div", { class: ["&-container", props.class].join(" ").trim(), ref, css: props.style, onClick: props.onClick, children: [
          props.children,
          showBubble && /* @__PURE__ */ jsx(
            "sup",
            {
              class: ["&-bubble", props.dot ? "is-dot" : "", !hasChildren ? "is-standalone" : ""].join(" ").trim(),
              style: bubbleStyle,
              children: !props.dot && displayContent
            }
          )
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/badge/badge-demo.tsx
  var BellIcon, CheckIcon2, badgeDemo;
  var init_badge_demo = __esm({
    "node_modules/lupine.components/src/component-pool/badge/badge-demo.tsx"() {
      init_badge();
      init_svg_props();
      init_jsx_runtime();
      BellIcon = () => /* @__PURE__ */ jsx(
        SvgSvg,
        {
          width: "24",
          height: "24",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          children: [
            /* @__PURE__ */ jsx(SvgPath, { d: "M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9" }),
            /* @__PURE__ */ jsx(SvgPath, { d: "M13.73 21a2 2 0 0 1-3.46 0" })
          ]
        }
      );
      CheckIcon2 = () => /* @__PURE__ */ jsx(
        SvgSvg,
        {
          width: "12",
          height: "12",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          "stroke-width": "3",
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          children: /* @__PURE__ */ jsx(SvgPath, { d: "M20 6L9 17l-5-5" })
        }
      );
      badgeDemo = {
        id: "badge",
        text: "Badge",
        args: {
          content: 5,
          max: 99,
          dot: false,
          color: "#ffffff",
          bgColor: "#e74c3c"
        },
        argTypes: {
          content: { control: "number", description: "Number or text to display" },
          max: { control: "number", description: "Max number before showing +" },
          dot: { control: "boolean", description: "Show as dot instead of value" },
          color: { control: "color", description: "Text color" },
          bgColor: { control: "color", description: "Background color" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { display: "flex", flexDirection: "column", gap: "30px", padding: "20px" }, children: /* @__PURE__ */ jsx("div", { style: { display: "flex", gap: "40px", alignItems: "center", flexWrap: "wrap" }, children: [
            /* @__PURE__ */ jsx("div", { style: { textAlign: "center" }, children: [
              /* @__PURE__ */ jsx("div", { style: { marginBottom: "16px" }, children: "Interactive Config" }),
              /* @__PURE__ */ jsx(
                Badge,
                {
                  content: args.content,
                  max: args.max,
                  dot: args.dot,
                  color: args.color,
                  bgColor: args.bgColor,
                  onClick: () => alert(`Badge clicked: ${args.content}`),
                  children: /* @__PURE__ */ jsx("div", { style: { padding: "8px 16px", backgroundColor: "#f0f0f0", borderRadius: "4px" }, children: "Messages" })
                }
              )
            ] }),
            /* @__PURE__ */ jsx("div", { style: { textAlign: "center" }, children: [
              /* @__PURE__ */ jsx("div", { style: { marginBottom: "16px" }, children: "Max Value (99+)" }),
              /* @__PURE__ */ jsx(Badge, { content: 150, max: 99, children: /* @__PURE__ */ jsx("div", { style: { padding: "8px 16px", backgroundColor: "#f0f0f0", borderRadius: "4px" }, children: "Notifications" }) })
            ] }),
            /* @__PURE__ */ jsx("div", { style: { textAlign: "center" }, children: [
              /* @__PURE__ */ jsx("div", { style: { marginBottom: "16px" }, children: "Dot Mode" }),
              /* @__PURE__ */ jsx(Badge, { dot: true, children: /* @__PURE__ */ jsx(BellIcon, {}) })
            ] }),
            /* @__PURE__ */ jsx("div", { style: { textAlign: "center" }, children: [
              /* @__PURE__ */ jsx("div", { style: { marginBottom: "16px" }, children: "Custom Node Content" }),
              /* @__PURE__ */ jsx(Badge, { content: /* @__PURE__ */ jsx(CheckIcon2, {}), bgColor: "var(--success-color, #2ecc71)", children: /* @__PURE__ */ jsx("div", { style: { width: "40px", height: "40px", backgroundColor: "#eee", borderRadius: "4px" } }) })
            ] }),
            /* @__PURE__ */ jsx("div", { style: { textAlign: "center" }, children: [
              /* @__PURE__ */ jsx("div", { style: { marginBottom: "16px" }, children: "Text Content" }),
              /* @__PURE__ */ jsx(Badge, { content: "NEW", bgColor: "var(--primary-accent-color, #0a74c9)", children: /* @__PURE__ */ jsx("div", { style: { padding: "8px 16px", backgroundColor: "#f0f0f0", borderRadius: "4px" }, children: "Features" }) })
            ] }),
            /* @__PURE__ */ jsx("div", { style: { textAlign: "center" }, children: [
              /* @__PURE__ */ jsx("div", { style: { marginBottom: "16px" }, children: "Standalone Badge" }),
              /* @__PURE__ */ jsx(Badge, { content: "Status: Online", bgColor: "var(--success-color, #2ecc71)" })
            ] })
          ] }) });
        },
        code: `import { Badge } from 'lupine.components/component-pool';

<Badge content={5} max={99} bgColor="red" color="white" onClick={...}>
  <div>Anchor Element</div>
</Badge>

<Badge dot={true}>
  <Icon />
</Badge>

<Badge content={<CheckIcon />} bgColor="green">
  <div>Task</div>
</Badge>
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/badge/index.ts
  var init_badge2 = __esm({
    "node_modules/lupine.components/src/component-pool/badge/index.ts"() {
      init_badge();
      init_badge_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/timeline/timeline.tsx
  var timelineCss, Timeline;
  var init_timeline = __esm({
    "node_modules/lupine.components/src/component-pool/timeline/timeline.tsx"() {
      init_src();
      init_svg_props();
      init_jsx_runtime();
      timelineCss = {
        position: "relative",
        width: "100%",
        minHeight: "80px",
        display: "flex",
        alignItems: "center",
        ".&-line": {
          position: "absolute",
          top: "50%",
          left: "0",
          right: "0",
          height: "var(--timeline-line-thickness, 4px)",
          transform: "translateY(-50%)",
          zIndex: 1
        },
        ".&-node": {
          position: "absolute",
          top: "50%",
          transform: "translate(-50%, -50%)",
          zIndex: 2,
          display: "flex",
          flexDirection: "column",
          alignItems: "center"
        },
        ".&-icon-wrapper": {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          width: "24px",
          height: "24px",
          borderRadius: "50%",
          fontSize: "14px",
          // added for step mode text
          fontWeight: "bold",
          // added for step mode text
          color: "var(--primary-bg-color, #fff)",
          zIndex: 2
          // Ensure the circle stays above the continuous line
        },
        ".&-icon-wrapper.step-completed": {
          backgroundColor: "var(--primary-accent-color, #0a74c9)"
        },
        ".&-icon-wrapper.step-incomplete": {
          backgroundColor: "var(--secondary-color, #818181)"
        },
        ".&-top-label, .&-bottom-info": {
          position: "absolute",
          left: "50%",
          transform: "translateX(-50%)",
          textAlign: "center",
          whiteSpace: "nowrap",
          overflow: "hidden",
          textOverflow: "ellipsis",
          maxWidth: "100px",
          // Prevents extreme overlaps
          fontSize: "12px",
          padding: "0 4px"
        },
        ".&-top-label": {
          bottom: "24px",
          fontWeight: "bold"
        },
        ".&-bottom-info": {
          top: "24px",
          color: "var(--secondary-color, #666)"
        }
      };
      Timeline = (props) => {
        const globalCssId = getGlobalStylesId(timelineCss);
        bindGlobalStyle(globalCssId, timelineCss);
        const ref = {
          globalCssId
        };
        const lineColor = props.lineColor || "var(--secondary-border-color, #ccc)";
        const topLabelColor = props.topLabelColor || "var(--primary-text-color, #000)";
        const containerStyle = {
          ...props.style,
          "--timeline-line-thickness": props.lineThickness || "4px"
        };
        return /* @__PURE__ */ jsx("div", { class: ["&-container", props.class].join(" ").trim(), ref, css: containerStyle, children: [
          /* @__PURE__ */ jsx("div", { class: "&-line", style: { backgroundColor: lineColor } }),
          (props.items || []).map((item, index) => {
            let nodeContent = null;
            let wrapperClass = "&-icon-wrapper";
            wrapperClass += item.completed ? " step-completed" : " step-incomplete";
            if (props.stepMode) {
              nodeContent = item.icon !== void 0 ? item.icon : index + 1;
            } else {
              if (item.icon !== void 0) {
                nodeContent = item.icon;
              } else {
                nodeContent = item.completed ? /* @__PURE__ */ jsx(CheckIcon, { strokeWidth: "4" }) : /* @__PURE__ */ jsx(IncompleteIcon, { strokeWidth: "4" });
              }
            }
            return /* @__PURE__ */ jsx("div", { class: "&-node", style: { left: `${item.percent}%` }, children: [
              item.topLabel && /* @__PURE__ */ jsx(
                "div",
                {
                  class: "&-top-label",
                  style: { color: topLabelColor },
                  title: typeof item.topLabel === "string" ? item.topLabel : "",
                  children: item.topLabel
                }
              ),
              /* @__PURE__ */ jsx("div", { class: wrapperClass, children: nodeContent }),
              item.bottomInfo && /* @__PURE__ */ jsx("div", { class: "&-bottom-info", title: typeof item.bottomInfo === "string" ? item.bottomInfo : "", children: item.bottomInfo })
            ] });
          })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/timeline/timeline-demo.tsx
  var timelineDemo;
  var init_timeline_demo = __esm({
    "node_modules/lupine.components/src/component-pool/timeline/timeline-demo.tsx"() {
      init_timeline();
      init_jsx_runtime();
      timelineDemo = {
        id: "timeline",
        text: "Timeline",
        args: {
          lineColor: "#cccccc",
          lineThickness: "4px",
          topLabelColor: "#000000",
          stepMode: false,
          items: []
          // Will be overridden in render, but needed for type definition
        },
        argTypes: {
          lineColor: { control: "color", description: "Line color" },
          lineThickness: { control: "text", description: "Thickness of the timeline connecting line" },
          topLabelColor: { control: "color", description: "Top label text color" },
          stepMode: { control: "boolean", description: "Show numerical steps instead of icons" }
        },
        render: (args) => {
          const items = [
            { percent: 0, topLabel: "2021", bottomInfo: "Project Kickoff", completed: true },
            { percent: 30, topLabel: "2022", bottomInfo: "Alpha Release (Internal)", completed: true },
            { percent: 70, topLabel: "2023", bottomInfo: "Beta Release (Public Testing)", completed: false },
            { percent: 100, topLabel: "2024", bottomInfo: "Final Production Release", completed: false }
          ];
          const stepItems = [
            { percent: 0, bottomInfo: "Cart", completed: true },
            { percent: 50, bottomInfo: "Payment", completed: true },
            { percent: 100, bottomInfo: "Confirmation", completed: false }
          ];
          return /* @__PURE__ */ jsx("div", { style: { padding: "60px 20px", width: "100%", boxSizing: "border-box" }, children: /* @__PURE__ */ jsx("div", { style: { maxWidth: "800px", margin: "0 auto", display: "flex", flexDirection: "column", gap: "80px" }, children: [
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginBottom: "40px", textAlign: "center" }, children: "Horizontal Project Timeline" }),
              /* @__PURE__ */ jsx(
                Timeline,
                {
                  items,
                  lineColor: args.lineColor,
                  lineThickness: args.lineThickness,
                  topLabelColor: args.topLabelColor,
                  stepMode: args.stepMode
                }
              )
            ] }),
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginBottom: "40px", textAlign: "center" }, children: "Step Mode (Checkout Flow)" }),
              /* @__PURE__ */ jsx(
                Timeline,
                {
                  items: stepItems,
                  lineColor: args.lineColor,
                  lineThickness: args.lineThickness,
                  topLabelColor: args.topLabelColor,
                  stepMode: true
                }
              )
            ] })
          ] }) });
        },
        code: `import { Timeline } from 'lupine.components/component-pool';

const items = [
  { percent: 0, topLabel: '2021', bottomInfo: 'Start', completed: true },
  { percent: 50, topLabel: '2022', bottomInfo: 'Beta', completed: true },
  { percent: 100, topLabel: '2025', bottomInfo: 'Final', completed: false },
];

<Timeline 
  items={items} 
  lineColor="#ccc" 
  topLabelColor="#000" 
/>`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/timeline/index.ts
  var init_timeline2 = __esm({
    "node_modules/lupine.components/src/component-pool/timeline/index.ts"() {
      init_timeline();
      init_timeline_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/radial-progress/radial-progress.tsx
  var RadialProgress;
  var init_radial_progress = __esm({
    "node_modules/lupine.components/src/component-pool/radial-progress/radial-progress.tsx"() {
      init_src();
      init_svg_props();
      init_jsx_runtime();
      RadialProgress = (props) => {
        const css2 = {
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          position: "relative",
          // Default size fallback if no ButtonSize is used
          width: "40px",
          height: "40px",
          // predefined sizes matching ButtonSize visually
          "&.button-ss": { width: "24px", height: "24px", fontSize: "10px" },
          "&.button-s": { width: "32px", height: "32px", fontSize: "12px" },
          "&.button-m": { width: "40px", height: "40px", fontSize: "14px" },
          "&.button-l": { width: "48px", height: "48px", fontSize: "16px" },
          "&.button-ll": { width: "64px", height: "64px", fontSize: "18px" },
          ".&-svg": {
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            transform: "rotate(-90deg)"
            // Start from top
          },
          ".&-track": {
            fill: "none",
            strokeWidth: 8
            // 100x100 viewBox
          },
          ".&-progress": {
            fill: "none",
            strokeWidth: 8,
            transition: "stroke-dashoffset 0.3s ease"
          },
          ".&-text": {
            fontFamily: "var(--font-family, sans-serif)",
            fontWeight: "bold",
            color: "var(--primary-text-color, #000)"
          }
        };
        const globalCssId = getGlobalStylesId(css2);
        bindGlobalStyle(globalCssId, css2);
        let currentValue = props.value !== void 0 ? Math.max(0, Math.min(100, props.value)) : 0;
        const circumference = 282.743;
        const getOffset = (val) => circumference - val / 100 * circumference;
        const progressCircleRef = {};
        const textRef = {};
        if (props.hook) {
          props.hook.onProgress = (percentage) => {
            currentValue = Math.max(0, Math.min(100, Math.round(percentage)));
            if (progressCircleRef.current) {
              progressCircleRef.current.style.strokeDashoffset = `${getOffset(currentValue)}`;
            }
            if (textRef.current) {
              textRef.current.textContent = `${currentValue}%`;
            }
          };
        }
        const containerRef = {
          globalCssId
        };
        const progressColor = props.color || "var(--primary-accent-color, #0a74c9)";
        const trackColor = props.trackColor || "var(--secondary-border-color, #e0e0e0)";
        const sizeClass = props.size || "button-m" /* Medium */;
        return /* @__PURE__ */ jsx("div", { class: ["&-container", sizeClass, props.class].join(" ").trim(), ref: containerRef, css: props.style, children: [
          /* @__PURE__ */ jsx(SvgSvg, { class: "&-svg", viewBox: "0 0 100 100", children: [
            /* @__PURE__ */ jsx(SvgCircle, { class: "&-track", cx: "50", cy: "50", r: "45", style: { stroke: trackColor } }),
            /* @__PURE__ */ jsx(
              SvgCircle,
              {
                class: "&-progress",
                ref: progressCircleRef,
                cx: "50",
                cy: "50",
                r: "45",
                style: {
                  stroke: progressColor,
                  strokeDasharray: circumference,
                  strokeDashoffset: getOffset(currentValue)
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsx("span", { class: "&-text", ref: textRef, children: [
            currentValue,
            "%"
          ] })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/radial-progress/radial-progress-demo.tsx
  var radialProgressDemo;
  var init_radial_progress_demo = __esm({
    "node_modules/lupine.components/src/component-pool/radial-progress/radial-progress-demo.tsx"() {
      init_radial_progress();
      init_button();
      init_jsx_runtime();
      radialProgressDemo = {
        id: "radial-progress",
        text: "Radial Progress",
        args: {
          color: "#0a74c9",
          trackColor: "#e0e0e0",
          value: 75,
          size: "button-l" /* Large */
        },
        argTypes: {
          color: { control: "color", description: "Progress ring color" },
          trackColor: { control: "color", description: "Background track ring color" },
          value: { control: "number", description: "Current completion percentage" },
          size: { control: "select", options: Object.values(ButtonSize), description: "Component pixel size mapping" }
        },
        render: (args) => {
          const hookData = { onProgress: null };
          let simValue = 0;
          const startSimulation = () => {
            simValue = 0;
            const interval = setInterval(() => {
              simValue += 5;
              if (hookData.onProgress) {
                hookData.onProgress(simValue);
              }
              if (simValue >= 100) clearInterval(interval);
            }, 100);
          };
          return /* @__PURE__ */ jsx("div", { style: { padding: "40px", display: "flex", flexDirection: "column", gap: "60px", alignItems: "center" }, children: [
            /* @__PURE__ */ jsx("div", { style: { textAlign: "center" }, children: [
              /* @__PURE__ */ jsx("h3", { children: "Declarative Value & Dynamic Sizes" }),
              /* @__PURE__ */ jsx(
                "div",
                {
                  style: {
                    display: "flex",
                    gap: "20px",
                    alignItems: "flex-end",
                    justifyContent: "center",
                    marginTop: "20px"
                  },
                  children: [
                    /* @__PURE__ */ jsx(RadialProgress, { value: 10, size: "button-ss" /* SmallLarge */ }),
                    /* @__PURE__ */ jsx(RadialProgress, { value: 30, size: "button-s" /* Small */ }),
                    /* @__PURE__ */ jsx(RadialProgress, { value: args.value, size: args.size, color: args.color, trackColor: args.trackColor }),
                    /* @__PURE__ */ jsx(RadialProgress, { value: 85, size: "button-ll" /* LargeLarge */, color: "#49e57e" })
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsx("div", { style: { textAlign: "center" }, children: [
              /* @__PURE__ */ jsx("h3", { children: "Hook-Driven Realtime Animation" }),
              /* @__PURE__ */ jsx("p", { style: { color: "#666", fontSize: "12px", marginBottom: "20px" }, children: "Click the button below to simulate loading" }),
              /* @__PURE__ */ jsx(RadialProgress, { value: 0, size: "button-l" /* Large */, hook: hookData }),
              /* @__PURE__ */ jsx("div", { style: { marginTop: "20px" }, children: /* @__PURE__ */ jsx(Button, { onClick: startSimulation, size: "button-l" /* Large */, text: "Start Upload/Download Simulation" }) })
            ] })
          ] });
        },
        code: `import { RadialProgress } from 'lupine.components/component-pool';
import { ButtonSize } from 'lupine.components/src/components/button.tsx';

// 1. Static declarative rendering
<RadialProgress value={75} size={ButtonSize.Large} color="var(--primary-accent-color)" />

// 2. Reactivity with hooks
const progressHook = {};
<RadialProgress hook={progressHook} size={ButtonSize.Medium} />

// Later triggering the hook update
progressHook.onProgress(100);
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/radial-progress/index.ts
  var init_radial_progress2 = __esm({
    "node_modules/lupine.components/src/component-pool/radial-progress/index.ts"() {
      init_radial_progress();
      init_radial_progress_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/breadcrumbs/breadcrumbs.tsx
  var Breadcrumbs;
  var init_breadcrumbs = __esm({
    "node_modules/lupine.components/src/component-pool/breadcrumbs/breadcrumbs.tsx"() {
      init_src();
      init_svg_props();
      init_jsx_runtime();
      Breadcrumbs = (props) => {
        const css2 = {
          display: "flex",
          width: "100%",
          minWidth: 0,
          position: "relative",
          overflow: "hidden",
          padding: "8px 0",
          boxSizing: "border-box",
          "&.is-measuring .&-list, &.is-initializing .&-list": {
            position: "absolute",
            visibility: "hidden"
          },
          ".&-list": {
            display: "flex",
            flexWrap: "nowrap",
            alignItems: "center",
            margin: 0,
            padding: 0,
            listStyle: "none",
            width: "100%"
          },
          ".&-item": {
            display: "inline-flex",
            alignItems: "center",
            whiteSpace: "nowrap",
            flexShrink: 0,
            color: "var(--secondary-color, #6b7280)",
            fontSize: "14px",
            transition: "color 0.2s"
          },
          ".&-item.is-active": {
            color: "var(--primary-text-color, #111827)",
            fontWeight: "500"
          },
          ".&-item a": {
            color: "inherit",
            textDecoration: "none",
            cursor: "pointer",
            display: "inline-flex",
            alignItems: "center",
            gap: "4px",
            transition: "color 0.2s"
          },
          ".&-item a:hover": {
            color: "var(--primary-text-color, #111827)"
          },
          ".&-separator": {
            display: "inline-flex",
            margin: "0 8px",
            color: "var(--secondary-color, #9ca3af)",
            opacity: 0.8,
            flexShrink: 0
          },
          ".&-ellipsis": {
            display: "none",
            alignItems: "center",
            justifyContent: "center",
            padding: "2px 4px",
            margin: "0 2px",
            color: "var(--secondary-color, #6b7280)",
            cursor: "default",
            borderRadius: "4px",
            transition: "background-color 0.2s, color 0.2s"
          }
        };
        const globalCssId = getGlobalStylesId(css2);
        bindGlobalStyle(globalCssId, css2);
        const autoCollapse = props.autoCollapse !== false;
        let ro = null;
        let timer = null;
        const ref = {
          globalCssId,
          onLoad: async () => {
            if (!autoCollapse) return;
            const container = ref.current;
            const list2 = ref.$(".&-list");
            if (!list2) return;
            const checkOverflow = () => {
              if (timer) clearTimeout(timer);
              timer = setTimeout(() => {
                const cItems = list2.querySelectorAll(".collapsible-item");
                const cSeps = list2.querySelectorAll(".collapsible-separator");
                const ellipsis = ref.$(".&-ellipsis");
                if (!cItems.length) {
                  container.classList.remove("is-initializing");
                  return;
                }
                cItems.forEach((el) => el.style.display = "");
                cSeps.forEach((el) => el.style.display = "");
                if (ellipsis) ellipsis.style.display = "none";
                container.classList.add("is-measuring");
                const listWidth = list2.scrollWidth;
                const containerWidth = container.clientWidth;
                container.classList.remove("is-measuring");
                if (listWidth > containerWidth) {
                  if (ellipsis) ellipsis.style.display = "inline-flex";
                  for (let k = 1; k <= cItems.length; k++) {
                    cItems[k - 1].style.display = "none";
                    if (k >= 2) {
                      cSeps[k - 2].style.display = "none";
                    }
                    if (list2.scrollWidth <= container.clientWidth) {
                      break;
                    }
                  }
                }
                container.classList.remove("is-initializing");
              }, 80);
            };
            ro = new ResizeObserver(() => checkOverflow());
            ro.observe(container);
          },
          onUnload: async () => {
            if (ro) ro.disconnect();
            if (timer) clearTimeout(timer);
          }
        };
        const items = props.items || [];
        const Separator = props.separator || /* @__PURE__ */ jsx(ChevronRightIcon, {});
        return /* @__PURE__ */ jsx(
          "nav",
          {
            class: ["&-container", autoCollapse ? "is-initializing" : "", props.class].join(" ").trim(),
            ref,
            css: props.style,
            "aria-label": "Breadcrumb",
            children: /* @__PURE__ */ jsx("ol", { class: "&-list", children: items.map((item, index) => {
              const isFirst = index === 0;
              const isLast = index === items.length - 1;
              const isCollapsible = !isFirst && !isLast && items.length > 2;
              const isCollapsibleSeparator = isCollapsible && index > 1;
              return /* @__PURE__ */ jsx(Fragment, { children: [
                index > 0 && /* @__PURE__ */ jsx(
                  "li",
                  {
                    class: ["&-separator", isCollapsibleSeparator ? "collapsible-separator" : ""].join(" ").trim(),
                    "aria-hidden": "true",
                    children: Separator
                  }
                ),
                index === 1 && items.length > 2 && /* @__PURE__ */ jsx("li", { class: "&-ellipsis", "aria-hidden": "true", title: "More items hidden", children: /* @__PURE__ */ jsx(DotsIcon, {}) }),
                /* @__PURE__ */ jsx(
                  "li",
                  {
                    class: ["&-item", isCollapsible ? "collapsible-item" : "", isLast ? "is-active" : ""].join(" ").trim(),
                    "aria-current": isLast ? "page" : void 0,
                    children: item.url && !isLast ? /* @__PURE__ */ jsx("a", { href: item.url, children: [
                      item.icon,
                      item.text
                    ] }) : /* @__PURE__ */ jsx("span", { style: { display: "inline-flex", alignItems: "center", gap: "4px" }, children: [
                      item.icon,
                      item.text
                    ] })
                  }
                )
              ] });
            }) })
          }
        );
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/breadcrumbs/breadcrumbs-demo.tsx
  var HomeIcon, FolderIcon, breadcrumbsDemo;
  var init_breadcrumbs_demo = __esm({
    "node_modules/lupine.components/src/component-pool/breadcrumbs/breadcrumbs-demo.tsx"() {
      init_breadcrumbs();
      init_svg_props();
      init_jsx_runtime();
      HomeIcon = () => /* @__PURE__ */ jsx(
        SvgSvg,
        {
          width: "14",
          height: "14",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          children: [
            /* @__PURE__ */ jsx(SvgPath, { d: "M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" }),
            /* @__PURE__ */ jsx(SvgPath, { d: "M9 22V12h6v10" })
          ]
        }
      );
      FolderIcon = () => /* @__PURE__ */ jsx(
        SvgSvg,
        {
          width: "14",
          height: "14",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          "stroke-width": "2",
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          children: /* @__PURE__ */ jsx(SvgPath, { d: "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z" })
        }
      );
      breadcrumbsDemo = {
        id: "breadcrumbs",
        text: "Breadcrumbs",
        args: {
          autoCollapse: true,
          items: []
        },
        argTypes: {
          autoCollapse: { control: "boolean", description: "Automatically collapse middle items on overflow" }
        },
        render: (args) => {
          const longItems = [
            { text: "Home", url: "/", icon: /* @__PURE__ */ jsx(HomeIcon, {}) },
            { text: "Settings", url: "/settings", icon: /* @__PURE__ */ jsx(FolderIcon, {}) },
            { text: "Account Profile", url: "/account" },
            { text: "Security Preferences", url: "/security" },
            { text: "Two-Factor Auth", url: "/2fa" },
            { text: "Active Sessions" }
          ];
          const shortItems = [{ text: "Dashboard", url: "/dashboard" }, { text: "Overview" }];
          return /* @__PURE__ */ jsx("div", { style: { padding: "40px", display: "flex", flexDirection: "column", gap: "40px" }, children: [
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginBottom: "20px" }, children: "Auto-Collapsing Long Breadcrumbs" }),
              /* @__PURE__ */ jsx("p", { style: { color: "#666", fontSize: "13px", marginBottom: "10px" }, children: "Scale the window (or iframe) down to see the middle sections collapse into an ellipsis `...`" }),
              /* @__PURE__ */ jsx("div", { style: { padding: "16px", border: "1px solid #eee", borderRadius: "8px", backgroundColor: "#fafafa" }, children: /* @__PURE__ */ jsx(Breadcrumbs, { items: longItems, autoCollapse: args.autoCollapse }) })
            ] }),
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginBottom: "20px" }, children: "Short Breadcrumbs" }),
              /* @__PURE__ */ jsx("div", { style: { padding: "16px", border: "1px solid #eee", borderRadius: "8px", backgroundColor: "#fafafa" }, children: /* @__PURE__ */ jsx(Breadcrumbs, { items: shortItems, autoCollapse: args.autoCollapse }) })
            ] })
          ] });
        },
        code: `import { Breadcrumbs } from 'lupine.components/component-pool';

const items = [
  { text: 'Home', url: '/' },
  { text: 'Settings', url: '/settings' },
  { text: 'Account Profile', url: '/account' },
  { text: 'Active Sessions' }, // Last item is automatically rendered as current page
];

// Automatically handles overflow and collapse logic naturally via container ResizeObserver
<Breadcrumbs items={items} autoCollapse={true} />
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/breadcrumbs/index.ts
  var init_breadcrumbs2 = __esm({
    "node_modules/lupine.components/src/component-pool/breadcrumbs/index.ts"() {
      init_breadcrumbs();
      init_breadcrumbs_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/skeleton/skeleton.tsx
  var Skeleton;
  var init_skeleton = __esm({
    "node_modules/lupine.components/src/component-pool/skeleton/skeleton.tsx"() {
      init_src();
      init_jsx_runtime();
      Skeleton = (props) => {
        const css2 = {
          display: "block",
          backgroundColor: "var(--secondary-bg-color, #e5e7eb)",
          borderRadius: "var(--border-radius-m, 4px)",
          flexShrink: 0,
          // Explicit global keyframes, ensuring it exists regardless of Tailwind context
          "@keyframes lupine-skeleton-pulse": {
            "0%, 100%": { opacity: 1 },
            "50%": { opacity: 0.5 }
          },
          "&.is-animated": {
            animation: "lupine-skeleton-pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite"
          },
          "&.is-circle": {
            borderRadius: "50%"
          }
        };
        const globalCssId = getGlobalStylesId(css2);
        bindGlobalStyle(globalCssId, css2);
        const ref = {
          globalCssId
        };
        const isAnimated = props.animated !== false;
        const isCircle = props.circle === true;
        const width = props.width || "100%";
        const height = props.height || "100%";
        const mergedStyle = {
          width,
          height,
          ...props.style
        };
        return /* @__PURE__ */ jsx(
          "div",
          {
            class: ["&-container", isAnimated ? "is-animated" : "", isCircle ? "is-circle" : "", props.class].join(" ").trim(),
            ref,
            css: mergedStyle,
            "aria-hidden": "true"
          }
        );
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/skeleton/skeleton-card.tsx
  var SkeletonCard;
  var init_skeleton_card = __esm({
    "node_modules/lupine.components/src/component-pool/skeleton/skeleton-card.tsx"() {
      init_src();
      init_skeleton();
      init_jsx_runtime();
      SkeletonCard = (props) => {
        const css2 = {
          display: "flex",
          gap: "16px",
          alignItems: "flex-start",
          width: "100%",
          height: "100%",
          padding: "24px",
          boxSizing: "border-box",
          border: "1px solid var(--secondary-border-color, #eee)",
          borderRadius: "12px",
          backgroundColor: "var(--primary-bg-color, #fff)",
          overflow: "hidden",
          ".&-content": {
            flex: 1,
            display: "flex",
            flexDirection: "column",
            gap: "8px",
            minWidth: 0
          }
        };
        const globalCssId = getGlobalStylesId(css2);
        bindGlobalStyle(globalCssId, css2);
        const animated = props.animated !== false;
        let ro = null;
        let timer = null;
        const contentRef = {};
        const ref = {
          globalCssId,
          onLoad: async () => {
            const container = ref.current;
            const refreshLines = () => {
              if (timer) clearTimeout(timer);
              timer = setTimeout(() => {
                const style = window.getComputedStyle(container);
                const paddingTop = parseFloat(style.paddingTop);
                const paddingBottom = parseFloat(style.paddingBottom);
                const availableHeight = container.clientHeight - paddingTop - paddingBottom;
                let remainingHeight = availableHeight;
                const lines = [];
                if (remainingHeight >= 20) {
                  lines.push(/* @__PURE__ */ jsx(Skeleton, { width: "60%", height: "20px", animated }));
                  remainingHeight -= 28;
                }
                if (remainingHeight >= 16) {
                  lines.push(/* @__PURE__ */ jsx(Skeleton, { width: "100%", height: "16px", animated }));
                  remainingHeight -= 24;
                }
                while (remainingHeight >= 16) {
                  lines.push(/* @__PURE__ */ jsx(Skeleton, { width: Math.random() > 0.5 ? "80%" : "90%", height: "16px", animated }));
                  remainingHeight -= 24;
                }
                if (contentRef.mountInnerComponent) {
                  contentRef.mountInnerComponent(/* @__PURE__ */ jsx(Fragment, { children: lines }));
                }
              }, 50);
            };
            ro = new ResizeObserver(() => refreshLines());
            ro.observe(container);
          },
          onUnload: async () => {
            if (ro) ro.disconnect();
            if (timer) clearTimeout(timer);
          }
        };
        const mergedStyle = {
          width: props.width || "100%",
          height: props.height || "100%",
          ...props.style
        };
        return /* @__PURE__ */ jsx("div", { class: ["&-container", props.class].join(" ").trim(), ref, css: mergedStyle, "aria-hidden": "true", children: [
          /* @__PURE__ */ jsx(Skeleton, { width: "48px", height: "48px", circle: true, animated }),
          /* @__PURE__ */ jsx("div", { class: "&-content", ref: contentRef })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/skeleton/skeleton-demo.tsx
  var skeletonDemo;
  var init_skeleton_demo = __esm({
    "node_modules/lupine.components/src/component-pool/skeleton/skeleton-demo.tsx"() {
      init_skeleton();
      init_skeleton_card();
      init_jsx_runtime();
      skeletonDemo = {
        id: "skeleton",
        text: "Skeleton",
        args: {
          width: "100%",
          height: "24px",
          circle: false,
          animated: true
        },
        argTypes: {
          width: { control: "text", description: "Width of the skeleton" },
          height: { control: "text", description: "Height of the skeleton" },
          circle: { control: "boolean", description: "Render as a circle" },
          animated: { control: "boolean", description: "Enable pulse animation" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { padding: "40px", display: "flex", flexDirection: "column", gap: "40px" }, children: [
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginBottom: "20px" }, children: "Interactive Skeleton" }),
              /* @__PURE__ */ jsx(Skeleton, { ...args })
            ] }),
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginBottom: "20px" }, children: "Card Example (Dynamic Height)" }),
              /* @__PURE__ */ jsx("p", { style: { color: "#666", fontSize: "13px", marginBottom: "10px" }, children: "The SkeletonCard automatically fills available vertical space with skeleton lines. Resize the browser to see it adapt!" }),
              /* @__PURE__ */ jsx("div", { style: { height: "200px", resize: "vertical", overflow: "hidden" }, children: /* @__PURE__ */ jsx(SkeletonCard, { height: "100%", animated: args.animated }) })
            ] })
          ] });
        },
        code: `import { Skeleton } from 'lupine.components/component-pool';

// Basic Line
<Skeleton width="100%" height="24px" />

// Circle (Avatar)
<Skeleton width="48px" height="48px" circle={true} />

// Static (No animation)
<Skeleton width="100%" height="100px" animated={false} />

// Dynamic Auto-filling Card
<SkeletonCard width="100%" height="300px" />
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/skeleton/index.ts
  var init_skeleton2 = __esm({
    "node_modules/lupine.components/src/component-pool/skeleton/index.ts"() {
      init_skeleton();
      init_skeleton_card();
      init_skeleton_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/copy-button/copy-button.tsx
  var css, CopyButton;
  var init_copy_button = __esm({
    "node_modules/lupine.components/src/component-pool/copy-button/copy-button.tsx"() {
      init_src();
      init_svg_props();
      init_jsx_runtime();
      css = {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "6px",
        padding: "6px 12px",
        borderRadius: "var(--border-radius-m, 6px)",
        fontSize: "14px",
        fontWeight: "500",
        cursor: "pointer",
        transition: "all 0.2s ease",
        outline: "none",
        border: "1px solid transparent",
        backgroundColor: "transparent",
        color: "inherit",
        // Default styles based on variant
        "&.variant-solid": {
          backgroundColor: "var(--primary-color, #3b82f6)",
          color: "#fff",
          "&:hover": {
            filter: "brightness(1.1)"
          },
          "&:active": {
            transform: "scale(0.97)"
          }
        },
        "&.variant-outline": {
          border: "1px solid var(--secondary-border-color, #e5e7eb)",
          backgroundColor: "var(--primary-bg-color, #fff)",
          color: "var(--primary-text-color, #111827)",
          "&:hover": {
            backgroundColor: "var(--secondary-bg-color, #f3f4f6)"
          },
          "&:active": {
            transform: "scale(0.97)"
          }
        },
        "&.variant-ghost": {
          padding: "6px",
          color: "var(--secondary-color, #6b7280)",
          "&:hover": {
            backgroundColor: "var(--secondary-bg-color, #f3f4f6)",
            color: "var(--primary-text-color, #111827)"
          },
          "&:active": {
            transform: "scale(0.95)"
          }
        },
        // Internal content wrappers
        ".&-content": {
          display: "inline-flex",
          alignItems: "center",
          gap: "6px",
          transition: "opacity 0.2s ease"
        },
        // State toggling
        "& .&-copied-content": {
          display: "none"
        },
        "&.is-copied": {
          color: "var(--success-color, #10b981)",
          borderColor: "var(--success-color, #10b981)"
        },
        "&.is-copied.variant-solid": {
          backgroundColor: "var(--success-color, #10b981)",
          borderColor: "transparent",
          color: "#fff"
        },
        "&.is-copied .&-default-content": {
          display: "none"
        },
        "&.is-copied .&-copied-content": {
          display: "inline-flex"
        }
      };
      CopyButton = (props) => {
        const globalCssId = getGlobalStylesId(css);
        bindGlobalStyle(globalCssId, css);
        const onClick = async () => {
          if (!props.text) return;
          try {
            const textToCopy = props.text();
            await navigator.clipboard.writeText(textToCopy);
            ref.current.classList.add("is-copied");
            setTimeout(() => {
              ref.current.classList.remove("is-copied");
            }, 2e3);
          } catch (err) {
            console.error("Failed to copy text: ", err);
          }
        };
        const ref = {
          globalCssId
        };
        const variantClass = `variant-${props.variant || "outline"}`;
        const DefaultContent = props.children || /* @__PURE__ */ jsx(Fragment, { children: [
          /* @__PURE__ */ jsx(CopyIcon, {}),
          " Copy"
        ] });
        const CopiedContent = props.copiedContent || /* @__PURE__ */ jsx(Fragment, { children: [
          /* @__PURE__ */ jsx(CheckIcon, {}),
          " Copied!"
        ] });
        return /* @__PURE__ */ jsx(
          "button",
          {
            class: ["&-container", variantClass, props.class].join(" ").trim(),
            ref,
            css: props.style,
            type: "button",
            onClick,
            "aria-label": "Copy to clipboard",
            children: [
              /* @__PURE__ */ jsx("span", { class: "&-content &-default-content", children: DefaultContent }),
              /* @__PURE__ */ jsx("span", { class: "&-content &-copied-content", children: CopiedContent })
            ]
          }
        );
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/copy-button/copy-button-demo.tsx
  var copyButtonDemo;
  var init_copy_button_demo = __esm({
    "node_modules/lupine.components/src/component-pool/copy-button/copy-button-demo.tsx"() {
      init_copy_button();
      init_jsx_runtime();
      copyButtonDemo = {
        id: "copy-button",
        text: "CopyButton",
        args: {
          text: () => "npm install lupine.js",
          variant: "outline"
        },
        argTypes: {
          variant: { control: "select", options: ["outline", "solid", "ghost"], description: "Button style variant" },
          timeoutMs: { control: "number", description: "Time (ms) before reverting from copied state (default: 2000)" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { padding: "40px", display: "flex", flexDirection: "column", gap: "40px" }, children: [
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginBottom: "16px" }, children: "Interactive Copy Button" }),
              /* @__PURE__ */ jsx(CopyButton, { ...args })
            ] }),
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginBottom: "16px" }, children: "Variants" }),
              /* @__PURE__ */ jsx("div", { style: { display: "flex", gap: "12px", flexWrap: "wrap", alignItems: "center" }, children: [
                /* @__PURE__ */ jsx(CopyButton, { text: () => "Copy me!", variant: "solid", children: "Solid" }),
                /* @__PURE__ */ jsx(CopyButton, { text: () => "Copy me!", variant: "outline", children: "Outline" }),
                /* @__PURE__ */ jsx(CopyButton, { text: () => "Copy me!", variant: "ghost" })
              ] })
            ] }),
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginBottom: "16px" }, children: "Inline with Code Block" }),
              /* @__PURE__ */ jsx(
                "div",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    gap: "12px",
                    padding: "12px 16px",
                    borderRadius: "8px",
                    backgroundColor: "var(--secondary-bg-color, #f3f4f6)",
                    fontFamily: "monospace",
                    fontSize: "14px"
                  },
                  children: [
                    /* @__PURE__ */ jsx("span", { style: { flex: 1 }, children: "npm install lupine.js" }),
                    /* @__PURE__ */ jsx(CopyButton, { text: () => "npm install lupine.js", variant: "ghost" })
                  ]
                }
              )
            ] })
          ] });
        },
        code: `import { CopyButton } from 'lupine.components/component-pool';

// Default (outline) with auto icons \u2014 text is a function returning string
<CopyButton text={() => 'npm install lupine.js'} />

// Solid variant
<CopyButton text={() => 'hello world'} variant="solid">Copy</CopyButton>

// Ghost icon-only variant (shows copy icon by default)
<CopyButton text={() => 'hello world'} variant="ghost" />

// Dynamic text \u2014 useful for copying from DOM at click time
<CopyButton text={() => ref.$('input').value} />
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/copy-button/index.ts
  var init_copy_button2 = __esm({
    "node_modules/lupine.components/src/component-pool/copy-button/index.ts"() {
      init_copy_button();
      init_copy_button_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/aspect-ratio/aspect-ratio.tsx
  var AspectRatio;
  var init_aspect_ratio = __esm({
    "node_modules/lupine.components/src/component-pool/aspect-ratio/aspect-ratio.tsx"() {
      init_src();
      init_jsx_runtime();
      AspectRatio = (props) => {
        const css2 = {
          position: "relative",
          width: "100%",
          overflow: "hidden",
          ".&-inner": {
            position: "absolute",
            inset: 0,
            width: "100%",
            height: "100%"
          }
        };
        const globalCssId = getGlobalStylesId(css2);
        bindGlobalStyle(globalCssId, css2);
        const ref = {
          globalCssId
        };
        const ratio = props.ratio ?? 16 / 9;
        const paddingTop = `${1 / ratio * 100}%`;
        return /* @__PURE__ */ jsx("div", { class: ["&-container", props.class].join(" ").trim(), ref, css: { paddingTop, ...props.style }, children: /* @__PURE__ */ jsx("div", { class: "&-inner", children: props.children }) });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/aspect-ratio/aspect-ratio-demo.tsx
  var aspectRatioDemo;
  var init_aspect_ratio_demo = __esm({
    "node_modules/lupine.components/src/component-pool/aspect-ratio/aspect-ratio-demo.tsx"() {
      init_aspect_ratio();
      init_jsx_runtime();
      aspectRatioDemo = {
        id: "aspect-ratio",
        text: "AspectRatio",
        args: {
          ratio: 16 / 9,
          children: /* @__PURE__ */ jsx("div", {})
        },
        argTypes: {
          ratio: {
            control: "select",
            options: [16 / 9, 4 / 3, 1, 9 / 16],
            description: "Aspect ratio (width / height)"
          }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { padding: "40px", display: "flex", flexDirection: "column", gap: "40px", maxWidth: "600px" }, children: [
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginBottom: "8px" }, children: "16 / 9 (Video)" }),
              /* @__PURE__ */ jsx(AspectRatio, { ratio: 16 / 9, children: /* @__PURE__ */ jsx(
                "div",
                {
                  style: {
                    width: "100%",
                    height: "100%",
                    backgroundColor: "var(--secondary-bg-color, #e5e7eb)",
                    borderRadius: "8px",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    color: "var(--secondary-color, #6b7280)",
                    fontSize: "14px"
                  },
                  children: "16:9 Content"
                }
              ) })
            ] }),
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginBottom: "8px" }, children: "4 / 3 (Classic Photo)" }),
              /* @__PURE__ */ jsx(AspectRatio, { ratio: 4 / 3, children: /* @__PURE__ */ jsx(
                "div",
                {
                  style: {
                    width: "100%",
                    height: "100%",
                    backgroundColor: "var(--secondary-bg-color, #e5e7eb)",
                    borderRadius: "8px",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    color: "var(--secondary-color, #6b7280)",
                    fontSize: "14px"
                  },
                  children: "4:3 Content"
                }
              ) })
            ] }),
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginBottom: "8px" }, children: "1 / 1 (Square)" }),
              /* @__PURE__ */ jsx(AspectRatio, { ratio: 1, children: /* @__PURE__ */ jsx(
                "div",
                {
                  style: {
                    width: "100%",
                    height: "100%",
                    backgroundColor: "var(--secondary-bg-color, #e5e7eb)",
                    borderRadius: "8px",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    color: "var(--secondary-color, #6b7280)",
                    fontSize: "14px"
                  },
                  children: "1:1 Content"
                }
              ) })
            ] })
          ] });
        },
        code: `import { AspectRatio } from 'lupine.components/component-pool';

// Video embed (16:9)
<AspectRatio ratio={16 / 9}>
  <iframe src="..." style={{ width: '100%', height: '100%', border: 'none' }} />
</AspectRatio>

// Image (4:3)
<AspectRatio ratio={4 / 3}>
  <img src="..." style={{ width: '100%', height: '100%', objectFit: 'cover' }} />
</AspectRatio>

// Square
<AspectRatio ratio={1}>
  <img src="..." style={{ width: '100%', height: '100%', objectFit: 'cover' }} />
</AspectRatio>
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/aspect-ratio/index.ts
  var init_aspect_ratio2 = __esm({
    "node_modules/lupine.components/src/component-pool/aspect-ratio/index.ts"() {
      init_aspect_ratio();
      init_aspect_ratio_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/map-wrapper/map-wrapper.tsx
  var MapWrapper;
  var init_map_wrapper = __esm({
    "node_modules/lupine.components/src/component-pool/map-wrapper/map-wrapper.tsx"() {
      init_src();
      init_jsx_runtime();
      MapWrapper = (props) => {
        const css2 = {
          display: "block",
          width: "100%",
          overflow: "hidden",
          borderRadius: "var(--border-radius-m, 8px)",
          backgroundColor: "var(--secondary-bg-color, #e5e7eb)",
          ".&-iframe": {
            display: "block",
            width: "100%",
            height: "100%",
            border: "none"
          }
        };
        const globalCssId = getGlobalStylesId(css2);
        bindGlobalStyle(globalCssId, css2);
        const lat = props.lat ?? 35.6762;
        const lng = props.lng ?? 139.6503;
        const zoom = props.zoom ?? 13;
        const buildSrc = (lat2, lng2, zoom2) => `https://www.openstreetmap.org/export/embed.html?bbox=${lng2 - 0.05},${lat2 - 0.05},${lng2 + 0.05},${lat2 + 0.05}&layer=mapnik&marker=${lat2},${lng2}`;
        const ref = {
          globalCssId,
          onLoad: async () => {
            const iframe = ref.$(".&-iframe");
            if (!iframe) return;
            if (props.hook) {
              props.hook.reload = () => {
                if (iframe) {
                  iframe.src = iframe.src;
                }
              };
            }
          }
        };
        const width = props.width || "100%";
        const height = props.height || "300px";
        return /* @__PURE__ */ jsx("div", { class: ["&-container", props.class].join(" ").trim(), ref, css: { width, height, ...props.style }, children: /* @__PURE__ */ jsx(
          "iframe",
          {
            class: "&-iframe",
            src: buildSrc(lat, lng, zoom),
            allowFullScreen: true,
            loading: "lazy",
            referrerpolicy: "no-referrer-when-downgrade",
            title: "Map"
          }
        ) });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/map-wrapper/map-wrapper-demo.tsx
  var mapWrapperDemo;
  var init_map_wrapper_demo = __esm({
    "node_modules/lupine.components/src/component-pool/map-wrapper/map-wrapper-demo.tsx"() {
      init_map_wrapper();
      init_jsx_runtime();
      mapWrapperDemo = {
        id: "map-wrapper",
        text: "MapWrapper",
        args: {
          lat: 35.6762,
          lng: 139.6503,
          zoom: 13,
          height: "350px"
        },
        argTypes: {
          lat: { control: "number", description: "Center latitude" },
          lng: { control: "number", description: "Center longitude" },
          zoom: { control: "number", description: "Zoom level (1-19)" },
          height: { control: "text", description: "Map height" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { padding: "40px", display: "flex", flexDirection: "column", gap: "40px" }, children: [
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginBottom: "8px" }, children: "Interactive Map (OpenStreetMap)" }),
              /* @__PURE__ */ jsx("p", { style: { color: "#666", fontSize: "13px", marginBottom: "12px" }, children: "Adjust lat/lng/zoom in the controls panel. Powered by OpenStreetMap \u2014 no API key required." }),
              /* @__PURE__ */ jsx(MapWrapper, { ...args })
            ] }),
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginBottom: "8px" }, children: "New York City" }),
              /* @__PURE__ */ jsx(MapWrapper, { lat: 40.7128, lng: -74.006, zoom: 12, height: "250px" })
            ] }),
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginBottom: "8px" }, children: "London" }),
              /* @__PURE__ */ jsx(MapWrapper, { lat: 51.5074, lng: -0.1278, zoom: 12, height: "250px" })
            ] })
          ] });
        },
        code: `import { MapWrapper } from 'lupine.components/component-pool';

// Basic usage \u2014 centers on Tokyo by default
<MapWrapper />

// Custom location
<MapWrapper lat={40.7128} lng={-74.0060} zoom={12} height="400px" />

// With hook for programmatic reload
const hook: MapWrapperHookProps = {};
<MapWrapper lat={35.6762} lng={139.6503} hook={hook} />
// Later: hook.reload?.();
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/map-wrapper/index.ts
  var init_map_wrapper2 = __esm({
    "node_modules/lupine.components/src/component-pool/map-wrapper/index.ts"() {
      init_map_wrapper();
      init_map_wrapper_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/avatar/avatar.tsx
  var avatarCss, groupCss, Avatar, AvatarGroup;
  var init_avatar = __esm({
    "node_modules/lupine.components/src/component-pool/avatar/avatar.tsx"() {
      init_src();
      init_src2();
      init_jsx_runtime();
      avatarCss = {
        display: "inline-block",
        position: "relative",
        verticalAlign: "middle",
        // Inner wrapper for content clipping/border
        ".&-content": {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          width: "100%",
          height: "100%",
          backgroundColor: "var(--secondary-bg-color, #f0f0f0)",
          color: "var(--secondary-color, #666)",
          overflow: "hidden",
          border: "1px solid var(--secondary-border-color, #ddd)",
          fontSize: "14px",
          fontWeight: "500",
          transition: "all 0.2s ease"
        },
        "&.shape-circle .&-content": { borderRadius: "50%" },
        "&.shape-rounded .&-content": { borderRadius: "var(--border-radius-m, 8px)" },
        "&.shape-square .&-content": { borderRadius: "0" },
        "&.size-xs": { width: "24px", height: "24px" },
        "&.size-sm": { width: "32px", height: "32px" },
        "&.size-md": { width: "40px", height: "40px" },
        "&.size-lg": { width: "48px", height: "48px" },
        "&.size-xl": { width: "64px", height: "64px" },
        "&.size-xs .&-content": { fontSize: "10px" },
        "&.size-xl .&-content": { fontSize: "20px" },
        ".&-img": {
          width: "100%",
          height: "100%",
          objectFit: "cover"
        },
        ".&-status": {
          position: "absolute",
          bottom: "0",
          right: "0",
          width: "25%",
          height: "25%",
          minWidth: "8px",
          minHeight: "8px",
          borderRadius: "50%",
          border: "2px solid var(--primary-bg-color, #fff)",
          backgroundColor: "#999",
          zIndex: 1
        },
        ".&-status.status-online": { backgroundColor: "var(--success-color, #2ecc71)" },
        ".&-status.status-offline": { backgroundColor: "var(--secondary-border-color, #999)" },
        ".&-status.status-busy": { backgroundColor: "var(--error-color, #e74c3c)" },
        ".&-status.status-away": { backgroundColor: "var(--warning-color, #f39c12)" }
      };
      groupCss = {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        ".&-item": {
          marginLeft: "-12px",
          border: "2px solid var(--primary-bg-color, #fff)",
          borderRadius: "50%",
          zIndex: 0
        },
        ".&-item:first-child": {
          marginLeft: "0"
        },
        ".&-item:hover": {
          zIndex: 1
        }
      };
      Avatar = (props) => {
        const size = props.size || "md";
        const shape = props.shape || "circle";
        const status = props.online ? "online" : props.status;
        const globalCssId = getGlobalStylesId(avatarCss);
        bindGlobalStyle(globalCssId, avatarCss);
        const renderInitials = () => /* @__PURE__ */ jsx("span", { children: props.initials || "?" });
        const renderContent = () => {
          if (props.src) {
            return /* @__PURE__ */ jsx(
              "img",
              {
                class: "&-img",
                src: props.src,
                onError: () => {
                  avatarContent.value = renderInitials();
                }
              }
            );
          }
          return renderInitials();
        };
        const avatarContent = new HtmlVar(renderContent());
        const ref = {
          globalCssId
        };
        return /* @__PURE__ */ jsx("div", { class: [`size-${size}`, `shape-${shape}`, props.class].join(" ").trim(), ref, css: props.style, children: [
          /* @__PURE__ */ jsx("div", { class: "&-content", children: avatarContent.node }),
          status && /* @__PURE__ */ jsx("div", { class: ["&-status", `status-${status}`].join(" ") })
        ] });
      };
      AvatarGroup = (props) => {
        var _a, _b;
        const globalCssId = getGlobalStylesId(groupCss);
        bindGlobalStyle(globalCssId, groupCss);
        const ref = {
          globalCssId
        };
        const children = Array.isArray(props.children) ? props.children : [props.children];
        const max = props.maxCount || children.length;
        const visibleItems = children.slice(0, max);
        const remaining = children.length - max;
        const items = visibleItems.map((child) => {
          if (child && typeof child === "object" && child.props) {
            if (props.size && !child.props.size) child.props.size = props.size;
            child.props.class = [child.props.class, "&-item"].join(" ").trim();
          }
          return child;
        });
        if (remaining > 0) {
          items.push(
            /* @__PURE__ */ jsx(
              Avatar,
              {
                class: "&-item",
                size: props.size || ((_b = (_a = visibleItems[0]) == null ? void 0 : _a.props) == null ? void 0 : _b.size) || "md",
                initials: `+${remaining}`
              }
            )
          );
        }
        return /* @__PURE__ */ jsx("div", { ref, class: ["&-group", props.class].join(" ").trim(), css: props.style, children: items });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/avatar/avatar-demo.tsx
  var avatarDemo;
  var init_avatar_demo = __esm({
    "node_modules/lupine.components/src/component-pool/avatar/avatar-demo.tsx"() {
      init_avatar();
      init_jsx_runtime();
      avatarDemo = {
        id: "avatarDemo",
        text: "Avatar",
        args: {
          maxCount: 3,
          size: "md",
          shape: "circle"
        },
        argTypes: {
          maxCount: {
            control: "number",
            description: "Maximum visible avatars in a group"
          },
          size: {
            control: "select",
            options: ["xs", "sm", "md", "lg", "xl"],
            description: "Size of the avatars"
          },
          shape: {
            control: "select",
            options: ["circle", "rounded", "square"],
            description: "Shape of the avatars"
          }
        },
        render: (args) => {
          const css2 = {
            display: "flex",
            flexDirection: "column",
            gap: "24px",
            padding: "24px",
            ".section-title": {
              fontSize: "18px",
              fontWeight: "bold",
              marginBottom: "12px",
              color: "var(--primary-color)"
            },
            ".demo-row": {
              display: "flex",
              flexWrap: "wrap",
              gap: "16px",
              alignItems: "center"
            }
          };
          return /* @__PURE__ */ jsx("div", { css: css2, children: [
            /* @__PURE__ */ jsx("section", { children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: [
                "Controlled by Panel (Size: ",
                args.size,
                ", Shape: ",
                args.shape,
                ")"
              ] }),
              /* @__PURE__ */ jsx("div", { class: "demo-row", children: [
                /* @__PURE__ */ jsx(Avatar, { size: args.size, shape: args.shape, src: "https://i.pravatar.cc/150?u=99", online: true }),
                /* @__PURE__ */ jsx(Avatar, { size: args.size, shape: args.shape, initials: "AD" })
              ] })
            ] }),
            /* @__PURE__ */ jsx("section", { children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Sizes (Static)" }),
              /* @__PURE__ */ jsx("div", { class: "demo-row", children: [
                /* @__PURE__ */ jsx(Avatar, { size: "xs", initials: "XS" }),
                /* @__PURE__ */ jsx(Avatar, { size: "sm", initials: "SM" }),
                /* @__PURE__ */ jsx(Avatar, { size: "md", initials: "MD" }),
                /* @__PURE__ */ jsx(Avatar, { size: "lg", initials: "LG" }),
                /* @__PURE__ */ jsx(Avatar, { size: "xl", initials: "XL" })
              ] })
            ] }),
            /* @__PURE__ */ jsx("section", { children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Shapes (Static)" }),
              /* @__PURE__ */ jsx("div", { class: "demo-row", children: [
                /* @__PURE__ */ jsx(Avatar, { shape: "circle", initials: "C" }),
                /* @__PURE__ */ jsx(Avatar, { shape: "rounded", initials: "R" }),
                /* @__PURE__ */ jsx(Avatar, { shape: "square", initials: "S" })
              ] })
            ] }),
            /* @__PURE__ */ jsx("section", { children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Status Indicators" }),
              /* @__PURE__ */ jsx("div", { class: "demo-row", children: [
                /* @__PURE__ */ jsx(Avatar, { size: "md", src: "https://i.pravatar.cc/150?u=3", status: "online" }),
                /* @__PURE__ */ jsx(Avatar, { size: "md", src: "https://i.pravatar.cc/150?u=4", status: "away" }),
                /* @__PURE__ */ jsx(Avatar, { size: "md", src: "https://i.pravatar.cc/150?u=5", status: "busy" }),
                /* @__PURE__ */ jsx(Avatar, { size: "md", src: "https://i.pravatar.cc/150?u=6", status: "offline" })
              ] })
            ] }),
            /* @__PURE__ */ jsx("section", { children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: [
                "Avatar Group (maxCount: ",
                args.maxCount,
                ", size: ",
                args.size,
                ")"
              ] }),
              /* @__PURE__ */ jsx("div", { class: "demo-row", children: /* @__PURE__ */ jsx(AvatarGroup, { maxCount: args.maxCount, size: args.size, children: [
                /* @__PURE__ */ jsx(Avatar, { src: "https://i.pravatar.cc/150?u=7" }),
                /* @__PURE__ */ jsx(Avatar, { src: "https://i.pravatar.cc/150?u=8" }),
                /* @__PURE__ */ jsx(Avatar, { src: "https://i.pravatar.cc/150?u=9" }),
                /* @__PURE__ */ jsx(Avatar, { src: "https://i.pravatar.cc/150?u=10" }),
                /* @__PURE__ */ jsx(Avatar, { src: "https://i.pravatar.cc/150?u=11" }),
                /* @__PURE__ */ jsx(Avatar, { src: "https://i.pravatar.cc/150?u=12" })
              ] }) })
            ] })
          ] });
        },
        code: `import { Avatar, AvatarGroup } from 'lupine.components/component-pool';

// Standalone
<Avatar size="md" shape="circle" src="..." status="online" />
<Avatar size="lg" initials="AD" />

// Group
<AvatarGroup maxCount={3}>
  <Avatar src="..." />
  <Avatar src="..." />
  <Avatar src="..." />
  <Avatar src="..." />
</AvatarGroup>
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/avatar/index.ts
  var init_avatar2 = __esm({
    "node_modules/lupine.components/src/component-pool/avatar/index.ts"() {
      init_avatar();
      init_avatar_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/card/card.tsx
  var cardCss, Card;
  var init_card = __esm({
    "node_modules/lupine.components/src/component-pool/card/card.tsx"() {
      init_src();
      init_src2();
      init_jsx_runtime();
      cardCss = {
        display: "flex",
        flexDirection: "column",
        backgroundColor: "var(--primary-bg-color, #fff)",
        border: "1px solid var(--secondary-border-color, #eee)",
        borderRadius: "var(--border-radius-m, 8px)",
        overflow: "hidden",
        transition: "all 0.3s ease",
        color: "var(--primary-color)",
        textDecoration: "none",
        width: "100%",
        boxSizing: "border-box",
        "&.hoverable:hover": {
          boxShadow: "var(--card-box-shadow, 0 4px 12px rgba(0,0,0,0.1))",
          transform: "translateY(-4px)",
          borderColor: "var(--primary-border-color, #ddd)"
        },
        // Layouts
        "&.horizontal": {
          flexDirection: "row"
        },
        // Body content area
        ".&-body": {
          display: "flex",
          flexDirection: "column",
          padding: "var(--space-m, 16px)",
          flex: 1,
          gap: "4px"
        },
        ".&-cover": {
          width: "100%",
          position: "relative",
          img: {
            width: "100%",
            height: "100%",
            objectFit: "cover",
            display: "block"
          }
        },
        "&.horizontal .&-cover": {
          width: "120px",
          height: "auto",
          flexShrink: 0
        },
        ".&-header": {
          display: "flex",
          alignItems: "center",
          justifyContent: "space-between",
          gap: "12px",
          width: "100%"
        },
        ".&-title": {
          fontSize: "16px",
          fontWeight: "600",
          margin: 0,
          color: "var(--primary-color)"
        },
        ".&-description": {
          fontSize: "14px",
          color: "var(--secondary-color, #666)",
          margin: 0,
          lineHeight: "1.5"
        },
        ".&-avatar": {
          flexShrink: 0
        },
        ".&-footer": {
          padding: "var(--space-m, 16px)",
          borderTop: "1px solid var(--secondary-border-color, #eee)",
          display: "flex",
          alignItems: "center",
          gap: "8px"
        },
        ".&-extra": {
          marginLeft: "auto"
        },
        // Mobile responsiveness
        [MediaQueryRange.MobileBelow]: {
          "&.horizontal": {
            flexDirection: "column",
            ".&-cover": {
              width: "100%",
              height: "180px"
            }
          }
        }
      };
      Card = (props) => {
        const globalCssId = getGlobalStylesId(cardCss);
        bindGlobalStyle(globalCssId, cardCss);
        const ref = {
          globalCssId
        };
        const isHorizontal = props.horizontal ? "horizontal" : "";
        const isHoverable = props.hoverable ? "hoverable" : "";
        return /* @__PURE__ */ jsx("div", { class: ["&-container", isHorizontal, isHoverable, props.class].join(" ").trim(), ref, css: props.style, children: [
          props.cover && /* @__PURE__ */ jsx("div", { class: "&-cover", children: props.cover }),
          /* @__PURE__ */ jsx("div", { class: "&-body", children: [
            (props.avatar || props.title || props.extra) && /* @__PURE__ */ jsx("div", { class: "&-header", children: [
              props.avatar && /* @__PURE__ */ jsx("div", { class: "&-avatar", children: props.avatar }),
              /* @__PURE__ */ jsx("div", { style: { flex: 1 }, children: props.title && /* @__PURE__ */ jsx("div", { class: "&-title", children: props.title }) }),
              props.extra && /* @__PURE__ */ jsx("div", { class: "&-extra", children: props.extra })
            ] }),
            props.description && /* @__PURE__ */ jsx("div", { class: "&-description", children: props.description }),
            props.children
          ] }),
          props.footer && /* @__PURE__ */ jsx("div", { class: "&-footer", children: props.footer })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/card/card-demo.tsx
  var cardDemo;
  var init_card_demo = __esm({
    "node_modules/lupine.components/src/component-pool/card/card-demo.tsx"() {
      init_card();
      init_avatar2();
      init_src2();
      init_jsx_runtime();
      cardDemo = {
        id: "cardDemo",
        text: "Card",
        args: {
          hoverable: true
        },
        argTypes: {
          hoverable: {
            control: "boolean",
            description: "Whether the card shows a hover effect"
          }
        },
        render: (args) => {
          const css2 = {
            display: "flex",
            flexDirection: "column",
            gap: "32px",
            padding: "24px",
            ".section-title": {
              fontSize: "20px",
              fontWeight: "bold",
              marginBottom: "16px",
              color: "var(--primary-color)",
              borderBottom: "2px solid var(--secondary-border-color)",
              paddingBottom: "8px"
            },
            ".card-grid": {
              display: "grid",
              gap: "16px",
              gridTemplateColumns: "repeat(4, 1fr)",
              [MediaQueryRange.DesktopBelow]: {
                gridTemplateColumns: "repeat(3, 1fr)"
              },
              [MediaQueryRange.MobileBelow]: {
                gridTemplateColumns: "repeat(2, 1fr)"
              },
              [MediaQueryRange.ExtraSmallBelow]: {
                gridTemplateColumns: "1fr"
              }
            },
            ".demo-row": {
              display: "flex",
              flexWrap: "wrap",
              gap: "24px"
            }
          };
          const productItems = [
            { id: 1, title: "Premium Violin Stand", price: "$49.99", img: "https://picsum.photos/seed/v1/400/300" },
            { id: 2, title: "Professional Bow", price: "$129.00", img: "https://picsum.photos/seed/v2/400/500" },
            { id: 3, title: "Silk String Set", price: "$25.00", img: "https://picsum.photos/seed/v3/400/300" },
            { id: 4, title: "Rosin High Grade", price: "$12.50", img: "https://picsum.photos/seed/v4/400/300" },
            { id: 5, title: "Violin Case Carbon", price: "$299.00", img: "https://picsum.photos/seed/v5/400/200" },
            { id: 6, title: "Shoulder Rest", price: "$35.00", img: "https://picsum.photos/seed/v6/400/300" }
          ];
          return /* @__PURE__ */ jsx("div", { css: css2, children: [
            /* @__PURE__ */ jsx("section", { children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Responsive Product Grid (4 \u2192 3 \u2192 2 \u2192 1)" }),
              /* @__PURE__ */ jsx("div", { class: "card-grid", children: productItems.map((item) => /* @__PURE__ */ jsx(
                Card,
                {
                  hoverable: args.hoverable,
                  cover: /* @__PURE__ */ jsx("img", { src: item.img, alt: item.title }),
                  title: item.title,
                  description: "High-quality accessory for professional musicians.",
                  footer: /* @__PURE__ */ jsx(
                    "div",
                    {
                      style: { display: "flex", justifyContent: "space-between", width: "100%", alignItems: "center" },
                      children: [
                        /* @__PURE__ */ jsx("span", { style: { fontWeight: "bold", color: "var(--success-color, #2ecc71)" }, children: item.price }),
                        /* @__PURE__ */ jsx(
                          "button",
                          {
                            style: {
                              padding: "4px 12px",
                              borderRadius: "4px",
                              border: "none",
                              backgroundColor: "var(--primary-color)",
                              color: "#fff",
                              cursor: "pointer"
                            },
                            children: "Buy"
                          }
                        )
                      ]
                    }
                  )
                }
              )) })
            ] }),
            /* @__PURE__ */ jsx("section", { children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Profile Layouts" }),
              /* @__PURE__ */ jsx("div", { class: "demo-row", children: [
                /* @__PURE__ */ jsx(
                  Card,
                  {
                    style: { width: "300px" },
                    hoverable: args.hoverable,
                    avatar: /* @__PURE__ */ jsx(Avatar, { src: "https://picsum.photos/seed/p1/150", size: "lg", online: true }),
                    title: "John Doe",
                    description: "Senior Violin Instructor at Lupine Academy. 15+ years of experience in classical music.",
                    extra: /* @__PURE__ */ jsx(
                      "button",
                      {
                        style: { background: "none", border: "none", color: "var(--primary-color)", cursor: "pointer" },
                        children: "Follow"
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsx(
                  Card,
                  {
                    style: { width: "300px" },
                    hoverable: args.hoverable,
                    horizontal: true,
                    avatar: /* @__PURE__ */ jsx(Avatar, { src: "https://picsum.photos/seed/p2/150", size: "md", status: "away" }),
                    title: "Jane Smith",
                    description: "Orchestra Conductor"
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsx("section", { children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Horizontal Product (Responsive)" }),
              /* @__PURE__ */ jsx(
                Card,
                {
                  hoverable: args.hoverable,
                  horizontal: true,
                  cover: /* @__PURE__ */ jsx("img", { src: "https://picsum.photos/seed/b1/400/300" }),
                  title: "Lupine Master Collection Book",
                  description: "The ultimate guide to mastering Lupine.js framework. Includes deep dives into reactive state, SSR, and component design patterns. Essential for modern web developers.",
                  footer: /* @__PURE__ */ jsx("div", { style: { gap: "12px", display: "flex" }, children: [
                    /* @__PURE__ */ jsx(
                      "button",
                      {
                        style: {
                          padding: "8px 16px",
                          borderRadius: "6px",
                          border: "1px solid var(--primary-color)",
                          background: "none"
                        },
                        children: "Preview"
                      }
                    ),
                    /* @__PURE__ */ jsx(
                      "button",
                      {
                        style: {
                          padding: "8px 16px",
                          borderRadius: "6px",
                          border: "none",
                          background: "var(--primary-color)",
                          color: "#fff"
                        },
                        children: "Add to Cart"
                      }
                    )
                  ] })
                }
              )
            ] })
          ] });
        },
        code: `import { Card } from 'lupine.components/component-pool';

<Card 
  title="Card Title" 
  description="Card description goes here."
  cover={<img src="..." />}
  footer={<button>Action</button>}
/>

<Card horizontal title="Row Item" avatar={<Avatar src="..." />} />
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/card/index.ts
  var init_card2 = __esm({
    "node_modules/lupine.components/src/component-pool/card/index.ts"() {
      init_card();
      init_card_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/carousel/carousel.tsx
  var carouselCss, Carousel;
  var init_carousel = __esm({
    "node_modules/lupine.components/src/component-pool/carousel/carousel.tsx"() {
      init_src();
      init_jsx_runtime();
      carouselCss = {
        position: "relative",
        width: "100%",
        overflow: "hidden",
        display: "flex",
        flexDirection: "column",
        borderRadius: "12px",
        boxShadow: "var(--cover-box-shadow-around)",
        ".&-drawer": {
          display: "flex",
          overflowX: "auto",
          width: "100%",
          scrollSnapType: "x mandatory",
          scrollBehavior: "smooth",
          gap: "12px",
          paddingBottom: "10px",
          WebkitOverflowScrolling: "touch",
          "&::-webkit-scrollbar": {
            display: "none"
          },
          scrollbarWidth: "none"
        },
        ".&-item": {
          minWidth: "100%",
          flexShrink: 0,
          scrollSnapAlign: "start"
        },
        ".&-dot-box": {
          display: "flex",
          justifyContent: "center",
          gap: "8px",
          padding: "16px 0",
          backgroundColor: "var(--primary-bg-color, #6d92b1ff)"
        },
        ".&-dot": {
          width: "8px",
          height: "8px",
          borderRadius: "50%",
          backgroundColor: "var(--secondary-color, #ccc)",
          cursor: "pointer",
          transition: "all 0.3s ease",
          "&.active": {
            backgroundColor: "var(--primary-color, #0a74c9)",
            transform: "scale(1.2)"
          }
        },
        ".&-arrow": {
          position: "absolute",
          top: "calc(50% - 20px)",
          // Offset by half dots height if dots are shown
          transform: "translateY(-50%)",
          width: "40px",
          height: "40px",
          borderRadius: "50%",
          backgroundColor: "rgba(255, 255, 255, 0.9)",
          border: "1px solid var(--secondary-border-color, #eee)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          cursor: "pointer",
          zIndex: 10,
          transition: "all 0.3s ease",
          boxShadow: "0 4px 12px rgba(0,0,0,0.15)",
          "&:hover": {
            backgroundColor: "#fff",
            transform: "translateY(-50%) scale(1.1)"
          },
          "&.disabled": {
            opacity: 0.2,
            cursor: "not-allowed",
            boxShadow: "none"
          },
          span: {
            fontSize: "20px",
            fontWeight: "bold",
            marginTop: "-2px",
            fontFamily: "monospace"
          }
        },
        ".&-arrow-left": { left: "16px" },
        ".&-arrow-right": { right: "16px" }
      };
      Carousel = (props) => {
        const children = props.children || [];
        const count = children.length;
        const interval = props.interval || 4e3;
        const globalCssId = getGlobalStylesId(carouselCss);
        bindGlobalStyle(globalCssId, carouselCss);
        let currentIndex = 0;
        let autoplayTimer = null;
        const updateIndicators = (index) => {
          currentIndex = index;
          const dots = ref.$all(".&-dot");
          dots.forEach((dot, i) => {
            dot.classList.toggle("active", i === index);
          });
          const leftArrow = ref.$(".&-arrow-left");
          const rightArrow = ref.$(".&-arrow-right");
          if (leftArrow) leftArrow.classList.toggle("disabled", index === 0);
          if (rightArrow) rightArrow.classList.toggle("disabled", index === count - 1);
        };
        const scrollTo = (index) => {
          const drawer = ref.$(".&-drawer");
          if (!drawer) return;
          const items = ref.$all(".&-item");
          if (items[index]) {
            drawer.scrollTo({
              left: items[index].offsetLeft,
              behavior: "smooth"
            });
          }
          updateIndicators(index);
        };
        const next = () => {
          if (currentIndex >= count - 1) {
            if (props.autoplay) scrollTo(0);
            return;
          }
          scrollTo(currentIndex + 1);
        };
        const prev = () => {
          if (currentIndex <= 0) return;
          scrollTo(currentIndex - 1);
        };
        const startAutoplay = () => {
          if (props.autoplay) {
            stopAutoplay();
            autoplayTimer = setInterval(next, interval);
          }
        };
        const stopAutoplay = () => {
          if (autoplayTimer) {
            clearInterval(autoplayTimer);
            autoplayTimer = null;
          }
        };
        const handleScroll = () => {
          const drawer = ref.$(".&-drawer");
          if (!drawer) return;
          const width = drawer.clientWidth;
          const index = Math.round(drawer.scrollLeft / width);
          if (index !== currentIndex && index >= 0 && index < count) {
            updateIndicators(index);
          }
        };
        const ref = {
          globalCssId,
          onLoad: async () => {
            updateIndicators(0);
            startAutoplay();
          },
          onUnload: async () => {
            stopAutoplay();
          }
        };
        return /* @__PURE__ */ jsx(
          "div",
          {
            class: ["&-container", props.class].join(" ").trim(),
            css: props.style,
            ref,
            onMouseEnter: stopAutoplay,
            onMouseLeave: startAutoplay,
            children: [
              /* @__PURE__ */ jsx("div", { class: "&-drawer", onScroll: handleScroll, children: children.map((child) => /* @__PURE__ */ jsx("div", { class: "&-item", children: child })) }),
              props.showArrows && count > 1 && /* @__PURE__ */ jsx(Fragment, { children: [
                /* @__PURE__ */ jsx("div", { class: "&-arrow &-arrow-left", onClick: prev, children: /* @__PURE__ */ jsx("span", { children: "<" }) }),
                /* @__PURE__ */ jsx("div", { class: "&-arrow &-arrow-right", onClick: next, children: /* @__PURE__ */ jsx("span", { children: ">" }) })
              ] }),
              props.showDots && count > 1 && /* @__PURE__ */ jsx("div", { class: "&-dot-box", children: children.map((_, i) => /* @__PURE__ */ jsx("div", { class: "&-dot", onClick: () => scrollTo(i) })) })
            ]
          }
        );
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/carousel/carousel-demo.tsx
  var carouselDemo;
  var init_carousel_demo = __esm({
    "node_modules/lupine.components/src/component-pool/carousel/carousel-demo.tsx"() {
      init_carousel();
      init_card2();
      init_avatar2();
      init_jsx_runtime();
      carouselDemo = {
        id: "carouselDemo",
        text: "Carousel",
        args: {
          showDots: true,
          showArrows: true,
          autoplay: false,
          interval: 4e3
        },
        argTypes: {
          showDots: { control: "boolean" },
          showArrows: { control: "boolean" },
          autoplay: { control: "boolean" },
          interval: { control: "number" }
        },
        render: (args) => {
          const css2 = {
            display: "flex",
            flexDirection: "column",
            gap: "48px",
            padding: "24px",
            ".section-title": {
              fontSize: "22px",
              fontWeight: "bold",
              marginBottom: "20px",
              color: "var(--primary-color)",
              borderBottom: "2px solid var(--secondary-border-color)",
              paddingBottom: "10px"
            },
            ".carousel-container": {
              maxWidth: "800px",
              margin: "0 auto"
              // backgroundColor: '#fff',
            }
          };
          const productCards = [
            /* @__PURE__ */ jsx(
              Card,
              {
                cover: /* @__PURE__ */ jsx("img", { src: "https://picsum.photos/seed/c1/800/400", style: { height: "300px", objectFit: "cover" } }),
                title: "Professional Violin",
                description: "Handcrafted in Italy using aged spruce and maple. Exceptional tone quality for soloists.",
                footer: /* @__PURE__ */ jsx(
                  "button",
                  {
                    style: {
                      width: "100%",
                      padding: "12px",
                      backgroundColor: "var(--secondary-bg-color)",
                      color: "var(--secondary-color)",
                      border: "none",
                      borderRadius: "6px"
                    },
                    children: "View Detail"
                  }
                )
              }
            ),
            /* @__PURE__ */ jsx(
              Card,
              {
                cover: /* @__PURE__ */ jsx("img", { src: "https://picsum.photos/seed/c2/800/400", style: { height: "300px", objectFit: "cover" } }),
                title: "Modern Cello",
                description: "Deep, resonant sound with excellent projection. Perfect for advanced students and conservatory levels.",
                footer: /* @__PURE__ */ jsx(
                  "button",
                  {
                    style: {
                      width: "100%",
                      padding: "12px",
                      backgroundColor: "var(--secondary-bg-color)",
                      color: "var(--secondary-color)",
                      border: "none",
                      borderRadius: "6px"
                    },
                    children: "View Detail"
                  }
                )
              }
            ),
            /* @__PURE__ */ jsx(
              Card,
              {
                cover: /* @__PURE__ */ jsx("img", { src: "https://picsum.photos/seed/c3/800/400", style: { height: "300px", objectFit: "cover" } }),
                title: "Premium Bow Collection",
                description: "Graphite and Pernambuco sticks carefully balanced for professional requirements.",
                footer: /* @__PURE__ */ jsx(
                  "button",
                  {
                    style: {
                      width: "100%",
                      padding: "12px",
                      backgroundColor: "var(--secondary-bg-color)",
                      color: "var(--secondary-color)",
                      border: "none",
                      borderRadius: "6px"
                    },
                    children: "View Detail"
                  }
                )
              }
            )
          ];
          const profileCards = [
            /* @__PURE__ */ jsx(
              Card,
              {
                horizontal: true,
                avatar: /* @__PURE__ */ jsx(Avatar, { src: "https://picsum.photos/seed/p1/200", size: "xl", online: true }),
                title: "Master Wang",
                description: "Famous violinist with 40 years of teaching experience. Specialized in Paganini Caprices."
              }
            ),
            /* @__PURE__ */ jsx(
              Card,
              {
                horizontal: true,
                avatar: /* @__PURE__ */ jsx(Avatar, { src: "https://picsum.photos/seed/p2/200", size: "xl", status: "busy" }),
                title: "Dr. Emily Chen",
                description: "Orchestral director and chamber music expert. PhD from Juilliard School."
              }
            ),
            /* @__PURE__ */ jsx(
              Card,
              {
                horizontal: true,
                avatar: /* @__PURE__ */ jsx(Avatar, { src: "https://picsum.photos/seed/p3/200", size: "xl", online: true }),
                title: "Sarkis Baghdassarian",
                description: "Concertmaster of the Lupine Symphony. Renowned for rich vibrato and technical precision."
              }
            )
          ];
          return /* @__PURE__ */ jsx("div", { css: css2, children: [
            /* @__PURE__ */ jsx("section", { children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Product Showreel (Arrows + Dots)" }),
              /* @__PURE__ */ jsx("div", { class: "carousel-container", children: /* @__PURE__ */ jsx(Carousel, { ...args, children: productCards }) })
            ] }),
            /* @__PURE__ */ jsx("section", { children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Instructor Highlights (Dots Only)" }),
              /* @__PURE__ */ jsx("div", { class: "carousel-container", children: /* @__PURE__ */ jsx(Carousel, { showDots: true, showArrows: false, autoplay: args.autoplay, children: profileCards }) })
            ] }),
            /* @__PURE__ */ jsx("section", { children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Mixed Content Carousel" }),
              /* @__PURE__ */ jsx("div", { class: "carousel-container", children: /* @__PURE__ */ jsx(Carousel, { showDots: false, showArrows: true, autoplay: args.autoplay, children: [
                /* @__PURE__ */ jsx(
                  "div",
                  {
                    style: {
                      height: "300px",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      backgroundColor: "#f0f4f8",
                      color: "#2c3e50",
                      fontSize: "24px"
                    },
                    children: "Custom HTML Slide 1"
                  }
                ),
                /* @__PURE__ */ jsx(
                  Card,
                  {
                    title: "Integrated Card Slide",
                    description: "This card is directly integrated as a slide in the carousel.",
                    cover: /* @__PURE__ */ jsx("img", { src: "https://picsum.photos/seed/m1/800/400", style: { height: "200px", objectFit: "cover" } })
                  }
                ),
                /* @__PURE__ */ jsx(
                  "div",
                  {
                    style: {
                      height: "300px",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      backgroundColor: "#e8f5e9",
                      color: "#2e7d32",
                      fontSize: "24px"
                    },
                    children: "Custom HTML Slide 3"
                  }
                )
              ] }) })
            ] })
          ] });
        },
        code: `import { Carousel } from 'lupine.components/component-pool';

<Carousel showDots={true} showArrows={true} autoplay={true} interval={4000}>
  <div class="slide">Slide 1</div>
  <div class="slide">Slide 2</div>
</Carousel>
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/carousel/index.ts
  var init_carousel2 = __esm({
    "node_modules/lupine.components/src/component-pool/carousel/index.ts"() {
      init_carousel();
      init_carousel_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/cascader/cascader.tsx
  var cascaderCss, Cascader;
  var init_cascader = __esm({
    "node_modules/lupine.components/src/component-pool/cascader/cascader.tsx"() {
      init_src();
      init_jsx_runtime();
      cascaderCss = {
        width: "100%",
        borderBottom: "1px solid var(--secondary-border-color, #eee)",
        backgroundColor: "var(--primary-bg-color, #fff)",
        transition: "all 0.3s ease",
        overflow: "hidden",
        ".&-header": {
          display: "flex",
          alignItems: "center",
          justifyContent: "space-between",
          padding: "12px 16px",
          cursor: "pointer",
          userSelect: "none",
          "&:hover": {
            backgroundColor: "var(--secondary-bg-color, #f9f9f9)"
          }
        },
        ".&-title": {
          fontSize: "16px",
          fontWeight: "600",
          color: "var(--primary-color)"
        },
        ".&-desc-wrapper": {
          display: "flex",
          alignItems: "flex-start",
          padding: "12px 16px",
          gap: "8px"
        },
        ".&-description": {
          flex: 1,
          fontSize: "14px",
          color: "var(--secondary-color, #666)",
          lineHeight: "1.6"
        },
        "&:not(.open) .&-description": {
          display: "-webkit-box",
          "-webkit-line-clamp": "2",
          "-webkit-box-orient": "vertical",
          overflow: "hidden"
        },
        ".&-content": {
          padding: "0 16px 16px 16px",
          fontSize: "14px",
          color: "var(--primary-color)",
          display: "none"
        },
        "&.open .&-content": {
          display: "block"
        },
        ".&-extra-content": {
          display: "none",
          marginTop: "8px"
        },
        "&.open .&-extra-content": {
          display: "block"
        },
        ".&-btn, .&-arrow": {
          marginLeft: "auto",
          cursor: "pointer",
          color: "var(--secondary-color, #999)",
          width: "24px",
          height: "24px",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          transition: "all 0.3s ease",
          userSelect: "none",
          // Circular styling (conditional via class)
          "&.circle": {
            borderRadius: "50%",
            border: "1px solid var(--secondary-border-color, #eee)",
            backgroundColor: "var(--secondary-bg-color, #f9f9f9)"
          },
          "&:hover": {
            color: "var(--primary-color)",
            "&.circle": {
              backgroundColor: "var(--secondary-border-color)"
            }
          }
        },
        ".&-btn span, .&-arrow span": {
          fontSize: "20px",
          fontWeight: "bold",
          fontFamily: "monospace",
          marginTop: "-2px",
          display: "inline-block",
          transition: "transform 0.3s ease",
          lineHeight: "1",
          transform: "rotate(0deg)"
        },
        // Merged rotation logic: Right (0deg) -> Down (90deg)
        "&.open .&-arrow span, &.open .&-btn span": {
          transform: "rotate(90deg)"
        }
      };
      Cascader = (props) => {
        const type = props.type || "title";
        const initialState = props.defaultOpen || false;
        const showCircle = props.showCircle || false;
        const globalCssId = getGlobalStylesId(cascaderCss);
        bindGlobalStyle(globalCssId, cascaderCss);
        const toggle = () => {
          const el = ref.current;
          if (!el) return;
          const nextState = !el.classList.contains("open");
          if (nextState && props.group) {
            const others = document.querySelectorAll(`[data-cascader-group="${props.group}"]`);
            others.forEach((other2) => {
              if (other2 !== el && other2._lj) {
                updateUI(other2._lj.ref, false);
              }
            });
          }
          updateUI(ref, nextState);
        };
        const updateUI = (targetRef, open) => {
          const el = targetRef.current;
          if (!el || open === el.classList.contains("open")) return;
          el.classList.toggle("open", open);
        };
        const ref = {
          globalCssId
        };
        const toggleClass = showCircle ? "circle" : "";
        if (type === "title") {
          return /* @__PURE__ */ jsx(
            "div",
            {
              class: ["&-container", props.class, initialState ? "open" : ""].join(" ").trim(),
              ref,
              css: props.style,
              "data-cascader-group": props.group,
              children: [
                /* @__PURE__ */ jsx("div", { class: "&-header", onClick: toggle, children: [
                  /* @__PURE__ */ jsx("div", { class: "&-title", children: props.title }),
                  /* @__PURE__ */ jsx("div", { class: ["&-arrow", toggleClass].join(" ").trim(), children: /* @__PURE__ */ jsx("span", { children: ">" }) })
                ] }),
                /* @__PURE__ */ jsx("div", { class: "&-content", children: [
                  props.description && /* @__PURE__ */ jsx("div", { style: { marginBottom: "12px", color: "var(--secondary-color)" }, children: props.description }),
                  props.children
                ] })
              ]
            }
          );
        }
        return /* @__PURE__ */ jsx(
          "div",
          {
            class: ["&-container", props.class, initialState ? "open" : ""].join(" ").trim(),
            ref,
            css: props.style,
            "data-cascader-group": props.group,
            children: /* @__PURE__ */ jsx("div", { class: "&-desc-wrapper", children: [
              /* @__PURE__ */ jsx("div", { class: "&-description", children: [
                props.description,
                /* @__PURE__ */ jsx("div", { class: "&-extra-content", children: props.children })
              ] }),
              /* @__PURE__ */ jsx("div", { class: ["&-btn", toggleClass].join(" ").trim(), onClick: toggle, children: /* @__PURE__ */ jsx("span", { children: ">" }) })
            ] })
          }
        );
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/cascader/cascader-demo.tsx
  var cascaderDemo;
  var init_cascader_demo = __esm({
    "node_modules/lupine.components/src/component-pool/cascader/cascader-demo.tsx"() {
      init_cascader();
      init_jsx_runtime();
      cascaderDemo = {
        id: "cascaderDemo",
        text: "Cascader",
        args: {
          type: "title",
          showCircle: false
        },
        argTypes: {
          type: {
            control: "select",
            options: ["title", "ellipsis"]
          },
          showCircle: {
            control: "boolean"
          }
        },
        render: (args) => {
          const css2 = {
            display: "flex",
            flexDirection: "column",
            gap: "32px",
            padding: "32px",
            maxWidth: "600px",
            margin: "0 auto",
            ".demo-section": {
              border: "1px solid var(--secondary-border-color)",
              borderRadius: "8px",
              overflow: "hidden",
              backgroundColor: "var(--primary-bg-color)"
            },
            ".section-label": {
              padding: "16px",
              backgroundColor: "var(--secondary-bg-color)",
              borderBottom: "1px solid var(--secondary-border-color)",
              fontSize: "14px",
              fontWeight: "bold",
              color: "var(--secondary-color)"
            }
          };
          return /* @__PURE__ */ jsx("div", { css: css2, children: [
            /* @__PURE__ */ jsx("section", { class: "demo-section", children: [
              /* @__PURE__ */ jsx("div", { class: "section-label", children: "Interactive Demo" }),
              /* @__PURE__ */ jsx("div", { style: { padding: args.type === "ellipsis" ? "12px" : "0" }, children: /* @__PURE__ */ jsx(
                Cascader,
                {
                  type: args.type,
                  showCircle: args.showCircle,
                  title: "Interactive Cascader",
                  description: "Change the controls on the right to see this component update in real-time.",
                  defaultOpen: true,
                  children: /* @__PURE__ */ jsx("div", { style: { padding: "10px", backgroundColor: "var(--secondary-bg-color)", borderRadius: "4px" }, children: [
                    /* @__PURE__ */ jsx("p", { children: "This section is dynamic!" }),
                    /* @__PURE__ */ jsx("p", { children: [
                      "Current Type: ",
                      /* @__PURE__ */ jsx("strong", { children: args.type })
                    ] }),
                    /* @__PURE__ */ jsx("p", { children: [
                      "Show Circle: ",
                      /* @__PURE__ */ jsx("strong", { children: args.showCircle ? "Yes" : "No" })
                    ] })
                  ] })
                },
                `${args.type}-${args.showCircle}`
              ) })
            ] }),
            /* @__PURE__ */ jsx("section", { class: "demo-section", children: [
              /* @__PURE__ */ jsx("div", { class: "section-label", children: "Accordion Group (Mixed Styles)" }),
              /* @__PURE__ */ jsx(
                Cascader,
                {
                  title: "Account Settings",
                  description: "Manage your profile and security",
                  group: "settings",
                  showCircle: args.showCircle,
                  defaultOpen: true,
                  children: /* @__PURE__ */ jsx("p", { children: "Username: Admin" })
                },
                `s1-${args.showCircle}`
              ),
              /* @__PURE__ */ jsx(
                Cascader,
                {
                  title: "Privacy Policy",
                  description: "Learn how we handle your data",
                  group: "settings",
                  showCircle: args.showCircle,
                  children: /* @__PURE__ */ jsx("p", { children: "Your privacy is important to us." })
                },
                `s2-${args.showCircle}`
              )
            ] }),
            /* @__PURE__ */ jsx("section", { class: "demo-section", children: [
              /* @__PURE__ */ jsx("div", { class: "section-label", children: "Ellipsis Mode (Inline Expand)" }),
              /* @__PURE__ */ jsx("div", { style: { padding: "12px" }, children: /* @__PURE__ */ jsx(
                Cascader,
                {
                  type: "ellipsis",
                  showCircle: args.showCircle,
                  description: "Lupine.js is a lightweight, high-performance web framework designed for modern agent-centric applications. It provides a rich set of UI components and a robust state management system that works seamlessly across different environments. By leveraging reactive principles and a clean component model, Lupine.js allows developers to build complex user interfaces with minimal boilerplate code.",
                  children: /* @__PURE__ */ jsx("p", { children: "Additional details for the ellipsis item." })
                },
                `e1-${args.showCircle}`
              ) })
            ] })
          ] });
        },
        code: `import { Cascader } from 'lupine.components/component-pool';

<Cascader 
  title="Account Settings" 
  description="Manage your profile"
  group="settings"
>
  <p>Content goes here...</p>
</Cascader>

<Cascader 
  type="ellipsis"
  description="Lupine.js is a lightweight, high-performance web framework..."
>
  <p>Expanded content</p>
</Cascader>
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/cascader/index.ts
  var init_cascader2 = __esm({
    "node_modules/lupine.components/src/component-pool/cascader/index.ts"() {
      init_cascader();
      init_cascader_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/picker-helper.tsx
  function calcPreferredPosition(rect, popupWidth, popupHeight, offset = 8) {
    const spaceTop = rect.top - offset;
    const spaceBottom = window.innerHeight - rect.bottom - offset;
    const spaceLeft = rect.left - offset;
    const spaceRight = window.innerWidth - rect.right - offset;
    if (spaceTop >= popupHeight) return "top";
    if (spaceBottom >= popupHeight) return "bottom";
    if (spaceRight >= popupWidth) return "right";
    if (spaceLeft >= popupWidth) return "left";
    const dirs = [
      ["top", spaceTop],
      ["bottom", spaceBottom],
      ["right", spaceRight],
      ["left", spaceLeft]
    ];
    return dirs.reduce((a, b) => b[1] > a[1] ? b : a)[0];
  }
  var pickerContainerCss, PickerHelper;
  var init_picker_helper = __esm({
    "node_modules/lupine.components/src/component-pool/picker-helper.tsx"() {
      init_src();
      init_jsx_runtime();
      pickerContainerCss = {
        position: "fixed",
        zIndex: "var(--layer-picker, 3000)",
        backgroundColor: "var(--primary-bg-color, #fff)",
        boxShadow: "var(--cover-box-shadow, 0 4px 12px rgba(0,0,0,0.15))",
        borderRadius: "var(--border-radius-m, 8px)",
        border: "1px solid var(--secondary-border-color, #eee)",
        opacity: 0,
        transition: "opacity 0.2s ease, transform 0.2s ease",
        transform: "translateY(10px)",
        overflow: "hidden",
        visibility: "hidden",
        pointerEvents: "none",
        outline: "none",
        "&.open": {
          visibility: "visible",
          pointerEvents: "auto",
          opacity: 1,
          transform: "translateY(0)"
        },
        "&.top": {
          transform: "translateY(-10px)"
        },
        "&.top.open": {
          transform: "translateY(0)"
        }
      };
      PickerHelper = class {
        static host = null;
        static currentRef = null;
        static closeCallback = null;
        static initHost() {
          if (this.host) return;
          this.host = document.createElement("div");
          this.host.className = "lupine-picker-host";
          document.body.appendChild(this.host);
        }
        static async show(target, content, options3 = {}) {
          this.initHost();
          this.closeCallback = options3.onHide || null;
          const ref = {
            onLoad: async () => {
              var _a;
              this.currentRef = ref;
              (_a = options3.onRef) == null ? void 0 : _a.call(options3, ref);
              this.updatePosition(target);
              setTimeout(() => {
                if (ref.current) {
                  ref.current.focus();
                }
              }, 10);
            }
          };
          const onBlur = (e) => {
            const refAtBlur = this.currentRef;
            const relatedTarget = e.relatedTarget;
            setTimeout(() => {
              var _a;
              if (this.currentRef === refAtBlur && ((_a = this.currentRef) == null ? void 0 : _a.current) && !this.currentRef.current.contains(relatedTarget)) {
                this.hide();
              }
            }, 100);
          };
          const component = /* @__PURE__ */ jsx("div", { ref, css: pickerContainerCss, tabIndex: -1, onBlur, children: content });
          await mountInnerComponent(this.host, component);
        }
        static updatePosition(target) {
          var _a;
          const pickerEl = (_a = this.currentRef) == null ? void 0 : _a.current;
          if (!pickerEl) return;
          const rect = target.getBoundingClientRect();
          const pickerWidth = pickerEl.offsetWidth;
          const pickerHeight = pickerEl.offsetHeight;
          let left = rect.left;
          let isTop = false;
          if (rect.bottom + 5 + pickerHeight > window.innerHeight - 10) {
            isTop = true;
          }
          if (isTop) {
            const spaceTop = rect.top;
            const spaceBottom = window.innerHeight - rect.bottom;
            if (spaceBottom > spaceTop) {
              isTop = false;
            }
          }
          if (left + pickerWidth > window.innerWidth - 10) {
            left = window.innerWidth - pickerWidth - 10;
          }
          if (left < 10) left = 10;
          pickerEl.style.left = `${left}px`;
          if (isTop) {
            pickerEl.style.bottom = `${window.innerHeight - rect.top + 5}px`;
            pickerEl.style.top = "auto";
            pickerEl.classList.add("top");
          } else {
            pickerEl.style.top = `${rect.bottom + 5}px`;
            pickerEl.style.bottom = "auto";
            pickerEl.classList.remove("top");
          }
          requestAnimationFrame(() => {
            pickerEl.classList.add("open");
          });
        }
        static hide() {
          var _a;
          if (!((_a = this.currentRef) == null ? void 0 : _a.current)) return;
          const pickerEl = this.currentRef.current;
          pickerEl.classList.remove("open");
          setTimeout(() => {
            if (this.host) {
              this.host.innerHTML = "";
            }
            if (this.closeCallback) {
              this.closeCallback();
              this.closeCallback = null;
            }
            this.currentRef = null;
          }, 200);
        }
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/tooltip/tooltip.tsx
  var tooltipCss, TOOLTIP_INITIALIZED, TooltipHelper, TooltipContent, Tooltip;
  var init_tooltip = __esm({
    "node_modules/lupine.components/src/component-pool/tooltip/tooltip.tsx"() {
      init_src();
      init_picker_helper();
      init_jsx_runtime();
      tooltipCss = {
        position: "fixed",
        zIndex: "var(--layer-tooltip, 2000)",
        pointerEvents: "none",
        opacity: 0,
        transition: "opacity 0.2s ease, transform 0.2s ease",
        transform: "scale(0.95)",
        "&.visible": {
          opacity: 1,
          transform: "scale(1)"
        },
        ".&-box": {
          position: "relative",
          backgroundColor: "var(--tooltip-bg, rgba(0, 0, 0, 0.85))",
          color: "var(--tooltip-color, #fff)",
          padding: "6px 10px",
          borderRadius: "4px",
          fontSize: "13px",
          lineHeight: "1.4",
          whiteSpace: "nowrap",
          boxShadow: "0 2px 8px rgba(0,0,0,0.15)"
        },
        ".&-arrow": {
          position: "absolute",
          width: 0,
          height: 0,
          borderStyle: "solid"
        },
        // Positions
        "&.top .&-arrow": {
          bottom: "-6px",
          left: "50%",
          marginLeft: "-6px",
          borderWidth: "6px 6px 0 6px",
          borderColor: "var(--tooltip-bg, rgba(0, 0, 0, 0.85)) transparent transparent transparent"
        },
        "&.bottom .&-arrow": {
          top: "-6px",
          left: "50%",
          marginLeft: "-6px",
          borderWidth: "0 6px 6px 6px",
          borderColor: "transparent transparent var(--tooltip-bg, rgba(0, 0, 0, 0.85)) transparent"
        },
        "&.left .&-arrow": {
          right: "-6px",
          top: "50%",
          marginTop: "-6px",
          borderWidth: "6px 0 6px 6px",
          borderColor: "transparent transparent transparent var(--tooltip-bg, rgba(0, 0, 0, 0.85))"
        },
        "&.right .&-arrow": {
          left: "-6px",
          top: "50%",
          marginTop: "-6px",
          borderWidth: "6px 6px 6px 0",
          borderColor: "transparent var(--tooltip-bg, rgba(0, 0, 0, 0.85)) transparent transparent"
        }
      };
      TOOLTIP_INITIALIZED = "__tooltip_init";
      TooltipHelper = class {
        static host = null;
        static ref = null;
        static closeTimer = null;
        static initHost() {
          if (this.host) return;
          this.host = document.createElement("div");
          document.body.appendChild(this.host);
        }
        /**
         * Main entry point: Call this on onMouseEnter
         */
        static show(event, content, options3 = {}) {
          const target = event.currentTarget || event.target;
          if (!target) return;
          if (!target[TOOLTIP_INITIALIZED]) {
            target[TOOLTIP_INITIALIZED] = true;
            target.addEventListener("mouseleave", () => this.hide());
            target.addEventListener("click", () => this.hide());
          }
          this.display(target, content, options3);
        }
        /**
         * Internal display logic
         */
        static async display(target, content, options3 = {}) {
          var _a;
          this.initHost();
          if (this.closeTimer) {
            clearTimeout(this.closeTimer);
            this.closeTimer = null;
          }
          const requestedPos = options3.position ?? "auto";
          const isAuto = requestedPos === "auto";
          const showArrow = options3.showArrow ?? true;
          const initialPos = isAuto ? "top" : requestedPos;
          const component = /* @__PURE__ */ jsx(TooltipContent, { content, position: initialPos, showArrow, onRef: (r) => this.ref = r });
          await mountInnerComponent(this.host, component);
          const tooltipEl = (_a = this.ref) == null ? void 0 : _a.current;
          if (!tooltipEl) return;
          const rect = target.getBoundingClientRect();
          const offset = 8;
          const tooltipWidth = tooltipEl.offsetWidth;
          const tooltipHeight = tooltipEl.offsetHeight;
          const position = isAuto ? calcPreferredPosition(rect, tooltipWidth, tooltipHeight, offset) : requestedPos;
          if (position !== initialPos) {
            tooltipEl.classList.remove(initialPos);
            tooltipEl.classList.add(position);
          }
          let top = 0;
          let left = 0;
          if (position === "top") {
            top = rect.top - tooltipHeight - offset;
            left = rect.left + rect.width / 2 - tooltipWidth / 2;
          } else if (position === "bottom") {
            top = rect.top + rect.height + offset;
            left = rect.left + rect.width / 2 - tooltipWidth / 2;
          } else if (position === "left") {
            top = rect.top + rect.height / 2 - tooltipHeight / 2;
            left = rect.left - tooltipWidth - offset;
          } else if (position === "right") {
            top = rect.top + rect.height / 2 - tooltipHeight / 2;
            left = rect.left + rect.width + offset;
          }
          if (left < 10) left = 10;
          if (left + tooltipWidth > window.innerWidth - 10) left = window.innerWidth - tooltipWidth - 10;
          if (top < 10) top = 10;
          if (top + tooltipHeight > window.innerHeight - 10) top = window.innerHeight - tooltipHeight - 10;
          tooltipEl.style.top = `${top}px`;
          tooltipEl.style.left = `${left}px`;
          requestAnimationFrame(() => {
            tooltipEl.classList.add("visible");
          });
        }
        static hide() {
          var _a;
          if (!((_a = this.ref) == null ? void 0 : _a.current)) return;
          const tooltipEl = this.ref.current;
          tooltipEl.classList.remove("visible");
          this.closeTimer = setTimeout(() => {
            if (this.host) {
              this.host.innerHTML = "";
            }
          }, 200);
        }
        /**
         * Deprecated: Use show(event, ...) instead for better performance
         */
        static attach(el, content, options3 = {}) {
          el.addEventListener("mouseenter", (e) => this.show(e, content, options3));
        }
      };
      TooltipContent = (props) => {
        const globalCssId = getGlobalStylesId(tooltipCss);
        bindGlobalStyle(globalCssId, tooltipCss);
        const ref = {
          globalCssId,
          onLoad: async () => {
            props.onRef(ref);
          }
        };
        return /* @__PURE__ */ jsx("div", { class: ["&-container", props.position].join(" "), ref, children: /* @__PURE__ */ jsx("div", { class: "&-box", children: [
          props.content,
          props.showArrow && /* @__PURE__ */ jsx("div", { class: "&-arrow" })
        ] }) });
      };
      Tooltip = TooltipHelper;
    }
  });

  // node_modules/lupine.components/src/component-pool/tooltip/tooltip-demo.tsx
  var tooltipDemo;
  var init_tooltip_demo = __esm({
    "node_modules/lupine.components/src/component-pool/tooltip/tooltip-demo.tsx"() {
      init_tooltip();
      init_jsx_runtime();
      tooltipDemo = {
        id: "tooltipDemo",
        text: "Tooltip",
        args: {
          content: "This is a tooltip",
          position: "auto",
          showArrow: true
        },
        argTypes: {
          content: { control: "text" },
          position: {
            control: "select",
            options: ["auto", "top", "bottom", "left", "right"]
          },
          showArrow: { control: "boolean" }
        },
        render: (args) => {
          const css2 = {
            display: "flex",
            flexDirection: "column",
            gap: "48px",
            padding: "48px",
            alignItems: "center",
            ".demo-section": {
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              gap: "24px",
              width: "100%",
              maxWidth: "600px"
            },
            ".section-title": {
              fontSize: "20px",
              fontWeight: "bold",
              color: "var(--primary-color)",
              marginBottom: "16px",
              borderBottom: "2px solid var(--secondary-border-color)",
              width: "100%",
              paddingBottom: "8px"
            },
            ".grid": {
              display: "grid",
              gridTemplateColumns: "repeat(2, 1fr)",
              gap: "20px",
              width: "100%"
            },
            ".box": {
              padding: "20px",
              border: "1px solid var(--secondary-border-color)",
              borderRadius: "8px",
              textAlign: "center",
              cursor: "pointer",
              backgroundColor: "var(--primary-bg-color)",
              "&:hover": {
                borderColor: "var(--primary-color)"
              }
            }
          };
          const richContent = /* @__PURE__ */ jsx("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
            /* @__PURE__ */ jsx("span", { style: { fontSize: "18px" }, children: "\u{1F4A1}" }),
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("div", { style: { fontWeight: "bold" }, children: "Rich Content" }),
              /* @__PURE__ */ jsx("div", { style: { fontSize: "11px", opacity: 0.8 }, children: "With icons and formatting" })
            ] })
          ] });
          return /* @__PURE__ */ jsx("div", { css: css2, children: [
            /* @__PURE__ */ jsx("section", { class: "demo-section", children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Interactive Control" }),
              /* @__PURE__ */ jsx(
                "div",
                {
                  class: "box",
                  style: { width: "200px", padding: "40px" },
                  onMouseEnter: (e) => Tooltip.show(e, args.content, { position: args.position, showArrow: args.showArrow }),
                  children: "Hover me to see Tooltip from Controls"
                }
              )
            ] }),
            /* @__PURE__ */ jsx("section", { class: "demo-section", children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Auto-Position & JIT Binding" }),
              /* @__PURE__ */ jsx("div", { class: "grid", children: [
                /* @__PURE__ */ jsx("div", { class: "box", onMouseEnter: (e) => Tooltip.show(e, "Top Tooltip", { position: "top" }), children: "Top Position" }),
                /* @__PURE__ */ jsx("div", { class: "box", onMouseEnter: (e) => Tooltip.show(e, "Bottom Tooltip", { position: "bottom" }), children: "Bottom Position" }),
                /* @__PURE__ */ jsx("div", { class: "box", onMouseEnter: (e) => Tooltip.show(e, "Left Tooltip", { position: "left" }), children: "Left Position" }),
                /* @__PURE__ */ jsx("div", { class: "box", onMouseEnter: (e) => Tooltip.show(e, "Right Tooltip", { position: "right" }), children: "Right Position" }),
                /* @__PURE__ */ jsx(
                  "div",
                  {
                    class: "box",
                    onMouseEnter: (e) => Tooltip.show(e, "Square Tooltip (No Arrow)", { showArrow: false }),
                    children: "Square Style"
                  }
                ),
                /* @__PURE__ */ jsx("div", { class: "box", onMouseEnter: (e) => Tooltip.show(e, richContent), children: "Rich Content (VNode)" })
              ] })
            ] }),
            /* @__PURE__ */ jsx("section", { class: "demo-section", children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Standard Buttons" }),
              /* @__PURE__ */ jsx("div", { style: { display: "flex", gap: "12px" }, children: [
                /* @__PURE__ */ jsx(
                  "button",
                  {
                    class: "button-base button-m",
                    onMouseEnter: (e) => Tooltip.show(e, "Saved successfully!", { position: "top" }),
                    children: "Save"
                  }
                ),
                /* @__PURE__ */ jsx(
                  "button",
                  {
                    class: "button-base button-m",
                    onMouseEnter: (e) => Tooltip.show(e, "Delete this item forever?", { position: "bottom" }),
                    children: "Delete"
                  }
                )
              ] })
            ] })
          ] });
        },
        code: `import { Tooltip } from 'lupine.components/component-pool';

// JIT triggering
<div onMouseEnter={e => Tooltip.show(e, 'Message')}>Hover me</div>

// With options
Tooltip.show(event, 'Message', { position: 'top', showArrow: true });
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/tooltip/index.ts
  var init_tooltip2 = __esm({
    "node_modules/lupine.components/src/component-pool/tooltip/index.ts"() {
      init_tooltip();
      init_tooltip_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/time-picker/time-picker.tsx
  var timePickerCss, TimePicker;
  var init_time_picker = __esm({
    "node_modules/lupine.components/src/component-pool/time-picker/time-picker.tsx"() {
      init_src();
      init_picker_helper();
      init_svg_props();
      init_jsx_runtime();
      timePickerCss = {
        display: "inline-flex",
        position: "relative",
        width: "100%",
        flexDirection: "column",
        ".&-input": {
          width: "100%",
          cursor: "pointer",
          paddingRight: "30px"
        },
        ".&-icon": {
          position: "absolute",
          right: "8px",
          top: "50%",
          transform: "translateY(-50%)",
          pointerEvents: "none",
          color: "var(--secondary-color, #999)"
        },
        ".&-icon-clear": {
          position: "absolute",
          right: "28px",
          top: "50%",
          transform: "translateY(-50%)",
          cursor: "pointer",
          color: "var(--error-color, #f5222d)",
          opacity: 0.6,
          transition: "opacity 0.2s",
          "&:hover": { opacity: 1 },
          display: "none"
        },
        "&:hover .&-icon-clear.visible": {
          display: "block"
        },
        ".&-panel": {
          display: "flex",
          flexDirection: "column-reverse",
          // Footer at top when popup is BELOW input
          width: "240px",
          backgroundColor: "var(--primary-bg-color, #fff)",
          borderRadius: "var(--border-radius-m, 8px)"
        },
        ":global(.lupine-picker-host .top) .&-panel": {
          flexDirection: "column"
          // Footer at bottom when popup is ABOVE input
        },
        ".&-columns": {
          display: "flex",
          height: "220px",
          borderBottom: "1px solid var(--secondary-border-color, #eee)"
        },
        ".&-column": {
          flex: 1,
          overflowY: "auto",
          textAlign: "center",
          padding: "4px 0",
          scrollbarWidth: "none",
          "-ms-overflow-style": "none",
          "&::-webkit-scrollbar": {
            display: "none"
          },
          overflowX: "hidden"
        },
        ".&-item": {
          padding: "2px 0",
          cursor: "pointer",
          fontSize: "13px",
          transition: "all 0.2s",
          color: "var(--primary-color-normal, #333)",
          "&:hover": {
            backgroundColor: "var(--secondary-bg-color, #f5f5f5)"
          },
          "&.selected": {
            backgroundColor: "var(--primary-bg-color-hover, #e6f7ff)",
            color: "var(--primary-color, #1890ff)",
            fontWeight: "bold"
          }
        },
        ".&-footer": {
          padding: "8px",
          display: "flex",
          justifyContent: "flex-end",
          borderBottom: "1px solid var(--secondary-border-color, #f0f0f0)"
        },
        ":global(.lupine-picker-host .top) .&-footer": {
          borderBottom: "none",
          borderTop: "1px solid var(--secondary-border-color, #f0f0f0)"
        },
        ".&-ok-btn": {
          padding: "2px 0 0 0",
          borderRadius: "var(--border-radius-m, 6px)",
          cursor: "pointer",
          backgroundColor: "var(--primary-color, #1890ff)",
          color: "#fff",
          border: "none",
          transition: "opacity 0.2s",
          width: "100%",
          "&:hover": {
            opacity: 0.85
          },
          "&:active": {
            opacity: 0.7
          }
        }
      };
      TimePicker = (props) => {
        const globalCssId = getGlobalStylesId(timePickerCss);
        bindGlobalStyle(globalCssId, timePickerCss);
        const ref = { globalCssId };
        let currentValue = props.value || "";
        const parseValue = (val) => {
          const parts = val.split(":");
          return {
            h: parseInt(parts[0]) || 0,
            m: parseInt(parts[1]) || 0,
            s: parseInt(parts[2]) || 0
          };
        };
        const formatValue = (h, m, s) => {
          return [h.toString().padStart(2, "0"), m.toString().padStart(2, "0"), s.toString().padStart(2, "0")].join(":");
        };
        const updateInput = (val) => {
          currentValue = val;
          const input = ref.$(".&-input");
          if (input) input.value = val;
        };
        const showPicker = () => {
          const input = ref.$(".&-input");
          const { h: initialH, m: initialM, s: initialS } = parseValue(input.value);
          let selectedH = initialH;
          let selectedM = initialM;
          let selectedS = initialS;
          const rect = input.getBoundingClientRect();
          const offset = 8;
          const spaceTop = rect.top - offset;
          const spaceBottom = window.innerHeight - rect.bottom - offset;
          let columnsHeight = 220;
          const footerHeight = 44;
          const expectedHeight = columnsHeight + footerHeight;
          if (spaceBottom < expectedHeight) {
            if (spaceTop > spaceBottom) {
              columnsHeight = spaceTop - footerHeight;
            } else {
              columnsHeight = spaceBottom - footerHeight;
            }
          }
          columnsHeight = Math.max(100, Math.min(220, columnsHeight));
          const renderPanel = () => {
            const hours = Array.from({ length: 24 }, (_, i) => i);
            const minutes = Array.from({ length: 60 }, (_, i) => i);
            const seconds = Array.from({ length: 60 }, (_, i) => i);
            const panelRef = {
              globalCssId,
              onLoad: async () => {
                setTimeout(highlightSelection, 10);
              }
            };
            const highlightSelection = () => {
              panelRef.$all(".&-item").forEach((item) => item.classList.remove("selected"));
              const hItem = panelRef.$(`.col-h [data-val="${selectedH}"]`);
              const mItem = panelRef.$(`.col-m [data-val="${selectedM}"]`);
              const sItem = panelRef.$(`.col-s [data-val="${selectedS}"]`);
              hItem == null ? void 0 : hItem.classList.add("selected");
              mItem == null ? void 0 : mItem.classList.add("selected");
              sItem == null ? void 0 : sItem.classList.add("selected");
              hItem == null ? void 0 : hItem.scrollIntoView({ block: "nearest" });
              mItem == null ? void 0 : mItem.scrollIntoView({ block: "nearest" });
              sItem == null ? void 0 : sItem.scrollIntoView({ block: "nearest" });
            };
            const handleConfirm = () => {
              var _a;
              const finalVal = formatValue(selectedH, selectedM, selectedS);
              updateInput(finalVal);
              (_a = props.onChange) == null ? void 0 : _a.call(props, finalVal);
              PickerHelper.hide();
            };
            const selectItem = (type, val, isDoubleClick) => {
              if (type === "h") selectedH = val;
              else if (type === "m") selectedM = val;
              else if (type === "s") selectedS = val;
              highlightSelection();
              if (isDoubleClick) {
                handleConfirm();
              }
            };
            return /* @__PURE__ */ jsx("div", { class: "&-panel", ref: panelRef, children: [
              /* @__PURE__ */ jsx("div", { class: "&-columns", style: `height: ${columnsHeight}px`, children: [
                /* @__PURE__ */ jsx("div", { class: "&-column col-h", children: hours.map((h) => /* @__PURE__ */ jsx(
                  "div",
                  {
                    class: "&-item",
                    "data-val": h,
                    onClick: () => selectItem("h", h),
                    onDblClick: () => selectItem("h", h, true),
                    children: h.toString().padStart(2, "0")
                  }
                )) }),
                /* @__PURE__ */ jsx("div", { class: "&-column col-m", children: minutes.map((m) => /* @__PURE__ */ jsx(
                  "div",
                  {
                    class: "&-item",
                    "data-val": m,
                    onClick: () => selectItem("m", m),
                    onDblClick: () => selectItem("m", m, true),
                    children: m.toString().padStart(2, "0")
                  }
                )) }),
                /* @__PURE__ */ jsx("div", { class: "&-column col-s", children: seconds.map((s) => /* @__PURE__ */ jsx(
                  "div",
                  {
                    class: "&-item",
                    "data-val": s,
                    onClick: () => selectItem("s", s),
                    onDblClick: () => selectItem("s", s, true),
                    children: s.toString().padStart(2, "0")
                  }
                )) })
              ] }),
              /* @__PURE__ */ jsx("div", { class: "&-footer", children: /* @__PURE__ */ jsx("button", { class: "&-ok-btn", onClick: handleConfirm, title: "Confirm", children: /* @__PURE__ */ jsx(CheckIcon, {}) }) })
            ] });
          };
          PickerHelper.show(input, renderPanel());
        };
        return /* @__PURE__ */ jsx("div", { class: "&-container", css: props.style, ref, children: [
          /* @__PURE__ */ jsx(
            "input",
            {
              class: ["&-input", props.className || "input-base"].join(" "),
              placeholder: props.placeholder || "Select time",
              value: currentValue,
              readonly: props.readonly !== false,
              onClick: showPicker
            }
          ),
          /* @__PURE__ */ jsx(
            "div",
            {
              class: ["&-icon-clear", currentValue ? "visible" : ""].join(" "),
              onClick: (e) => {
                var _a;
                e.stopPropagation();
                updateInput("");
                (_a = props.onChange) == null ? void 0 : _a.call(props, "");
              },
              children: /* @__PURE__ */ jsx(ClearIcon, {})
            }
          ),
          /* @__PURE__ */ jsx("div", { class: "&-icon", children: /* @__PURE__ */ jsx(ClockIcon, {}) })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/time-picker/time-picker-demo.tsx
  var timePickerDemo;
  var init_time_picker_demo = __esm({
    "node_modules/lupine.components/src/component-pool/time-picker/time-picker-demo.tsx"() {
      init_time_picker();
      init_action_sheet_time();
      init_button();
      init_jsx_runtime();
      timePickerDemo = {
        id: "timePickerDemo",
        text: "TimePicker",
        args: {
          value: "14:30:00",
          placeholder: "Pick a time"
        },
        argTypes: {
          value: { control: "text", description: "Initial time value (HH:mm:ss)" },
          placeholder: { control: "text" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { padding: "40px", display: "flex", flexDirection: "column", gap: "40px", maxWidth: "400px" }, children: [
            /* @__PURE__ */ jsx("section", { children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Interactive Time Selection" }),
              /* @__PURE__ */ jsx("p", { style: { fontSize: "14px", color: "#666", marginBottom: "16px" }, children: "Click the input to open the 3-column selector. Double-click an item or click OK to confirm." }),
              /* @__PURE__ */ jsx(TimePicker, { ...args, onChange: (val) => console.log("Time changed:", val) })
            ] }),
            /* @__PURE__ */ jsx("section", { children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Standalone Usage" }),
              /* @__PURE__ */ jsx("div", { style: { display: "flex", gap: "20px", alignItems: "center" }, children: [
                /* @__PURE__ */ jsx(TimePicker, { value: "09:00:00", style: { width: "150px" } }),
                /* @__PURE__ */ jsx(TimePicker, { value: "18:45:30", style: { width: "150px" } })
              ] })
            ] }),
            /* @__PURE__ */ jsx("section", { children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Mobile Friendly Alternative" }),
              /* @__PURE__ */ jsx("p", { style: { fontSize: "14px", color: "#666", marginBottom: "16px" }, children: "For mobile environments, it is highly recommended to use the ActionSheet-based Time Picker, which provides a native-like bottom-sheet spinning wheel experience." }),
              /* @__PURE__ */ jsx("div", { style: { display: "flex", gap: "20px", alignItems: "center", flexWrap: "wrap" }, children: [
                /* @__PURE__ */ jsx(
                  Button,
                  {
                    text: "Show Time Picker (HH:mm)",
                    size: "button-m" /* Medium */,
                    onClick: async () => {
                      const result = await ActionSheetTimePicker({
                        title: "Pick a time",
                        value: "09:30",
                        showSeconds: false
                      });
                      if (result) console.log("Time selected (HH:mm):", result);
                    }
                  }
                ),
                /* @__PURE__ */ jsx(
                  Button,
                  {
                    text: "Show Time Picker (HH:mm:ss)",
                    size: "button-m" /* Medium */,
                    onClick: async () => {
                      const result = await ActionSheetTimePicker({
                        title: "Pick a time",
                        value: "14:05:30",
                        showSeconds: true
                      });
                      if (result) console.log("Time selected (HH:mm:ss):", result);
                    }
                  }
                )
              ] })
            ] })
          ] });
        },
        code: `import { TimePicker } from 'lupine.components/component-pool';

<TimePicker 
  value="14:30:00" 
  onChange={(val) => console.log(val)} 
  placeholder="Select time"
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/time-picker/index.ts
  var init_time_picker2 = __esm({
    "node_modules/lupine.components/src/component-pool/time-picker/index.ts"() {
      init_time_picker();
      init_time_picker_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/date-picker/date-picker.tsx
  var datePickerCss, DatePicker;
  var init_date_picker = __esm({
    "node_modules/lupine.components/src/component-pool/date-picker/date-picker.tsx"() {
      init_src();
      init_html_var();
      init_picker_helper();
      init_svg_props();
      init_jsx_runtime();
      datePickerCss = {
        display: "inline-flex",
        position: "relative",
        width: "100%",
        flexDirection: "column",
        ".&-input": {
          width: "100%",
          cursor: "pointer",
          paddingRight: "30px"
        },
        ".&-icon": {
          position: "absolute",
          right: "8px",
          top: "50%",
          transform: "translateY(-50%)",
          pointerEvents: "none",
          color: "var(--secondary-color, #999)"
        },
        ".&-icon-clear": {
          position: "absolute",
          right: "28px",
          top: "50%",
          transform: "translateY(-50%)",
          cursor: "pointer",
          color: "var(--error-color, #f5222d)",
          opacity: 0.6,
          transition: "opacity 0.2s",
          "&:hover": { opacity: 1 },
          display: "none"
        },
        "&:hover .&-icon-clear.visible": {
          display: "block"
        },
        ".&-panel": {
          width: "280px",
          backgroundColor: "var(--primary-bg-color, #fff)",
          userSelect: "none",
          display: "flex",
          flexDirection: "column"
        },
        ".&-header": {
          display: "flex",
          alignItems: "center",
          padding: "12px",
          borderBottom: "1px solid var(--secondary-border-color, #f0f0f0)",
          gap: "4px"
        },
        ".&-nav-btn": {
          padding: "4px 8px",
          border: "1px solid transparent",
          backgroundColor: "transparent",
          cursor: "pointer",
          color: "var(--primary-color-normal, #666)",
          "&:hover": { color: "var(--primary-color, #1890ff)" },
          fontSize: "16px",
          fontWeight: "bold"
        },
        ".&-year-input-box": {
          display: "flex",
          alignItems: "center",
          flex: 1,
          position: "relative",
          ".year-input": {
            width: "100%",
            border: "1px solid var(--secondary-border-color, #d9d9d9)",
            borderRadius: "4px",
            padding: "4px 8px",
            fontSize: "14px",
            textAlign: "center",
            cursor: "pointer",
            "&:focus": { borderColor: "var(--primary-color, #1890ff)", outline: "none" }
          }
        },
        ".&-month-select": {
          border: "1px solid var(--secondary-border-color, #d9d9d9)",
          borderRadius: "4px",
          padding: "4px",
          cursor: "pointer"
        },
        ".&-body": {
          padding: "12px"
        },
        ".&-grid": {
          display: "grid",
          gridTemplateColumns: "repeat(7, 1fr)",
          gap: "2px"
        },
        ".&-weekday": {
          textAlign: "center",
          fontSize: "12px",
          fontWeight: "600",
          color: "var(--secondary-color, #8c8c8c)",
          padding: "8px 0"
        },
        ".&-day": {
          textAlign: "center",
          padding: "8px 0",
          cursor: "pointer",
          borderRadius: "4px",
          fontSize: "14px",
          transition: "all 0.2s",
          "&:hover": {
            backgroundColor: "var(--primary-bg-color-hover, #e6f7ff)",
            color: "var(--primary-color, #1890ff)"
          },
          "&.selected": {
            backgroundColor: "var(--primary-color, #1890ff)",
            color: "#fff",
            fontWeight: "bold"
          },
          "&.today": {
            color: "var(--primary-color, #1890ff)",
            fontWeight: "bold",
            "&::after": {
              content: '""',
              display: "block",
              margin: "-4px auto 0",
              width: "4px",
              height: "4px",
              borderRadius: "50%",
              backgroundColor: "var(--primary-color, #1890ff)"
            }
          },
          "&.not-this-month": {
            color: "var(--secondary-color-light, #d9d9d9)"
          }
        },
        ".&-ok-btn": {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          width: "24px",
          height: "24px",
          padding: "2px",
          borderRadius: "4px",
          cursor: "pointer",
          backgroundColor: "var(--primary-color, #1890ff)",
          color: "#fff",
          border: "none",
          transition: "opacity 0.2s",
          "&:hover": { opacity: 0.85 }
        },
        ".&-year-popup": {
          position: "absolute",
          top: "100%",
          left: 0,
          right: 0,
          backgroundColor: "#fff",
          boxShadow: "var(--cover-box-shadow, 0 4px 12px rgba(0,0,0,0.1))",
          borderRadius: "4px",
          border: "1px solid var(--secondary-border-color, #f0f0f0)",
          maxHeight: "200px",
          overflowY: "auto",
          scrollbarWidth: "none",
          "-ms-overflow-style": "none",
          "&::-webkit-scrollbar": {
            display: "none"
          },
          zIndex: 10,
          display: "none",
          "&.open": { display: "block" },
          ".year-item": {
            padding: "8px",
            textAlign: "center",
            cursor: "pointer",
            fontSize: "13px",
            "&:hover": { backgroundColor: "var(--secondary-bg-color, #f5f5f5)" },
            "&.active": { color: "var(--primary-color, #1890ff)", fontWeight: "bold" }
          }
        }
      };
      DatePicker = (props) => {
        const globalCssId = getGlobalStylesId(datePickerCss);
        bindGlobalStyle(globalCssId, datePickerCss);
        const ref = { globalCssId };
        let currentValue = props.value || "";
        const parseDate = (val) => {
          if (!val) return /* @__PURE__ */ new Date();
          const d = new Date(val);
          if (isNaN(d.getTime())) return /* @__PURE__ */ new Date();
          return d;
        };
        const formatDate = (date) => {
          const y = date.getFullYear();
          const m = (date.getMonth() + 1).toString().padStart(2, "0");
          const d = date.getDate().toString().padStart(2, "0");
          return `${y}-${m}-${d}`;
        };
        const updateInput = (val) => {
          currentValue = val;
          const input = ref.$(".&-input");
          if (input) input.value = val;
        };
        const showPicker = () => {
          const input = ref.$(".&-input");
          let viewDate = parseDate(input.value);
          let selectedDate = parseDate(input.value);
          let isYearMenuOpen = false;
          const renderPanel = () => {
            const panelRef = { globalCssId };
            const gridVar = new HtmlVar("");
            const refreshGrid = () => {
              gridVar.value = renderGridDays();
            };
            const changeYear = (delta) => {
              viewDate = new Date(viewDate.setFullYear(viewDate.getFullYear() + delta));
              updateHeader();
              refreshGrid();
            };
            const changeMonth = (m) => {
              viewDate = new Date(viewDate.setMonth(m));
              updateHeader();
              refreshGrid();
            };
            const setYear = (y) => {
              viewDate = new Date(viewDate.setFullYear(y));
              isYearMenuOpen = false;
              updateHeader();
              refreshGrid();
            };
            const updateHeader = () => {
              const yrInput = panelRef.$(".year-input");
              if (yrInput) yrInput.value = viewDate.getFullYear().toString();
              const mSelect = panelRef.$(".&-month-select");
              if (mSelect) mSelect.value = viewDate.getMonth().toString();
              const yearPopup = panelRef.$(".&-year-popup");
              if (yearPopup) yearPopup.classList.toggle("open", isYearMenuOpen);
            };
            const selectDay = (day, confirm = false) => {
              var _a;
              selectedDate = new Date(day);
              viewDate = new Date(day);
              if (confirm) {
                const val = formatDate(selectedDate);
                updateInput(val);
                (_a = props.onChange) == null ? void 0 : _a.call(props, val);
                PickerHelper.hide();
              } else {
                refreshGrid();
              }
            };
            const renderGridDays = () => {
              const year = viewDate.getFullYear();
              const month = viewDate.getMonth();
              const firstDayOfMonth = new Date(year, month, 1).getDay();
              const daysInMonth = new Date(year, month + 1, 0).getDate();
              const prevMonthLastDay = new Date(year, month, 0).getDate();
              const daysNodes = [];
              ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"].map((w) => {
                daysNodes.push(/* @__PURE__ */ jsx("div", { class: "&-weekday", children: w }));
              });
              const todayStr = formatDate(/* @__PURE__ */ new Date());
              const selectedStr = formatDate(selectedDate);
              for (let i = firstDayOfMonth - 1; i >= 0; i--) {
                daysNodes.push(/* @__PURE__ */ jsx("div", { class: "&-day not-this-month", children: prevMonthLastDay - i }));
              }
              for (let i = 1; i <= daysInMonth; i++) {
                const d = new Date(year, month, i);
                const dStr = formatDate(d);
                const isToday = dStr === todayStr;
                const isSelected = dStr === selectedStr;
                daysNodes.push(
                  /* @__PURE__ */ jsx(
                    "div",
                    {
                      class: ["&-day", isToday ? "today" : "", isSelected ? "selected" : ""].join(" "),
                      onClick: () => selectDay(d),
                      onDblClick: () => selectDay(d, true),
                      children: i
                    }
                  )
                );
              }
              const ref2 = { globalCssId };
              return /* @__PURE__ */ jsx("div", { class: "&-grid", ref: ref2, children: daysNodes });
            };
            const yearRange = props.yearRange || 10;
            const years = [];
            const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
            for (let i = currentYear - 50; i <= currentYear + 50; i++) {
              years.push(i);
            }
            gridVar.value = renderGridDays();
            return /* @__PURE__ */ jsx("div", { class: "&-panel", ref: panelRef, children: [
              /* @__PURE__ */ jsx("div", { class: "&-header", children: [
                /* @__PURE__ */ jsx("button", { class: "&-nav-btn", onClick: () => changeYear(-1), children: "\xAB" }),
                /* @__PURE__ */ jsx("button", { class: "&-nav-btn", onClick: () => changeMonth(viewDate.getMonth() - 1), children: "\u2039" }),
                /* @__PURE__ */ jsx("div", { class: "&-year-input-box", children: [
                  /* @__PURE__ */ jsx(
                    "input",
                    {
                      class: "year-input",
                      value: viewDate.getFullYear(),
                      readonly: true,
                      onClick: () => {
                        isYearMenuOpen = !isYearMenuOpen;
                        updateHeader();
                      }
                    }
                  ),
                  /* @__PURE__ */ jsx("div", { class: "&-year-popup", children: years.map((y) => /* @__PURE__ */ jsx(
                    "div",
                    {
                      class: ["year-item", y === viewDate.getFullYear() ? "active" : ""].join(" "),
                      onClick: () => setYear(y),
                      children: y
                    }
                  )) })
                ] }),
                /* @__PURE__ */ jsx(
                  "select",
                  {
                    class: "&-month-select",
                    value: viewDate.getMonth(),
                    onChange: (e) => changeMonth(parseInt(e.target.value)),
                    children: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"].map((m, i) => /* @__PURE__ */ jsx("option", { value: i, children: m }))
                  }
                ),
                /* @__PURE__ */ jsx("button", { class: "&-nav-btn", onClick: () => changeMonth(viewDate.getMonth() + 1), children: "\u203A" }),
                /* @__PURE__ */ jsx("button", { class: "&-nav-btn", onClick: () => changeYear(1), children: "\xBB" }),
                /* @__PURE__ */ jsx("button", { class: "&-ok-btn", onClick: () => selectDay(selectedDate, true), title: "Confirm", children: /* @__PURE__ */ jsx(CheckIcon, {}) })
              ] }),
              /* @__PURE__ */ jsx("div", { class: "&-body", children: gridVar.node })
            ] });
          };
          PickerHelper.show(input, renderPanel());
        };
        return /* @__PURE__ */ jsx("div", { class: "&-container", css: { ...datePickerCss, ...props.style }, ref, children: [
          /* @__PURE__ */ jsx(
            "input",
            {
              class: ["&-input", props.className || "input-base"].join(" "),
              placeholder: props.placeholder || "Select date",
              value: currentValue,
              readonly: true,
              onClick: showPicker
            }
          ),
          /* @__PURE__ */ jsx(
            "div",
            {
              class: ["&-icon-clear", currentValue ? "visible" : ""].join(" "),
              onClick: (e) => {
                var _a;
                e.stopPropagation();
                updateInput("");
                (_a = props.onChange) == null ? void 0 : _a.call(props, "");
              },
              children: /* @__PURE__ */ jsx(ClearIcon, {})
            }
          ),
          /* @__PURE__ */ jsx("div", { class: "&-icon", children: /* @__PURE__ */ jsx(CalendarIcon, {}) })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/date-picker/date-picker-demo.tsx
  var datePickerDemo;
  var init_date_picker_demo = __esm({
    "node_modules/lupine.components/src/component-pool/date-picker/date-picker-demo.tsx"() {
      init_date_picker();
      init_action_sheet_date();
      init_button();
      init_jsx_runtime();
      datePickerDemo = {
        id: "datePickerDemo",
        text: "DatePicker",
        args: {
          value: "2026-02-24",
          placeholder: "Pick a date",
          yearRange: 10
        },
        argTypes: {
          value: { control: "text", description: "Initial date value (YYYY-MM-DD)" },
          placeholder: { control: "text" },
          yearRange: { control: "number", description: "Years +/- to show in menu" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { padding: "40px", display: "flex", flexDirection: "column", gap: "40px", maxWidth: "400px" }, children: [
            /* @__PURE__ */ jsx("section", { children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Interactive Date Selection" }),
              /* @__PURE__ */ jsx("p", { style: { fontSize: "14px", color: "#666", marginBottom: "16px" }, children: "Click the input to open the calendar. Use the header to change year/month. Double-click a date or click OK to confirm." }),
              /* @__PURE__ */ jsx(DatePicker, { ...args, onChange: (val) => console.log("Date changed:", val) })
            ] }),
            /* @__PURE__ */ jsx("section", { children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Presets" }),
              /* @__PURE__ */ jsx("div", { style: { display: "flex", gap: "20px", alignItems: "center" }, children: [
                /* @__PURE__ */ jsx(DatePicker, { value: "1990-01-01", style: { width: "150px" } }),
                /* @__PURE__ */ jsx(DatePicker, { value: "2030-12-31", style: { width: "150px" } })
              ] })
            ] }),
            /* @__PURE__ */ jsx("section", { children: [
              /* @__PURE__ */ jsx("div", { class: "section-title", children: "Mobile Friendly Alternative" }),
              /* @__PURE__ */ jsx("p", { style: { fontSize: "14px", color: "#666", marginBottom: "16px" }, children: "For mobile environments, it is highly recommended to use the ActionSheet-based Date Picker, which provides a native-like bottom-sheet spinning wheel experience." }),
              /* @__PURE__ */ jsx("div", { style: { display: "flex", gap: "20px", alignItems: "center", flexWrap: "wrap" }, children: [
                /* @__PURE__ */ jsx(
                  Button,
                  {
                    text: "Show Date Picker (Year-Month-Day)",
                    size: "button-m" /* Medium */,
                    onClick: async () => {
                      const result = await ActionSheetDatePicker({
                        title: "Pick a date",
                        value: "2026-02-24",
                        order: "YMD"
                      });
                      if (result) console.log("Date selected (YMD):", result);
                    }
                  }
                ),
                /* @__PURE__ */ jsx(
                  Button,
                  {
                    text: "Show Date Picker (Day-Month-Year)",
                    size: "button-m" /* Medium */,
                    onClick: async () => {
                      const result = await ActionSheetDatePicker({
                        title: "Pick a date",
                        value: "2026-02-24",
                        order: "DMY"
                      });
                      if (result) console.log("Date selected (DMY):", result);
                    }
                  }
                )
              ] })
            ] })
          ] });
        },
        code: `import { DatePicker } from 'lupine.components/component-pool';

<DatePicker 
  value="2026-02-24" 
  onChange={(val) => console.log(val)} 
  placeholder="Select date"
  yearRange={10}
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/date-picker/index.ts
  var init_date_picker2 = __esm({
    "node_modules/lupine.components/src/component-pool/date-picker/index.ts"() {
      init_date_picker();
      init_date_picker_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/pull-to-refresh/pull-to-refresh.tsx
  var PullToRefresh, PullToRefreshContent;
  var init_pull_to_refresh = __esm({
    "node_modules/lupine.components/src/component-pool/pull-to-refresh/pull-to-refresh.tsx"() {
      init_spinner();
      init_svg_props();
      init_jsx_runtime();
      PullToRefresh = (props) => {
        const css2 = {
          display: "flex",
          flexDirection: "column",
          width: "100%",
          height: "0px",
          position: "relative",
          pointerEvents: "none",
          zIndex: "var(--layer-dragged-item, 4000)",
          ".pull-indicator": {
            position: "fixed",
            top: "0",
            left: "0",
            width: "100%",
            height: "0px",
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            alignItems: "center",
            overflow: "hidden",
            transition: "none",
            background: "linear-gradient(to bottom, rgba(var(--primary-color-rgb, 55 55 55) / 0.1), transparent)",
            pointerEvents: "none"
          },
          ".pull-icon-wrapper": {
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            width: "40px",
            height: "40px",
            borderRadius: "50%",
            backgroundColor: "var(--primary-bg-color, #fff)",
            boxShadow: "var(--cover-box-shadow, 0 4px 12px rgba(0,0,0,0.15))",
            transition: "transform 0.1s ease, opacity 0.1s ease",
            color: "var(--primary-color)"
          },
          "&.refreshing .pull-icon-wrapper": {
            animation: "pull-to-refresh-pulse 1.5s infinite ease-in-out"
          },
          "@keyframes pull-to-refresh-pulse": {
            "0%": { transform: "scale(1)" },
            "50%": { transform: "scale(1.1)" },
            "100%": { transform: "scale(1)" }
          }
        };
        let isEnabled = false;
        if (props.hook) {
          props.hook.setCheckEnabled = (checkEnabled) => {
            props.checkEnabled = checkEnabled;
          };
          props.hook.setOnDragRefresh = (onDragRefresh) => {
            props.onDragRefresh = onDragRefresh;
          };
        }
        const ref = {
          onLoad: async () => {
            const container = document.querySelector(props.container);
            const pullDom = ref.current;
            const indicatorDom = ref.$(".pull-indicator");
            const iconWrapper = ref.$(".pull-icon-wrapper");
            if (!container || !pullDom || !indicatorDom || !iconWrapper) return;
            let touchstartY = 0;
            let touchstartX = 0;
            let pulling = false;
            let refreshing = false;
            const threshold = 70;
            const maxPull = 120;
            const reset = (smooth = true) => {
              pulling = false;
              refreshing = false;
              pullDom.classList.remove("refreshing");
              if (smooth) {
                indicatorDom.style.transition = "height 0.3s ease, opacity 0.3s ease";
              }
              indicatorDom.style.height = "0px";
              indicatorDom.style.opacity = "0";
              iconWrapper.style.transform = "rotate(0deg) scale(0.5)";
              if (smooth) {
                setTimeout(() => {
                  indicatorDom.style.transition = "none";
                }, 300);
              }
            };
            const close = () => {
              reset(true);
            };
            container.addEventListener(
              "touchstart",
              (e) => {
                if (refreshing) return;
                const scrollTop = container.scrollTop;
                if (scrollTop > 0) {
                  isEnabled = false;
                  return;
                }
                isEnabled = props.checkEnabled ? props.checkEnabled() : true;
                if (!isEnabled) return;
                touchstartY = e.touches[0].clientY;
                touchstartX = e.touches[0].clientX;
                pulling = false;
                indicatorDom.style.transition = "none";
              },
              { passive: true }
            );
            container.addEventListener(
              "touchmove",
              (e) => {
                if (!isEnabled || refreshing) return;
                const touchY = e.touches[0].clientY;
                const touchX = e.touches[0].clientX;
                const deltaY = touchY - touchstartY;
                const deltaX = touchX - touchstartX;
                if (deltaY <= 0 || Math.abs(deltaX) > Math.abs(deltaY) && !pulling) {
                  return;
                }
                pulling = true;
                if (e.cancelable) e.preventDefault();
                const pullDistance = Math.min(maxPull, deltaY * 0.5);
                const progress = Math.min(1, pullDistance / threshold);
                indicatorDom.style.height = `${pullDistance}px`;
                indicatorDom.style.opacity = `${progress}`;
                const rotation = progress * 360;
                const scale = 0.5 + progress * 0.5;
                iconWrapper.style.transform = `rotate(${rotation}deg) scale(${scale})`;
                indicatorDom.style.background = `linear-gradient(to bottom, rgba(var(--primary-color-rgb, 55 55 55) / ${0.1 * progress}), transparent)`;
              },
              { passive: false }
            );
            container.addEventListener("touchend", () => {
              if (!isEnabled || !pulling || refreshing) return;
              const currentHeight = parseInt(indicatorDom.style.height);
              if (currentHeight >= threshold) {
                refreshing = true;
                pullDom.classList.add("refreshing");
                indicatorDom.style.transition = "height 0.2s ease";
                indicatorDom.style.height = "60px";
                if (props.onDragRefresh) {
                  props.onDragRefresh(close);
                } else {
                  setTimeout(close, 1500);
                }
              } else {
                reset(true);
              }
              pulling = false;
            });
          }
        };
        return /* @__PURE__ */ jsx("div", { ref, css: css2, class: ["pull-to-refresh", props.className].filter(Boolean).join(" "), children: /* @__PURE__ */ jsx("div", { class: "pull-indicator", children: /* @__PURE__ */ jsx("div", { class: "pull-icon-wrapper", children: /* @__PURE__ */ jsx(PullToRefreshContent, {}) }) }) });
      };
      PullToRefreshContent = () => {
        return /* @__PURE__ */ jsx("div", { css: { display: "flex", alignItems: "center", justifyContent: "center" }, children: [
          /* @__PURE__ */ jsx("div", { class: "refresh-icon-only", css: { ".refreshing &": { display: "none" } }, children: /* @__PURE__ */ jsx(RefreshIcon, { width: "24", height: "24" }) }),
          /* @__PURE__ */ jsx("div", { class: "refresh-spinner-only", css: { display: "none", ".refreshing &": { display: "block" } }, children: /* @__PURE__ */ jsx(Spinner01, { size: "22px" /* Small */ }) })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/pull-to-refresh/pull-to-refresh-demo.tsx
  var pullToRefreshDemo;
  var init_pull_to_refresh_demo = __esm({
    "node_modules/lupine.components/src/component-pool/pull-to-refresh/pull-to-refresh-demo.tsx"() {
      init_html_var();
      init_card2();
      init_pull_to_refresh();
      init_jsx_runtime();
      pullToRefreshDemo = {
        id: "pull-to-refresh-demo",
        text: "PullToRefresh",
        title: "Display/PullToRefresh",
        args: {},
        argTypes: {},
        render: (args) => {
          const css2 = {
            display: "flex",
            flexDirection: "column",
            height: "400px",
            border: "1px solid var(--secondary-border-color)",
            borderRadius: "8px",
            overflow: "hidden",
            backgroundColor: "var(--secondary-bg-color)",
            ".scroll-container": {
              flex: 1,
              overflowY: "auto",
              padding: "16px",
              display: "flex",
              flexDirection: "column",
              gap: "12px"
            }
          };
          const listDom = new HtmlVar("");
          const generateItems = () => {
            return Array.from({ length: 10 }, (_, i) => ({
              id: Math.random().toString(36).substr(2, 9),
              title: `Item ${i + 1}`,
              description: `This is the description for item ${i + 1}. On mobile devices, pull down to refresh and see new items!`
            }));
          };
          let items = generateItems();
          const updateList = () => {
            listDom.value = /* @__PURE__ */ jsx(Fragment, { children: items.map((item) => /* @__PURE__ */ jsx(
              Card,
              {
                title: item.title,
                description: item.description,
                style: { backgroundColor: "var(--primary-bg-color)" }
              },
              item.id
            )) });
          };
          const onDragRefresh = async (close) => {
            await new Promise((resolve) => setTimeout(resolve, 2e3));
            items = [
              {
                id: "new-" + Date.now(),
                title: "Directly Refreshed!",
                description: "This item was added after a pull-to-refresh action."
              },
              ...generateItems().slice(0, 9)
            ];
            updateList();
            close();
          };
          updateList();
          return /* @__PURE__ */ jsx("div", { css: css2, children: /* @__PURE__ */ jsx("div", { class: "scroll-container", children: [
            /* @__PURE__ */ jsx(PullToRefresh, { container: ".scroll-container", onDragRefresh }),
            listDom.node
          ] }) });
        },
        code: `
<div class='container' style={{ height: '400px', overflowY: 'auto' }}>
  <PullToRefresh 
    container='.container' 
    onDragRefresh={async (close) => {
      await fetchData();
      close();
    }} 
  />
  {/* List content here */}
</div>
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/tag-input/tag-input.tsx
  var tagInputCss, TagInput;
  var init_tag_input = __esm({
    "node_modules/lupine.components/src/component-pool/tag-input/tag-input.tsx"() {
      init_src();
      init_html_var();
      init_action_sheet();
      init_jsx_runtime();
      tagInputCss = {
        display: "flex",
        "&.disabled": {
          backgroundColor: "var(--primary-bg-color-hover, #f5f5f5)",
          cursor: "not-allowed",
          opacity: "0.7"
        },
        "&:hover": {
          borderColor: "var(--activatable-color-normal, #4080ff)"
        },
        "&.disabled:hover": {
          borderColor: "var(--primary-border-color)"
        },
        ".&-tag-box": {
          border: "1px solid var(--primary-border-color)",
          borderRadius: "var(--border-radius-m, 8px)",
          backgroundColor: "var(--primary-bg-color, #fff)",
          minHeight: "40px",
          padding: "4px 8px",
          cursor: "pointer",
          display: "flex",
          flex: 1,
          flexWrap: "wrap",
          gap: "2px",
          alignItems: "center",
          opacity: "1"
        },
        ".&-placeholder": {
          color: "var(--secondary-color, #999)",
          fontSize: "14px",
          paddingLeft: "4px"
        },
        ".&-tag": {
          display: "inline-flex",
          alignItems: "center",
          backgroundColor: "var(--activatable-bg-color-hover, rgba(0,0,0,0.06))",
          color: "var(--primary-color)",
          borderRadius: "4px",
          padding: "2px 8px",
          fontSize: "13px",
          lineHeight: "20px"
        },
        ".&-tag-remove": {
          marginLeft: "6px",
          cursor: "pointer",
          fontSize: "16px",
          lineHeight: "1",
          color: "var(--secondary-color, #999)",
          transition: "color 0.2s",
          "&:hover": {
            color: "var(--error-color, #ff4d4f)"
          }
        }
      };
      TagInput = ({
        options: options3 = [],
        selectedIndices = [],
        placeholder = "Select tags...",
        disabled = false,
        maxCount,
        align = "center",
        title = "Select Tags",
        onChange,
        class: cls,
        css: extraCss
      }) => {
        const globalCssId = getGlobalStylesId(tagInputCss);
        bindGlobalStyle(globalCssId, tagInputCss);
        const ref = {
          globalCssId
        };
        let currentSelection = [...selectedIndices];
        const renderTags = () => {
          const tempRef = {
            globalCssId
          };
          if (currentSelection.length === 0) {
            return /* @__PURE__ */ jsx("span", { class: "&-tag-box &-placeholder", ref: tempRef, children: placeholder });
          }
          return /* @__PURE__ */ jsx("div", { class: "&-tag-box", ref: tempRef, children: currentSelection.map((idx) => /* @__PURE__ */ jsx("div", { class: "&-tag", children: [
            /* @__PURE__ */ jsx("span", { class: "&-tag-text", children: options3[idx] }),
            !disabled && /* @__PURE__ */ jsx(
              "span",
              {
                class: "&-tag-remove",
                onClick: (e) => {
                  e.stopPropagation();
                  removeTag(idx);
                },
                children: "\xD7"
              }
            )
          ] })) });
        };
        const update = (newSelection) => {
          currentSelection = newSelection;
          dom.value = renderTags();
          onChange == null ? void 0 : onChange(
            currentSelection,
            currentSelection.map((i) => options3[i])
          );
        };
        const removeTag = (idxToRemove) => {
          if (disabled) return;
          update(currentSelection.filter((i) => i !== idxToRemove));
        };
        const openSelector = async () => {
          if (disabled) return;
          const result = await ActionSheetMultiSelectPromise({
            title,
            options: options3,
            initialSelected: currentSelection,
            align,
            maxCount,
            closeWhenClickOutside: true
          });
          update(result);
        };
        const dom = new HtmlVar(renderTags());
        let finalClass = cls || "";
        if (disabled) finalClass += " disabled";
        return /* @__PURE__ */ jsx("div", { ref, css: extraCss, class: finalClass, onClick: openSelector, children: dom.node });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/tag-input/tag-input-demo.tsx
  var tagInputDemo;
  var init_tag_input_demo = __esm({
    "node_modules/lupine.components/src/component-pool/tag-input/tag-input-demo.tsx"() {
      init_tag_input();
      init_html_var();
      init_jsx_runtime();
      tagInputDemo = {
        id: "tag-input-demo",
        text: "Tag Input",
        args: {
          options: ["Apple", "Banana", "Cherry", "Date", "Elderberry", "Fig", "Grape"],
          selectedIndices: [0, 2],
          placeholder: "Select your favorite fruits...",
          disabled: false,
          maxCount: 3,
          align: "center",
          title: "Select Fruits"
        },
        argTypes: {
          placeholder: { control: "text", description: "Placeholder when empty" },
          disabled: { control: "boolean", description: "Disable interaction" },
          maxCount: { control: "number", description: "Max number of items allowed to be selected" },
          align: { control: "select", options: ["left", "center", "right"], description: "Text alignment in selector" },
          title: { control: "text", description: "Title for the ActionSheet" }
        },
        render: (args) => {
          const msg = new HtmlVar("");
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px" }, children: [
            /* @__PURE__ */ jsx(
              TagInput,
              {
                ...args,
                onChange: (indices, labels) => {
                  msg.value = `Selected: [${labels.join(", ")}] (Indices: ${indices.join(", ")})`;
                }
              }
            ),
            /* @__PURE__ */ jsx("div", { css: { marginTop: "10px", fontSize: "13px", color: "var(--secondary-color, #999)" }, children: msg.node })
          ] });
        },
        code: `import { TagInput } from 'lupine.components/component-pool/tag-input/tag-input';

// Basic usage
<TagInput
  options={['Apple', 'Banana', 'Cherry']}
  selectedIndices={[0, 2]}
  onChange={(indices, labels) => console.log(labels)}
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/floating-icon-menu/floating-icon-menu.tsx
  var FloatingIconMenu;
  var init_floating_icon_menu = __esm({
    "node_modules/lupine.components/src/component-pool/floating-icon-menu/floating-icon-menu.tsx"() {
      init_src();
      init_jsx_runtime();
      FloatingIconMenu = (props) => {
        const css2 = {
          position: "fixed",
          display: "flex",
          alignItems: "center",
          gap: "16px",
          zIndex: "1000",
          "&.dir-up": { flexDirection: "column-reverse" },
          "&.dir-up .&-children": { flexDirection: "column-reverse" },
          "&.dir-down": { flexDirection: "column" },
          "&.dir-down .&-children": { flexDirection: "column" },
          "&.dir-left": { flexDirection: "row-reverse" },
          "&.dir-left .&-children": { flexDirection: "row-reverse" },
          "&.dir-right": { flexDirection: "row" },
          "&.dir-right .&-children": { flexDirection: "row" },
          ".&-main-btn": {
            width: "56px",
            height: "56px",
            borderRadius: "50%",
            backgroundColor: "var(--primary-color)",
            color: "var(--primary-bg-color)",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            boxShadow: "var(--cover-box-shadow, 0 4px 12px rgba(0,0,0,0.15))",
            cursor: "pointer",
            transition: "transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28), background-color 0.3s",
            fontSize: "24px",
            i: {
              transition: "transform 0.3s"
            }
          },
          // When the menu is open
          "&.is-open .&-main-btn": {
            backgroundColor: "var(--danger-color, #ff4d4f)",
            // The icon revolves
            i: {
              transform: "rotate(135deg)"
            }
          },
          ".&-children": {
            display: "flex",
            gap: "16px"
          },
          ".&-child-item": {
            width: "48px",
            height: "48px",
            borderRadius: "50%",
            backgroundColor: "var(--primary-bg-color)",
            color: "var(--primary-color)",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            boxShadow: "var(--cover-box-shadow, 0 4px 12px rgba(0,0,0,0.1))",
            cursor: "pointer",
            textDecoration: "none",
            position: "relative",
            opacity: "0",
            visibility: "hidden",
            transition: "all 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28)",
            fontSize: "20px"
          },
          "&.dir-up .&-child-item": { transform: "translateY(16px) scale(0.8)" },
          "&.dir-down .&-child-item": { transform: "translateY(-16px) scale(0.8)" },
          "&.dir-left .&-child-item": { transform: "translateX(16px) scale(0.8)" },
          "&.dir-right .&-child-item": { transform: "translateX(-16px) scale(0.8)" },
          "&.is-open .&-child-item": {
            opacity: "1",
            visibility: "visible",
            transform: "translate(0, 0) scale(1)"
          },
          ".&-child-item:hover": {
            backgroundColor: "var(--secondary-bg-color)"
          },
          ".&-text-label": {
            position: "absolute",
            backgroundColor: "var(--secondary-color)",
            color: "var(--primary-bg-color)",
            padding: "4px 8px",
            borderRadius: "6px",
            fontSize: "12px",
            whiteSpace: "nowrap",
            opacity: "0",
            pointerEvents: "none",
            transition: "all 0.3s ease"
          },
          // Label positioning classes
          "&.label-pos-left .&-text-label": {
            right: "60px",
            transform: "translateX(10px)"
          },
          "&.label-pos-right .&-text-label": {
            left: "60px",
            transform: "translateX(-10px)"
          },
          "&.label-pos-top .&-text-label": {
            bottom: "60px",
            transform: "translateY(10px)"
          },
          "&.label-pos-bottom .&-text-label": {
            top: "60px",
            transform: "translateY(-10px)"
          },
          "&.is-open.label-pos-left .&-text-label": { transform: "translateX(0)" },
          "&.is-open.label-pos-right .&-text-label": { transform: "translateX(0)" },
          "&.is-open.label-pos-top .&-text-label": { transform: "translateY(0)" },
          "&.is-open.label-pos-bottom .&-text-label": { transform: "translateY(0)" }
        };
        const globalCssId = getGlobalStylesId(css2);
        bindGlobalStyle(globalCssId, css2);
        const ref = {
          globalCssId
        };
        const toggleMenu = () => {
          const root = ref.current;
          if (root) {
            if (root.classList.contains("is-open")) {
              root.classList.remove("is-open");
            } else {
              root.classList.add("is-open");
            }
          }
          if (props.mainIcon.js) {
            props.mainIcon.js();
          }
        };
        const top = props.top;
        const left = props.left;
        const bottom = props.bottom !== void 0 ? props.bottom : top !== void 0 ? void 0 : "20px";
        const right = props.right !== void 0 ? props.right : left !== void 0 ? void 0 : "20px";
        const containerStyle = {};
        if (top !== void 0) containerStyle.top = top;
        if (left !== void 0) containerStyle.left = left;
        if (bottom !== void 0) containerStyle.bottom = bottom;
        if (right !== void 0) containerStyle.right = right;
        const direction = props.direction || "up";
        let labelPos = "left";
        if (direction === "up" || direction === "down") {
          labelPos = left !== void 0 ? "right" : "left";
        } else {
          labelPos = top !== void 0 ? "bottom" : "top";
        }
        const wrapperClass = ["floating-icon-menu", `dir-${direction}`, `label-pos-${labelPos}`, props.className].filter(Boolean).join(" ");
        return /* @__PURE__ */ jsx("div", { class: wrapperClass, style: containerStyle, ref, children: [
          /* @__PURE__ */ jsx("div", { class: "&-main-btn", onClick: toggleMenu, children: /* @__PURE__ */ jsx("i", { class: `ifc-icon ${props.mainIcon.icon}` }) }),
          /* @__PURE__ */ jsx("div", { class: "&-children", children: props.items.map((item, index) => {
            const handleClick = (e) => {
              if (item.js) {
                e.preventDefault();
                item.js();
              }
              ref.current.classList.remove("is-open");
            };
            const delay = `${index * 0.05}s`;
            return /* @__PURE__ */ jsx(
              "a",
              {
                class: "&-child-item",
                href: item.url || "javascript:void(0)",
                onClick: handleClick,
                style: { transitionDelay: delay },
                children: [
                  /* @__PURE__ */ jsx("span", { class: "&-text-label", style: { transitionDelay: delay }, children: item.text }),
                  /* @__PURE__ */ jsx("i", { class: `ifc-icon ${item.icon}` })
                ]
              }
            );
          }) })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/floating-icon-menu/floating-icon-menu-demo.tsx
  var showMsg, floatingIconMenuMainBtnMock, floatingIconMenuOptionsMock, floatingIconMenuDemo;
  var init_floating_icon_menu_demo = __esm({
    "node_modules/lupine.components/src/component-pool/floating-icon-menu/floating-icon-menu-demo.tsx"() {
      init_floating_icon_menu();
      init_notice_message();
      init_jsx_runtime();
      showMsg = (msg) => {
        NotificationMessage.sendMessage(msg, "var(--success-bg-color)" /* Success */);
      };
      floatingIconMenuMainBtnMock = {
        icon: "ma-add",
        url: "",
        text: "Options"
      };
      floatingIconMenuOptionsMock = [
        {
          icon: "ma-home-outline",
          url: "#/home",
          text: "Home",
          js: () => showMsg("Navigated to Home!")
        },
        {
          icon: "ma-tools",
          url: "#/tools",
          text: "Tools",
          js: () => showMsg("Opened Tools!")
        },
        {
          icon: "co-cil-chat-bubble",
          url: "#/chat",
          text: "Chat",
          js: () => showMsg("Chat Support Selected!")
        },
        {
          icon: "ma-crown-outline",
          url: "#/vip",
          text: "VIP",
          js: () => showMsg("VIP Lounge!")
        }
      ];
      floatingIconMenuDemo = {
        id: "floating-icon-menu-demo",
        text: "Floating Icon Menu",
        args: {
          top: "",
          bottom: "20px",
          left: "",
          right: "20px",
          direction: "up"
        },
        argTypes: {
          top: { control: "text" },
          bottom: { control: "text" },
          left: { control: "text" },
          right: { control: "text" },
          direction: {
            control: "select",
            options: ["up", "down", "left", "right"]
          }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx("div", { style: { position: "relative" }, children: [
            /* @__PURE__ */ jsx("div", { style: { padding: "20px" }, children: [
              /* @__PURE__ */ jsx("h3", { children: "Floating Action Menu Demo" }),
              /* @__PURE__ */ jsx("p", { children: [
                "Use the controls in the ",
                /* @__PURE__ */ jsx("strong", { children: "Props" }),
                " panel to adjust the position (`top`, `bottom`, `left`, `right`) and the popup `direction` (`up`, `down`, `left`, `right`)."
              ] }),
              /* @__PURE__ */ jsx("p", { style: { color: "var(--secondary-text-color)" }, children: [
                "Note: This component uses `position: fixed`, so it will appear at the specified coordinates of your",
                /* @__PURE__ */ jsx("strong", { children: "entire browser viewport" }),
                " regardless of scrolling."
              ] }),
              /* @__PURE__ */ jsx("p", { style: { color: "var(--danger-color, #ff4d4f)" }, children: [
                /* @__PURE__ */ jsx("strong", { children: "Important:" }),
                " If you set `top` or `left`, you should typically clear the default `bottom` or `right` values to avoid CSS conflicts."
              ] })
            ] }),
            /* @__PURE__ */ jsx(
              FloatingIconMenu,
              {
                mainIcon: { ...floatingIconMenuMainBtnMock, text: args.direction || "Options" },
                items: floatingIconMenuOptionsMock,
                top: args.top || void 0,
                bottom: args.bottom || void 0,
                left: args.left || void 0,
                right: args.right || void 0,
                direction: args.direction
              }
            )
          ] });
        }
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/floating-icon-menu/index.ts
  var init_floating_icon_menu2 = __esm({
    "node_modules/lupine.components/src/component-pool/floating-icon-menu/index.ts"() {
      init_floating_icon_menu();
      init_floating_icon_menu_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/tour/tour.tsx
  var Tour;
  var init_tour = __esm({
    "node_modules/lupine.components/src/component-pool/tour/tour.tsx"() {
      init_jsx_runtime();
      Tour = (props) => {
        const zIndex = props.zIndex || 9999;
        const css2 = {
          position: "fixed",
          top: 0,
          left: 0,
          width: "100vw",
          height: "100vh",
          pointerEvents: "none",
          zIndex: `${zIndex}`,
          transition: "opacity 0.3s",
          opacity: 0,
          "&.is-active": {
            opacity: 1,
            pointerEvents: "auto"
          },
          // Overlay background using SVG mask or clip-path or huge box-shadow
          // We'll use absolute elements for precise highlighting
          ".&-overlay-bg": {
            position: "absolute",
            backgroundColor: "rgba(0, 0, 0, 0.6)",
            transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
            pointerEvents: "auto"
            // intercept clicks
          },
          ".&-overlay-top": { top: 0, left: 0, right: 0 },
          ".&-overlay-bottom": { bottom: 0, left: 0, right: 0 },
          ".&-overlay-left": { left: 0 },
          ".&-overlay-right": { right: 0 },
          ".&-highlight": {
            position: "absolute",
            backgroundColor: "transparent",
            borderRadius: "4px",
            transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
            pointerEvents: "none"
          },
          ".&-popover": {
            position: "absolute",
            backgroundColor: "var(--primary-bg-color, white)",
            borderRadius: "8px",
            padding: "16px",
            width: "280px",
            boxShadow: "var(--cover-box-shadow, 0 4px 12px rgba(0,0,0,0.15))",
            transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
            color: "var(--primary-text-color, #333)",
            boxSizing: "border-box"
          },
          ".&-title": {
            fontSize: "16px",
            fontWeight: "bold",
            marginBottom: "8px",
            color: "var(--primary-color)"
          },
          ".&-content": {
            fontSize: "14px",
            lineHeight: "1.5",
            marginBottom: "16px",
            color: "var(--secondary-text-color)"
          },
          ".&-footer": {
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center"
          },
          ".&-steps-count": {
            fontSize: "12px",
            color: "var(--secondary-text-color)"
          },
          ".&-buttons": {
            display: "flex",
            gap: "8px"
          },
          ".&-btn": {
            padding: "6px 12px",
            borderRadius: "4px",
            cursor: "pointer",
            fontSize: "14px",
            border: "none",
            backgroundColor: "transparent"
          },
          ".&-btn-primary": {
            backgroundColor: "var(--primary-color, #1890ff)",
            color: "var(--primary-bg-color, white)"
          },
          ".&-btn-primary:active": {
            opacity: 0.8
          }
        };
        const ref = {};
        let currentStepIndex = 0;
        const updatePosition = () => {
          const root = ref.current;
          if (!root) return;
          if (props.steps.length === 0 || currentStepIndex >= props.steps.length) {
            root.classList.remove("is-active");
            return;
          }
          const step = props.steps[currentStepIndex];
          let targetEl = document.querySelector(step.target);
          if (!targetEl) {
            console.warn(`Tour target not found: ${step.target}`);
            targetEl = document.body;
          }
          const rect = targetEl.getBoundingClientRect();
          const hl = ref.$("&-highlight");
          const bgTop = ref.$("&-overlay-top");
          const bgBottom = ref.$("&-overlay-bottom");
          const bgLeft = ref.$("&-overlay-left");
          const bgRight = ref.$("&-overlay-right");
          const popover = ref.$("&-popover");
          const titleEl = ref.$("&-title");
          const contentEl = ref.$("&-content");
          const countEl = ref.$("&-steps-count");
          const nextBtn = ref.$("&-next-btn");
          titleEl.textContent = step.title;
          contentEl.textContent = step.content;
          countEl.textContent = `${currentStepIndex + 1} / ${props.steps.length}`;
          if (currentStepIndex === props.steps.length - 1) {
            nextBtn.textContent = "Finish";
          } else {
            nextBtn.textContent = "Next";
          }
          const padding = targetEl === document.body ? 0 : 4;
          let ht = 0, hl_l = 0, hw = 0, hh = 0;
          if (targetEl === document.body) {
            hl.style.width = "0px";
            hl.style.height = "0px";
            hl.style.top = "50%";
            hl.style.left = "50%";
            ht = window.innerHeight / 2;
            hl_l = window.innerWidth / 2;
          } else {
            ht = rect.top - padding;
            hl_l = rect.left - padding;
            hw = rect.width + padding * 2;
            hh = rect.height + padding * 2;
            hl.style.width = `${hw}px`;
            hl.style.height = `${hh}px`;
            hl.style.top = `${ht}px`;
            hl.style.left = `${hl_l}px`;
          }
          bgTop.style.height = `${ht}px`;
          bgBottom.style.top = `${ht + hh}px`;
          bgBottom.style.bottom = "0px";
          bgLeft.style.top = `${ht}px`;
          bgLeft.style.height = `${hh}px`;
          bgLeft.style.width = `${hl_l}px`;
          bgRight.style.top = `${ht}px`;
          bgRight.style.height = `${hh}px`;
          bgRight.style.left = `${hl_l + hw}px`;
          bgRight.style.right = "0px";
          const placement = step.placement || "bottom";
          const spacing = 12;
          requestAnimationFrame(() => {
            const pRect = popover.getBoundingClientRect();
            let pTop = 0;
            let pLeft = 0;
            switch (placement) {
              case "top":
                pTop = ht - spacing - pRect.height;
                pLeft = hl_l;
                break;
              case "bottom":
                pTop = ht + hh + spacing;
                pLeft = hl_l;
                break;
              case "left":
                pTop = ht;
                pLeft = hl_l - spacing - pRect.width;
                break;
              case "right":
                pTop = ht;
                pLeft = hl_l + hw + spacing;
                break;
            }
            if (pLeft + pRect.width > window.innerWidth) {
              pLeft = window.innerWidth - pRect.width - spacing;
            }
            if (pLeft < 0) {
              pLeft = spacing;
            }
            if (pTop + pRect.height > window.innerHeight) {
              pTop = window.innerHeight - pRect.height - spacing;
            }
            if (pTop < 0) {
              pTop = spacing;
            }
            popover.style.top = `${pTop}px`;
            popover.style.left = `${pLeft}px`;
            if (targetEl !== document.body) {
              targetEl.scrollIntoView({ behavior: "smooth", block: "center" });
            }
          });
        };
        setTimeout(() => {
          updatePosition();
          const root = ref.current;
          if (root) {
            root.classList.add("is-active");
          }
          window.addEventListener("resize", updatePosition);
        }, 50);
        const cleanup = () => {
          window.removeEventListener("resize", updatePosition);
        };
        const handleNext = () => {
          if (currentStepIndex < props.steps.length - 1) {
            currentStepIndex++;
            updatePosition();
          } else {
            ref.current.classList.remove("is-active");
            cleanup();
            setTimeout(() => {
              ref.current.remove();
              if (props.onFinish) props.onFinish();
            }, 300);
          }
        };
        const handleClose = () => {
          ref.current.classList.remove("is-active");
          cleanup();
          setTimeout(() => {
            ref.current.remove();
            if (props.onClose) props.onClose();
          }, 300);
        };
        return /* @__PURE__ */ jsx("div", { class: "tour", ref, css: css2, children: [
          /* @__PURE__ */ jsx("div", { class: "&-overlay-bg &-overlay-top" }),
          /* @__PURE__ */ jsx("div", { class: "&-overlay-bg &-overlay-bottom" }),
          /* @__PURE__ */ jsx("div", { class: "&-overlay-bg &-overlay-left" }),
          /* @__PURE__ */ jsx("div", { class: "&-overlay-bg &-overlay-right" }),
          /* @__PURE__ */ jsx("div", { class: "&-highlight" }),
          /* @__PURE__ */ jsx("div", { class: "&-popover", children: [
            /* @__PURE__ */ jsx("div", { class: "&-title" }),
            /* @__PURE__ */ jsx("div", { class: "&-content" }),
            /* @__PURE__ */ jsx("div", { class: "&-footer", children: [
              /* @__PURE__ */ jsx("div", { class: "&-steps-count" }),
              /* @__PURE__ */ jsx("div", { class: "&-buttons", children: [
                /* @__PURE__ */ jsx("button", { class: "&-btn", onClick: handleClose, children: "Skip" }),
                /* @__PURE__ */ jsx("button", { class: "&-btn &-btn-primary &-next-btn", onClick: handleNext, children: "Next" })
              ] })
            ] })
          ] })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/tour/tour-demo.tsx
  var tourDemo;
  var init_tour_demo = __esm({
    "node_modules/lupine.components/src/component-pool/tour/tour-demo.tsx"() {
      init_components();
      init_tour();
      init_jsx_runtime();
      tourDemo = {
        id: "tour-demo",
        text: "Tour (Guidance)",
        args: {},
        argTypes: {},
        render: () => {
          const tour = new HtmlVar();
          const handleStartTour = () => {
            const steps = [
              {
                target: "#tour-step-1",
                title: "Welcome to Lupine.js",
                content: "This is the first step of your product tour. You can highlight any element!",
                placement: "bottom"
              },
              {
                target: "#tour-step-2",
                title: "Main Feature",
                content: "Here is a key feature we want to draw your attention to.",
                placement: "right"
              },
              {
                target: "#tour-step-3",
                title: "Action Button",
                content: "Click here to perform the primary action on this page.",
                placement: "top"
              }
            ];
            tour.value = /* @__PURE__ */ jsx(
              Tour,
              {
                steps,
                onClose: () => console.log("Tour skipped or closed"),
                onFinish: () => console.log("Tour completed!")
              }
            );
          };
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px" }, children: [
            /* @__PURE__ */ jsx("h2", { children: "Tour Component Demo" }),
            /* @__PURE__ */ jsx("p", { children: "The Tour component is used to guide users through your application by highlighting specific elements." }),
            tour.node,
            /* @__PURE__ */ jsx(
              "button",
              {
                id: "tour-step-1",
                class: "ifc-btn ifc-btn-primary",
                style: { marginBottom: "40px" },
                onClick: handleStartTour,
                children: "Start Tour"
              }
            ),
            /* @__PURE__ */ jsx("div", { style: { display: "flex", gap: "20px", marginBottom: "40px" }, children: [
              /* @__PURE__ */ jsx(
                "div",
                {
                  id: "tour-step-2",
                  style: { padding: "20px", backgroundColor: "#f0f2f5", borderRadius: "8px", width: "200px" },
                  children: [
                    /* @__PURE__ */ jsx("h3", { children: "Feature Card" }),
                    /* @__PURE__ */ jsx("p", { children: "This is some pseudo content to highlight." })
                  ]
                }
              ),
              /* @__PURE__ */ jsx("div", { style: { padding: "20px", backgroundColor: "#f0f2f5", borderRadius: "8px", width: "200px" }, children: [
                /* @__PURE__ */ jsx("h3", { children: "Another Card" }),
                /* @__PURE__ */ jsx("p", { children: "This will not be highlighted." })
              ] })
            ] }),
            /* @__PURE__ */ jsx("button", { id: "tour-step-3", class: "ifc-btn ifc-btn-secondary", style: { marginTop: "100px" }, children: "Submit Action" })
          ] });
        }
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/tour/index.ts
  var init_tour2 = __esm({
    "node_modules/lupine.components/src/component-pool/tour/index.ts"() {
      init_tour();
      init_tour_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/search-input/search-input.tsx
  var SearchInput;
  var init_search_input = __esm({
    "node_modules/lupine.components/src/component-pool/search-input/search-input.tsx"() {
      init_src();
      init_jsx_runtime();
      SearchInput = (props) => {
        const css2 = {
          display: "flex",
          flex: 1,
          position: "relative",
          alignItems: "center",
          ".&-input": {
            flex: 1,
            paddingRight: "30px",
            boxSizing: "border-box",
            width: "100%",
            padding: "8px 12px",
            border: "var(--primary-border, 1px solid #d9d9d9)",
            borderRadius: "4px",
            outline: "none",
            fontSize: "14px",
            transition: "border-color 0.3s"
          },
          ".&-input:focus": {
            borderColor: "var(--primary-color, #1890ff)"
          },
          ".&-search, .&-clear": {
            position: "absolute",
            top: "50%",
            transform: "translateY(-50%)",
            cursor: "pointer",
            color: "var(--secondary-text-color, #8c8c8c)",
            transition: "color 0.3s"
          },
          ".&-search:hover": {
            color: "var(--primary-color, #1890ff)"
          },
          ".&-clear:hover": {
            color: "red"
          },
          ".&-search": {
            right: "8px",
            fontSize: "16px"
          },
          ".&-clear": {
            display: "none",
            right: "28px",
            fontSize: "18px"
          },
          "input.&-input:not(:placeholder-shown) + .&-clear": {
            display: "block"
          }
        };
        const globalCssId = getGlobalStylesId(css2);
        bindGlobalStyle(globalCssId, css2);
        const ref = {
          globalCssId
        };
        const onSearch = () => {
          const input = ref.$("&-input");
          if (input) {
            props.onSearch(input.value);
          }
        };
        const onClear = () => {
          var _a;
          const input = ref.$("&-input");
          if (input) {
            input.value = "";
          }
          (_a = props.onClear) == null ? void 0 : _a.call(props);
        };
        if (props.hook) {
          props.hook.setValue = (value) => {
            const input = ref.$("&-input");
            if (input) {
              input.value = value;
            }
          };
        }
        return /* @__PURE__ */ jsx("div", { ref, class: ["search-input", props.class].join(" ").trim(), children: [
          /* @__PURE__ */ jsx(
            "input",
            {
              type: "text",
              maxLength: 30,
              spellcheck: false,
              class: "&-input input-base",
              placeholder: props.placeholder,
              onKeyDown: (e) => {
                if (e.key === "Enter") {
                  onSearch();
                }
              },
              onBlur: () => {
                var _a;
                return (_a = props.onBlur) == null ? void 0 : _a.call(props);
              },
              onFocus: () => {
                var _a;
                return (_a = props.onFocus) == null ? void 0 : _a.call(props);
              }
            }
          ),
          /* @__PURE__ */ jsx("div", { class: "&-clear", onClick: onClear, children: /* @__PURE__ */ jsx("i", { class: "ifc-icon ma-close" }) }),
          /* @__PURE__ */ jsx("div", { class: "&-search", onClick: onSearch, children: /* @__PURE__ */ jsx("i", { class: ["ifc-icon", props.searchIcon || "bs-search"].join(" ") }) })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/search-input/search-input-demo.tsx
  var searchInputDemo;
  var init_search_input_demo = __esm({
    "node_modules/lupine.components/src/component-pool/search-input/search-input-demo.tsx"() {
      init_search_input();
      init_notice_message();
      init_jsx_runtime();
      searchInputDemo = {
        id: "search-input-demo",
        text: "Search Input",
        args: {
          placeholder: "Search here..."
        },
        argTypes: {
          placeholder: { control: "text" }
        },
        render: (args) => {
          const hook = {};
          const handleSearch = (val) => {
            if (!val) {
              NotificationMessage.sendMessage("Please enter a keyword", "var(--warning-bg-color)" /* Warning */);
              return;
            }
            NotificationMessage.sendMessage(`Searching for: ${val}`, "var(--success-bg-color)" /* Success */);
          };
          const handleClear = () => {
            NotificationMessage.sendMessage("Input cleared", "var(--info-bg-color)" /* Info */);
          };
          const handleSetValue = () => {
            if (hook.setValue) {
              hook.setValue("Lupine.js");
            }
          };
          return /* @__PURE__ */ jsx("div", { style: { padding: "20px", maxWidth: "400px" }, children: [
            /* @__PURE__ */ jsx("h3", { children: "Search Input Demo" }),
            /* @__PURE__ */ jsx("p", { children: "A simple search input component with clear button functionality." }),
            /* @__PURE__ */ jsx("div", { style: { marginBottom: "20px" }, children: /* @__PURE__ */ jsx(SearchInput, { placeholder: args.placeholder, onSearch: handleSearch, onClear: handleClear, hook }) }),
            /* @__PURE__ */ jsx("button", { class: "button-base", onClick: handleSetValue, children: "Set Value via Hook" })
          ] });
        }
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/search-input/index.ts
  var init_search_input2 = __esm({
    "node_modules/lupine.components/src/component-pool/search-input/index.ts"() {
      init_search_input();
      init_search_input_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/svg-icons.ts
  var SvgIconData, SvgIconNames, LJ_SVG_ICON_CLASS, LJ_SVG_ICON_STYLE_ID, loadSvgIconStyles;
  var init_svg_icons = __esm({
    "node_modules/lupine.components/src/component-pool/svg-icons.ts"() {
      SvgIconData = {
        // iEditor
        undo: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z'/%3E%3C/svg%3E`,
        redo: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M5.8 15.5c1.05-3.19 4.06-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L14.9 15.5h9v-9l-3.6 3.6C18.45 8.99 16.05 8 13.4 8c-4.65 0-8.58 3.03-9.96 7.22l2.36.78z'/%3E%3C/svg%3E`,
        upload: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z'/%3E%3C/svg%3E`,
        download: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z'/%3E%3C/svg%3E`,
        zoomIn: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M15.5 14h-.79l-.28-.27A6.47 6.47 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zm.5-7H9v2H7v1h2v2h1v-2h2V9h-2V7z'/%3E%3C/svg%3E`,
        zoomOut: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M15.5 14h-.79l-.28-.27A6.47 6.47 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7z'/%3E%3C/svg%3E`,
        pan: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M10 9h4V6h3l-5-5-5 5h3v3zm-1 1H6V7l-5 5 5 5v-3h3v-4zm14 2l-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3H7l5 5 5-5h-3v-3z'/%3E%3C/svg%3E`,
        select: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Crect fill='none' stroke='currentColor' stroke-width='2' stroke-dasharray='4 2' x='4' y='4' width='16' height='16'/%3E%3Ccircle fill='currentColor' cx='4' cy='4' r='2'/%3E%3Ccircle fill='currentColor' cx='20' cy='4' r='2'/%3E%3Ccircle fill='currentColor' cx='4' cy='20' r='2'/%3E%3Ccircle fill='currentColor' cx='20' cy='20' r='2'/%3E%3C/svg%3E`,
        crop: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M17 15h2V7c0-1.1-.9-2-2-2H9v2h8v8zM7 17V1H5v4H1v2h4v10c0 1.1.9 2 2 2h10v4h2v-4h4v-2H7z'/%3E%3C/svg%3E`,
        rotate: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6zm6.76 1.74L17.3 9.2c.44.84.7 1.79.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26z'/%3E%3C/svg%3E`,
        resize: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M19 12h-2v3h-3v2h5v-5zM7 9h3V7H5v5h2V9zm14-6H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02z'/%3E%3C/svg%3E`,
        pencil: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z'/%3E%3C/svg%3E`,
        draw: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z'/%3E%3C/svg%3E`,
        mosaic: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M12 4.9688h7.0313v7.0312H12zM4.9688 12h7.0312v7.0313H4.9688z'/%3E%3Cpath fill='currentColor' d='M19.0313 23.25H4.9688a4.2188 4.2188 0 0 1-4.2188-4.2188V4.9688a4.2188 4.2188 0 0 1 4.2188-4.2188h14.0625a4.2188 4.2188 0 0 1 4.2187 4.2188v14.0625a4.2188 4.2188 0 0 1-4.2188 4.2187zM4.9688 3.5625a1.4063 1.4063 0 0 0-1.4063 1.4063v14.0625a1.4063 1.4063 0 0 0 1.4063 1.4062h14.0625a1.4063 1.4063 0 0 0 1.4062-1.4062V4.9688a1.4063 1.4063 0 0 0-1.4062-1.4063z'/%3E%3C/svg%3E`,
        text: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M2.5 4v3h5v12h3V7h5V4h-13zm19 5h-9v3h3v7h3v-7h3V9z'/%3E%3C/svg%3E`,
        sticker: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Ccircle cx='12' cy='12' r='10' fill='none' stroke='currentColor' stroke-width='2'/%3E%3Cpolygon fill='currentColor' points='12,4 13.9,9.8 20,9.8 15.1,13.4 17,19.2 12,15.6 7,19.2 8.9,13.4 4,9.8 10.1,9.8'/%3E%3C/svg%3E`,
        merge: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M17 1H7c-1.1 0-2 .9-2 2v18l7-3 7 3V3c0-1.1-.9-2-2-2z'/%3E%3C/svg%3E`,
        paste: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M19 2h-4.18C14.4.84 13.3 0 12 0c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z'/%3E%3C/svg%3E`,
        rotateHandle: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Ccircle fill='none' stroke='currentColor' stroke-width='2' cx='12' cy='12' r='9'/%3E%3Cpath fill='currentColor' d='M12 3v4l4-4-4-4v4z'/%3E%3C/svg%3E`,
        adjust: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M19 10h-2V8h-2V6h2V4h2v2h2v2h-2v2zm-4 7h-2v-2h-2v-2h2v-2h2v2h2v2h-2v2zM5 14h2v-2h2v-2H7V8H5v2H3v2h2v2z'/%3E%3C/svg%3E`,
        round: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14zM8 8h8v8H8z'/%3E%3C/svg%3E`,
        frame: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Crect x='5' y='2' width='14' height='20' fill='none' stroke='currentColor' stroke-width='2'/%3E%3Crect x='8' y='5' width='8' height='14' fill='none' stroke='currentColor' stroke-width='1'/%3E%3C/svg%3E`,
        rotL: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.78-4.95-2.05L6.64 16.35C8.27 17.98 10.51 19 13 19c3.87 0 7-3.13 7-7s-3.13-7-7-7z'/%3E%3C/svg%3E`,
        rotR: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M11 3c4.97 0 9 4.03 9 9H23l-3.89 3.89-0.07 0.14L15 12H18c0-3.87-3.13-7-7-7s-7 3.13-7 7 3.13 7 7 7c1.93 0 3.68-0.78 4.95-2.05L17.36 16.35C15.73 17.98 13.49 19 11 19c-3.87 0-7-3.13-7-7s3.13-7 7-7z'/%3E%3C/svg%3E`,
        flipH: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M15 21h2v-2h-2v2zm4-12h2V7h-2v2zM3 5v14c0 1.1.9 2 2 2h4v-2H5V5h4V3H5c-1.1 0-2 .9-2 2zm16-2v2h2c0-1.1-.9-2-2-2zm-8 20h2V1h-2v22zm8-6h2v-2h-2v2zM15 5h2V3h-2v2zm4 8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2z'/%3E%3C/svg%3E`,
        flipV: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M3 15l0 2 2 0 0-2-2 0z m12 4l0 2L17 21l0-2-2 0zM19 3l-14 0c-1.1 0-2 0.9-2 2l0 4 2 0L5 5 19 5l0 4L21 9 21 5c0-1.1-0.9-2-2-2z m2 16l-2 0 0 2c1.1 0 2-0.9 2-2z m-20-8l0 2L23 13l0-2-22 0z m6 8l0 2 2 0 0-2-2 0zM19 15l0 2L21 17l0-2-2 0z m-8 4l0 2 2 0 0-2-2 0z m-8 0c0 1.1 0.9 2 2 2l0-2-2 0z'/%3E%3C/svg%3E`,
        circle: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Ccircle cx='12' cy='12' r='8' fill='currentColor'/%3E%3C/svg%3E`,
        heart: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z'/%3E%3C/svg%3E`,
        bw: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M12 22c5.52 0 10-4.48 10-10S17.52 2 12 2 2 6.48 2 12s4.48 10 10 10zm1-17.93c3.9.49 7 3.85 7 7.93s-3.1 7.44-7 7.93V4.07z'/%3E%3C/svg%3E`,
        layerUp: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M8 11h3v10h2V11h3l-4-4-4 4zM4 3v2h16V3H4z'/%3E%3C/svg%3E`,
        layerDown: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='currentColor' d='M16 13h-3V3h-2v10H8l4 4 4-4zM4 19v2h16v-2H4z'/%3E%3C/svg%3E`,
        // hEditor
        bold: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z'/%3E%3C/svg%3E`,
        italic: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M10 5v3h2.2l-3.4 8H6v3h8v-3h-2.2l3.4-8H18V5h-8z'/%3E%3C/svg%3E`,
        underline: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M12 17c3.31 0 6-2.69 6-6V3h-2.5v8c0 1.93-1.57 3.5-3.5 3.5S8.5 12.93 8.5 11V3H6v8c0 3.31 2.69 6 6 6zm-7 2v2h14v-2H5z'/%3E%3C/svg%3E`,
        strikethrough: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M13.8 21H10.2a0.9 0.9 0 0 1 0-1.8h0.9V4.8H5.7V5.7A0.9 0.9 0 0 1 3.9 5.7V3.9A0.9 0.9 0 0 1 4.8 3H19.2a0.9 0.9 0 0 1 0.9 0.9V5.7a0.9 0.9 0 0 1-1.8 0V4.8H12.9V19.2h0.9a0.9 0.9 0 0 1 0 1.8Z'/%3E%3Cpath fill='black' d='M20.1 12.9H3.9a0.9 0.9 0 0 1 0-1.8H20.1a0.9 0.9 0 0 1 0 1.8Z'/%3E%3C/svg%3E`,
        left: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z'/%3E%3C/svg%3E`,
        center: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z'/%3E%3C/svg%3E`,
        right: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zM3 3v2h18V3H3z'/%3E%3C/svg%3E`,
        justify: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M3 21h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18V7H3v2zM3 3v2h18V3H3z'/%3E%3C/svg%3E`,
        ol: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z'/%3E%3C/svg%3E`,
        ul: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M4 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-6c-.83 0-1.5.67-1.5 1.5S3.17 7.5 4 7.5 5.5 6.83 5.5 6 4.83 4.5 4 4.5zm0 12c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5zM7 19h14v-2H7v2zm0-6h14v-2H7v2zm0-8v2h14V5H7z'/%3E%3C/svg%3E`,
        indent: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M3 21h18v-2H3v2zM3 8.11l4 3.89-4 3.89v-7.78zM11 15h10v-2H11v2zm0-4h10V9H11v2zm-8-8v2h18V3H3z'/%3E%3C/svg%3E`,
        outdent: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M11 15h10v-2H11v2zm0-4h10V9H11v2zm-4 .89l4-3.89v7.78l-4-3.89zM3 21h18v-2H3v2zM3 3v2h18V3H3z'/%3E%3C/svg%3E`,
        removeformat: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M15.14 3c-.51 0-1.02.2-1.41.59L4.59 12.73c-.78.78-.78 2.05 0 2.83l3.54 3.54c.39.39.9.59 1.41.59H20v-2h-3.15l5.56-5.56c.78-.78.78-2.05 0-2.83l-3.54-3.54c-.39-.39-.9-.59-1.41-.59v0zm-.01 2l3.53 3.53-2.83 2.83-3.53-3.53 2.83-2.83zm-4.24 4.24l3.53 3.53-3.53 3.53H7.36l-3.54-3.54 7.07-7.06z'/%3E%3C/svg%3E`,
        textColor: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M9.62 12L12 5.67 14.38 12H9.62zM11 3L5.5 17h2.25l1.12-3h6.25l1.12 3h2.25L13 3h-2zm-9 17h20v2H2v-2z'/%3E%3C/svg%3E`,
        backColor: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M16.56 8.94L7.62 0 6.21 1.41l2.38 2.38-5.15 5.15c-.59.59-.59 1.54 0 2.12l5.5 5.5c.29.29.68.44 1.06.44s.77-.15 1.06-.44l5.5-5.5c.59-.58.59-1.53 0-2.12zM5.21 10L10 5.21 14.79 10H5.21zM19 11.5s-2 2.17-2 3.5c0 1.1.9 2 2 2s2-.9 2-2c0-1.33-2-3.5-2-3.5zM2 20h20v4H2v-4z'/%3E%3C/svg%3E`,
        image: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z'/%3E%3C/svg%3E`,
        link: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z'/%3E%3C/svg%3E`,
        unlink: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M17 7h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1 0 1.43-.98 2.63-2.31 2.98l1.46 1.46C20.88 15.61 22 13.95 22 12c0-2.76-2.24-5-5-5zm-1 4h-2.19l2 2H16zM2 4.27l3.11 3.11C3.29 8.12 2 9.91 2 12c0 2.76 2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1 0-1.59 1.18-2.9 2.72-3.08L9.73 12H8v2h3.73l6 6 1.27-1.27L3.27 3 2 4.27z'/%3E%3C/svg%3E`,
        html: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z'/%3E%3C/svg%3E`
        // undo: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z'/%3E%3C/svg%3E`,
        // redo: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='black' d='M5.8 15.5c1.05-3.19 4.06-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L14.9 15.5h9v-9l-3.6 3.6C18.45 8.99 16.05 8 13.4 8c-4.65 0-8.58 3.03-9.96 7.22l2.36.78z'/%3E%3C/svg%3E`,
      };
      SvgIconNames = Object.fromEntries(Object.keys(SvgIconData).map((key) => [key, key]));
      LJ_SVG_ICON_CLASS = "lj_svg_icon";
      LJ_SVG_ICON_STYLE_ID = "lj_svg_icon_style";
      loadSvgIconStyles = () => {
        if (typeof document === "undefined" || document.getElementById(LJ_SVG_ICON_STYLE_ID)) return;
        let iconStyles = "";
        for (const key of Object.keys(SvgIconData)) {
          iconStyles += `.${LJ_SVG_ICON_CLASS}_${key} { mask-image: url("${SvgIconData[key]}"); }
`;
        }
        const style = document.createElement("style");
        style.id = LJ_SVG_ICON_STYLE_ID;
        style.innerHTML = `
      .${LJ_SVG_ICON_CLASS} {
        display: inline-block;
        width: 24px;
        height: 24px;
        vertical-align: middle;
        mask-repeat: no-repeat;
        mask-position: center;
        background-color: var(--primary-color, #ccc);
        overflow:hidden;
        mask-size: contain;
      }
      .${LJ_SVG_ICON_CLASS}:hover, .${LJ_SVG_ICON_CLASS}.active {
        background-color: var(--primary-accent-color, #0a74c9);
      }
      ${iconStyles}
    `;
        document.head.appendChild(style);
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/h-editor/h-editor.ts
  var HEditorLangEn, HEditorLangCn, HEditorLabel, hEditorUniqueId, HEditor, HEditorPluginFont, HEditorPluginBasic, HEditorPluginColor, HEditorPluginImage, HEditorPluginLink, HEditorPluginHtml, HEditorPluginUndo;
  var init_h_editor = __esm({
    "node_modules/lupine.components/src/component-pool/h-editor/h-editor.ts"() {
      init_src();
      init_svg_icons();
      HEditorLangEn = {
        name: "EN",
        Size: "Size",
        fontsize: "Font Size",
        bold: "Bold",
        italic: "Italic",
        underline: "Underline",
        left: "Left Align",
        center: "Center Align",
        right: "Right Align",
        justify: "Justify Align",
        ol: "Insert Ordered List",
        ul: "Insert Unordered List",
        strikethrough: "Strike Through",
        indent: "Indent Text",
        outdent: "Remove Indent",
        removeformat: "Remove Formatting",
        textColor: "Text Color",
        backColor: "Background Color",
        image: "Image",
        undo: "Undo",
        redo: "Redo",
        Link: "Edit Link",
        UnLink: "Remove Link",
        OK: "OK",
        Cancel: "Cancel"
      };
      HEditorLangCn = {
        name: "CN",
        Size: "\u5B57\u53F7",
        fontsize: "\u5B57\u53F7",
        bold: "\u7C97\u4F53",
        italic: "\u659C\u4F53",
        underline: "\u4E0B\u5212\u7EBF",
        left: "\u5DE6\u5BF9\u9F50",
        center: "\u5C45\u4E2D\u5BF9\u9F50",
        right: "\u53F3\u5BF9\u9F50",
        justify: "\u4E24\u7AEF\u5BF9\u9F50",
        ol: "\u63D2\u5165\u6709\u5E8F\u5217\u8868",
        ul: "\u63D2\u5165\u65E0\u5E8F\u5217\u8868",
        strikethrough: "\u5220\u9664\u7EBF",
        indent: "\u7F29\u8FDB",
        outdent: "\u53D6\u6D88\u7F29\u8FDB",
        removeformat: "\u6E05\u9664\u683C\u5F0F",
        textColor: "\u6587\u672C\u989C\u8272",
        backColor: "\u80CC\u666F\u989C\u8272",
        image: "\u56FE\u7247",
        undo: "\u64A4\u9500",
        redo: "\u91CD\u505A",
        Link: "\u7F16\u8F91\u94FE\u63A5",
        UnLink: "\u79FB\u9664\u94FE\u63A5",
        OK: "\u786E\u5B9A",
        Cancel: "\u53D6\u6D88"
      };
      HEditorLabel = {};
      hEditorUniqueId = uniqueIdGenerator("he-");
      HEditor = class _HEditor {
        static _plugins = {};
        static _lang = HEditorLangEn;
        static _label = HEditorLabel;
        static iconColor = "#1384d1";
        static _PickupImageHook;
        selector;
        m_buttons = [];
        constructor(selector, html2, m_buttons, lang) {
          this.selector = selector;
          this.m_buttons = m_buttons;
          _HEditor._lang = lang || _HEditor._lang;
          this.init(html2);
          window.HEditor = _HEditor;
        }
        static setLang(lang) {
          _HEditor._lang = lang;
        }
        static setLabel(label) {
          _HEditor._label = label;
        }
        static setIconColor(color) {
          _HEditor.iconColor = color;
        }
        static setPickupImageHook(hook) {
          _HEditor._PickupImageHook = hook;
        }
        static lang(key) {
          return _HEditor._lang[key] || key;
        }
        static label(key) {
          return _HEditor._label[key] || key;
        }
        static addPlugin(name, plugin) {
          _HEditor._plugins[name.toUpperCase()] = plugin;
        }
        static getEditor(selector, html2, m_buttons, lang) {
          const dom = typeof selector === "string" ? document.querySelector(selector) : selector;
          if (!dom) {
            console.warn(`HEditor: ${selector} not found`);
            return;
          }
          const domAny = dom;
          if (domAny._edt) {
            return domAny._edt;
          }
          const edt = new _HEditor(selector, html2, m_buttons, lang);
          domAny._edt = edt;
          return edt;
        }
        static getEditorById(eid) {
          const dom = document.querySelector(`[_eid="${eid}"]`);
          if (!dom || !dom._edt) {
            console.warn(`HEditor: ${eid} not found`);
            return;
          }
          return dom._edt;
        }
        static processSelectedChanged(obj, edtId, pluginname, btnid) {
          const editor = _HEditor.getEditorById(edtId);
          const plugin = _HEditor._plugins[pluginname.toUpperCase()];
          plugin.onSelectedChanged(editor, plugin, btnid, obj.options[obj.selectedIndex].text, obj.value);
          obj.selectedIndex = 0;
        }
        static processButtonClick(obj, edtId, pluginname, btnid) {
          const editor = _HEditor.getEditorById(edtId);
          const plugin = _HEditor._plugins[pluginname.toUpperCase()];
          plugin.onButtonClick(editor, plugin, btnid);
        }
        m_id = "";
        m_doc;
        m_win;
        m_p;
        m_ifrm;
        m_focus = false;
        m_range;
        m_savedRange = null;
        m_drag;
        m_pickingColor = false;
        onBlur() {
          this.m_focus = false;
        }
        onFocus() {
          this.m_focus = true;
          this.m_range = null;
        }
        onMDown(e) {
          if (this.m_pickingColor) {
            e.preventDefault();
            this.m_pickingColor = false;
          }
          this.m_focus = true;
          const tg = e.target;
          const tgname = tg.nodeName.toUpperCase();
          if (this.m_drag && this.m_drag.o) {
            this.m_drag.o.style.cursor = this.m_drag.c;
            this.m_drag = null;
          }
          if (tgname == "IMG") {
            this.selObj(tg);
            this.m_drag = {
              ty: -1,
              o: tg,
              x: e.clientX,
              y: e.clientY,
              w: tg.offsetWidth,
              h: tg.offsetHeight,
              // op: tg.style.opacity,
              // b: tg.style.border,
              c: tg.style.cursor
            };
            const r = tg.getBoundingClientRect();
            if (e.clientX >= r.right - 10 || e.clientY >= r.bottom - 10) {
              e.preventDefault();
              this.m_drag.ty = 0;
            }
          }
        }
        onMMove(e) {
          var _a;
          const tg = e.target;
          const tgname = tg.nodeName.toUpperCase();
          const press = e.buttons == 1;
          if (this.m_drag && this.m_drag.o) {
            if (this.m_drag.ty >= 0) {
              if (!press) return this.onMUp(e);
            }
            if (this.m_drag.ty !== -1) {
              (_a = window.getSelection()) == null ? void 0 : _a.removeAllRanges();
            }
            if (this.m_drag.ty == 0) {
              e.preventDefault();
              this.m_drag.ty = 1;
            } else if (this.m_drag.ty < 0 && press) {
              if (e.clientX != this.m_drag.x || e.clientY != this.m_drag.y) {
                this.m_drag.o.style.cursor = this.m_drag.c;
              }
            }
            if (this.m_drag.ty == 1) {
              let ww = this.m_drag.w + e.clientX - this.m_drag.x;
              let hh = this.m_drag.h + e.clientY - this.m_drag.y;
              if (ww < 5) ww = 5;
              if (hh < 5) hh = 5;
              this.m_drag.o.width = ww;
              this.m_drag.o.height = hh;
            }
          }
          if (tgname == "IMG") {
            const r = tg.getBoundingClientRect();
            if (e.clientX >= r.right - 10 && e.clientY <= r.bottom - 20) {
              tg.style.cursor = "w-resize";
            } else if (e.clientX <= r.right - 20 && e.clientY >= r.bottom - 10) {
              tg.style.cursor = "ns-resize";
            } else if (e.clientX >= r.right - 20 && e.clientY >= r.bottom - 20) {
              tg.style.cursor = "nw-resize";
            } else {
              tg.style.cursor = "";
            }
          }
        }
        onMUp(e) {
          const tg = e.target;
          const tgname = tg.nodeName.toUpperCase();
          if (this.m_drag && this.m_drag.o) {
            this.m_drag.o.style.cursor = this.m_drag.c;
            this.m_drag.ty = -1;
          }
          if (tgname == "IMG") {
            this.selObj(tg);
          }
        }
        onDblClick() {
        }
        setFocus() {
          this.m_win.focus();
          this.onFocus();
        }
        onBeforedeactivate() {
          this.m_range = this.m_doc.selection.createRange();
          this.m_focus = false;
        }
        execCommand(cmd, args) {
          this.setFocus();
          this.m_doc.execCommand(cmd, false, args);
        }
        pickupColor(callback) {
          const sel = this.m_win.getSelection();
          if (sel && sel.rangeCount > 0) {
            this.m_savedRange = sel.getRangeAt(0).cloneRange();
          }
          const input = document.querySelector(`.${this.m_id}_color`);
          this.m_pickingColor = true;
          const apply = () => {
            this.setFocus();
            if (this.m_savedRange) {
              const restoreSel = this.m_win.getSelection();
              if (restoreSel) {
                restoreSel.removeAllRanges();
                restoreSel.addRange(this.m_savedRange);
              }
            }
            callback(input.value);
            const afterSel = this.m_win.getSelection();
            if (afterSel && afterSel.rangeCount > 0) {
              this.m_savedRange = afterSel.getRangeAt(0).cloneRange();
            }
          };
          input.oninput = apply;
          input.onchange = () => {
            apply();
            setTimeout(() => {
              this.m_pickingColor = false;
            }, 200);
          };
          input.click();
        }
        pickupImage(callback) {
          if (!_HEditor._PickupImageHook) {
            alert("HEditor: PickupImageHook not set");
            return;
          }
          _HEditor._PickupImageHook(callback);
        }
        init(html2) {
          const dom = typeof this.selector === "string" ? document.querySelector(this.selector) : this.selector;
          if (!dom) {
            console.warn(`HEditor: ${this.selector} not found`);
            return;
          }
          let _eid = dom.getAttribute("_eid");
          if (!_eid) {
            _eid = hEditorUniqueId();
            dom.setAttribute("_eid", _eid);
          }
          this.m_id = _eid;
          loadSvgIconStyles();
          const s = `<div id="${_eid}_pp" style="display:flex;flex-direction:column;height:100%;width:100%;position:relative;">
<style>
.h_edt_box {
  display:flex;cursor:pointer;border: 1px solid #aaaaaa;background-color:#efefef;
}
.h_edt_box:hover {
  filter: brightness(0.8);
}
.h_edt_box > div {
  display: flex;align-items: center;padding: 0 1px;
}
.h-editor-top-box .${LJ_SVG_ICON_CLASS} {
  background-color: ${_HEditor.iconColor};width: 18px;height: 18px;
}
</style>
<div class='h-editor-top-box' id="${_eid}_p" style="flex: 0 0 auto;width:100%;border: 1px solid #ccc;display:flex;font-size:14px;color:#333;flex-wrap:wrap;"></div>
<input style='height:0;width:0;padding:0;margin:0;border:0;' class='${_eid}_color' type='color' />
<iframe id="${_eid}_ifrm" style="flex: 1 1 auto;min-height:0;width:100%;border: 1px solid #ccc;" allowTransparency="true" scrolling="auto" frameborder=0></iframe>
</div>`;
          dom.innerHTML = s;
          this.m_p = dom.querySelector(`#${_eid}_p`);
          this.m_ifrm = dom.querySelector(`#${_eid}_ifrm`);
          this.reset(html2);
          this.setPanel();
          dom.style.resize = "both";
          dom.style.overflow = "auto";
        }
        reset(html2) {
          const fd = this.m_ifrm.contentDocument || this.m_ifrm.contentWindow.document;
          fd.designMode = "On";
          fd.open();
          fd.write(
            `<html><head></head><body style="margin:0!important;background-color:transparent!important;width:100%;height:100%;">${html2 || "<br>"}</body></html>`
          );
          fd.close();
          this.m_doc = fd;
          this.m_win = this.m_ifrm.contentWindow;
          this.m_win.addEventListener("blur", this.onBlur.bind(this));
          this.m_win.addEventListener("focus", this.onFocus.bind(this));
          this.m_doc.addEventListener("mousedown", this.onMDown.bind(this));
          this.m_doc.addEventListener("mousemove", this.onMMove.bind(this));
          this.m_doc.addEventListener("mouseup", this.onMUp.bind(this));
          this.m_win.addEventListener("dblclick", this.onDblClick.bind(this));
        }
        setPanel() {
          let s = "";
          if (this.m_buttons && this.m_buttons.length > 0) {
            for (const btn of this.m_buttons) {
              for (const k in _HEditor._plugins) {
                s += this.createPanel(k, _HEditor._plugins[k].buttons, btn);
              }
            }
          } else {
            for (const k in _HEditor._plugins) {
              s += this.createPanel(k, _HEditor._plugins[k].buttons);
            }
          }
          this.m_p.innerHTML = s;
        }
        createPanel(pluginname, btns, onebutton) {
          let s = "";
          for (const btnId in btns) {
            if (onebutton && btnId != onebutton) continue;
            const btn = btns[btnId];
            if (btnId == "-") {
              s += '<br style="clear:both;">';
            } else if (btn.list) {
              s += `<div style="" title="${_HEditor.lang(btn.name)}"><select onchange="HEditor.processSelectedChanged(this,'${this.m_id}', '${pluginname}','${btnId}')" style="${btn.width ? "width:" + btn.width + ";" : ""}">`;
              for (const k in btn.list) {
                s += `<option value="${k}">${_HEditor.lang(btn.list[k])}</option>`;
              }
              s += "</select></div>";
            } else {
              const lab = _HEditor.label(btn.label);
              s += `<div class='h_edt_box' style="${btn.style || ""}"><div title="${_HEditor.lang(btn.name)}" onclick="HEditor.processButtonClick(this,'${this.m_id}','${pluginname}','${btnId}')">${lab}</div></div>`;
            }
          }
          return s;
        }
        getHtml() {
          return this.m_doc.body.innerHTML;
        }
        setHtml(html2) {
          this.m_doc.body.innerHTML = html2 || "<br>";
        }
        pasteHTML(html2) {
          this.setFocus();
          this.m_doc.execCommand("InsertHtml", false, html2);
        }
        selObj(obj) {
          window.setTimeout(() => {
            const selection = this.m_win.getSelection();
            const range = this.m_doc.createRange();
            range.selectNode(obj);
            selection.removeAllRanges();
            selection.addRange(range);
          }, 100);
        }
        getCurrentLink() {
          var _a;
          const sel = this.m_win.getSelection();
          if (!sel || sel.rangeCount === 0) return null;
          const node = sel.anchorNode;
          if (!node) return null;
          const link2 = (_a = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement) == null ? void 0 : _a.closest("a");
          return link2;
        }
        showPanel(html2) {
          var _a;
          if (!html2) {
            (_a = this.m_p.parentNode.querySelector(`#${this.m_id}_userpanel`)) == null ? void 0 : _a.remove();
            return;
          }
          const panel = document.createElement("div");
          panel.innerHTML = html2;
          panel.id = `${this.m_id}_userpanel`;
          panel.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;z-index:10000;background-color:#d3d1d1fc;";
          this.m_p.parentNode.appendChild(panel);
          return panel;
        }
      };
      HEditorPluginFont = {
        name: "font",
        buttons: {
          fontsize: {
            name: "fontsize",
            label: "Size",
            command: "fontsize",
            width: "50px",
            list: {
              "0": "Size",
              // '32px': '32px (H1)',
              // '24px': '24px (H2)',
              // '18.7px': '18.7px (H3)',
              // '16px': '16px (H4, P)',
              // '13.2px': '13.2px (H5)',
              // '10.7px': '10.7px (H6)',
              1: "1&nbsp;(10px)",
              2: "2&nbsp;(13px)",
              3: "3&nbsp;(16px)",
              4: "4&nbsp;(18px)",
              5: "5&nbsp;(24px)",
              6: "6&nbsp;(32px)"
            }
          }
          // fontplus: {
          //   name: 'fontplus',
          //   label: 'A+',
          // },
          // fontminus: {
          //   name: 'fontminus',
          //   label: 'A-',
          // },
        },
        onSelectedChanged: (editor, plugin, btnid, selText, selValue) => {
          if (btnid == "fontsize") {
            if (selValue) {
              editor.execCommand("fontsize", selValue);
            }
          }
        }
        // onButtonClick: (editor: HEditor, plugin: HEditorPluginProps, btnid: string) => {
        //   if (btnid == 'fontplus') {
        //     editor.setFocus();
        //     editorApplySize(editor.m_win, editor.m_doc, +1);
        //   } else if (btnid == 'fontminus') {
        //     editor.setFocus();
        //     editorApplySize(editor.m_win, editor.m_doc, -1);
        //   }
        // },
      };
      HEditor.addPlugin(HEditorPluginFont.name, HEditorPluginFont);
      HEditorPluginBasic = {
        name: "basic",
        buttons: {
          bold: {
            name: "bold",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.bold}"></span>`
          },
          italic: {
            name: "italic",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.italic}"></span>`
          },
          underline: {
            name: "underline",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.underline}"></span>`
          },
          strikethrough: {
            name: "strikethrough",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.strikethrough}"></span>`
          },
          left: {
            name: "left",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.left}"></span>`,
            style: "margin-left: 3px"
          },
          center: {
            name: "center",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.center}"></span>`
          },
          right: {
            name: "right",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.right}"></span>`
          },
          justify: {
            name: "justify",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.justify}"></span>`
          },
          ol: {
            name: "ol",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.ol}"></span>`,
            style: "margin-left: 3px"
          },
          ul: {
            name: "ul",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.ul}"></span>`
          },
          indent: {
            name: "indent",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.indent}"></span>`
          },
          outdent: {
            name: "outdent",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.outdent}"></span>`
          },
          removeformat: {
            name: "removeformat",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.removeformat}"></span>`,
            style: "margin-left: 3px;margin-right: 3px;"
          }
        },
        onButtonClick: (editor, plugin, btnid) => {
          if (btnid == "bold") {
            editor.execCommand("bold");
          } else if (btnid == "italic") {
            editor.execCommand("italic");
          } else if (btnid == "underline") {
            editor.execCommand("underline");
          } else if (btnid == "left") {
            editor.execCommand("justifyleft");
          } else if (btnid == "center") {
            editor.execCommand("justifycenter");
          } else if (btnid == "right") {
            editor.execCommand("justifyright");
          } else if (btnid == "justify") {
            editor.execCommand("justifyfull");
          } else if (btnid == "ol") {
            editor.execCommand("insertorderedlist", "OL");
          } else if (btnid == "ul") {
            editor.execCommand("insertunorderedlist", "UL");
          } else if (btnid == "strikethrough") {
            editor.execCommand("strikeThrough");
          } else if (btnid == "removeformat") {
            editor.execCommand("removeformat");
          } else if (btnid == "indent") {
            editor.execCommand("indent");
          } else if (btnid == "outdent") {
            editor.execCommand("outdent");
          }
        }
      };
      HEditor.addPlugin(HEditorPluginBasic.name, HEditorPluginBasic);
      HEditorPluginColor = {
        name: "color",
        buttons: {
          textColor: {
            name: "textColor",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.textColor}"></span>`
          },
          backColor: {
            name: "backColor",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.backColor}"></span>`
          }
        },
        onButtonClick: (editor, plugin, btnid) => {
          if (btnid == "textColor") {
            editor.pickupColor((color) => {
              editor.execCommand("forecolor", color);
            });
          } else if (btnid == "backColor") {
            editor.pickupColor((color) => {
              editor.execCommand("hilitecolor", color);
            });
          }
        }
      };
      HEditor.addPlugin(HEditorPluginColor.name, HEditorPluginColor);
      HEditorPluginImage = {
        name: "image",
        buttons: {
          image: {
            name: "image",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.image}"></span>`,
            style: "margin-left: 3px;"
          }
        },
        onButtonClick: (editor, plugin, btnid) => {
          if (btnid == "image") {
            editor.pickupImage(async (url) => {
              editor.execCommand("insertImage", [url]);
            });
          }
        }
      };
      HEditor.addPlugin(HEditorPluginImage.name, HEditorPluginImage);
      HEditorPluginLink = {
        name: "link",
        buttons: {
          link: {
            name: "Link",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.link}"></span>`
          },
          unlink: {
            name: "Unlink",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.unlink}"></span>`
          }
        },
        onButtonClick: (editor, plugin, btnid) => {
          var _a, _b;
          if (btnid == "link") {
            const link2 = editor.getCurrentLink();
            const linkValue = (link2 == null ? void 0 : link2.getAttribute("href")) || "";
            const panel = editor.showPanel(
              `<div><button onclick="HEditor.processButtonClick(this,'${editor.m_id}','link','ok')">${HEditor.lang(
                "OK"
              )}</button><button onclick="HEditor.processButtonClick(this,'${editor.m_id}','link','cancel')">${HEditor.lang(
                "Cancel"
              )}</button></div>
        <input style='width:100%;' value='${linkValue}' />`
            );
            plugin.panel = panel;
          } else if (btnid == "unlink") {
            editor.execCommand("unlink");
          } else if (btnid == "ok") {
            const value = (_b = (_a = plugin.panel) == null ? void 0 : _a.querySelector("input")) == null ? void 0 : _b.value;
            if (!value) {
              editor.execCommand("unlink");
              return;
            }
            editor.showPanel("");
            const link2 = editor.getCurrentLink();
            if (link2) {
              link2.setAttribute("href", value);
              return;
            }
            editor.execCommand("createLink", value);
          } else if (btnid == "cancel") {
            editor.showPanel("");
          }
        }
      };
      HEditor.addPlugin(HEditorPluginLink.name, HEditorPluginLink);
      HEditorPluginHtml = {
        name: "html",
        buttons: {
          html: {
            name: "html",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.html}"></span>`,
            style: "margin-left: 3px;"
          }
        },
        onButtonClick: (editor, plugin, btnid) => {
          var _a, _b;
          if (btnid == "html") {
            const panel = editor.showPanel(
              `<div><button onclick="HEditor.processButtonClick(this,'${editor.m_id}','html','ok')">${HEditor.lang(
                "OK"
              )}</button><button onclick="HEditor.processButtonClick(this,'${editor.m_id}','html','cancel')">${HEditor.lang(
                "Cancel"
              )}</button></div>
        <textarea style='flex:1;'>${editor.getHtml()}</textarea>`
            );
            plugin.panel = panel;
          } else if (btnid == "ok") {
            editor.showPanel("");
            editor.setHtml(((_b = (_a = plugin.panel) == null ? void 0 : _a.querySelector("textarea")) == null ? void 0 : _b.value) || "");
          } else if (btnid == "cancel") {
            editor.showPanel("");
          }
        }
      };
      HEditor.addPlugin(HEditorPluginHtml.name, HEditorPluginHtml);
      HEditorPluginUndo = {
        name: "undo",
        buttons: {
          undo: {
            name: "undo",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.undo}"></span>`,
            style: "margin-left: 3px"
          },
          redo: {
            name: "redo",
            label: `<span class="${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames.redo}"></span>`
          }
        },
        onButtonClick: (editor, plugin, btnid) => {
          if (btnid == "undo") {
            editor.execCommand("undo");
          } else if (btnid == "redo") {
            editor.execCommand("redo");
          }
        }
      };
      HEditor.addPlugin(HEditorPluginUndo.name, HEditorPluginUndo);
    }
  });

  // node_modules/lupine.components/src/component-pool/h-editor/h-editor-demo.tsx
  var defaultHtml, HEditorDemoPage, hEditorDemo;
  var init_h_editor_demo = __esm({
    "node_modules/lupine.components/src/component-pool/h-editor/h-editor-demo.tsx"() {
      init_src2();
      init_h_editor();
      init_jsx_runtime();
      defaultHtml = `
  <h2>Welcome to HEditor!</h2>
  <p>This is a <strong>rich text</strong> editing component powered by <em>Lupine.js</em>.</p>
  <ul>
    <li>Try typing some text</li>
    <li>Use toolbar to format content</li>
    <li>Insert links or images</li>
  </ul>
`;
      HEditorDemoPage = () => {
        let edt;
        const ref = {
          onLoad: async () => {
            const container = ref.$(".edit-view-box");
            if (container) {
              edt = HEditor.getEditor(container, defaultHtml);
            }
          }
        };
        const css2 = {
          display: "flex",
          flexDirection: "column",
          height: "600px",
          // Set an explicit height for the editor container area
          padding: "16px",
          boxSizing: "border-box",
          ".h-editor-demo-header": {
            display: "flex",
            flexDirection: "row",
            alignItems: "center",
            justifyContent: "space-between",
            paddingBottom: "16px"
          },
          ".a-vw-edt-body": {
            flex: 1,
            // Take up remaining space
            border: "1px solid var(--primary-border, #eee)",
            borderRadius: "8px",
            overflow: "hidden"
          },
          // The editor container needs width and height 100% to fill the flex container
          ".edit-view-box": {
            width: "100%",
            height: "100%"
          }
        };
        const handleGetHtml = async () => {
          if (!edt) {
            NotificationMessage.sendMessage("Editor hasn't initialized yet.", "var(--error-bg-color)" /* Error */);
            return;
          }
          const htmlContent = edt.getHtml();
          const closeIndex = await ModalWindow.show({
            title: "Current HTML Output",
            buttons: ["Close"],
            handleClicked: async (index, close) => {
              close();
            },
            children: /* @__PURE__ */ jsx(
              "div",
              {
                style: {
                  padding: "20px",
                  backgroundColor: "var(--secondary-bg-color, #f5f5f5)",
                  borderRadius: "4px",
                  whiteSpace: "pre-wrap",
                  fontFamily: "monospace",
                  maxHeight: "400px",
                  overflowY: "auto"
                },
                children: htmlContent
              }
            )
          });
        };
        return /* @__PURE__ */ jsx("div", { ref, css: css2, children: [
          /* @__PURE__ */ jsx("div", { class: "h-editor-demo-header", children: [
            /* @__PURE__ */ jsx("h3", { children: "HTML Editor" }),
            /* @__PURE__ */ jsx("button", { class: "button-base", onClick: handleGetHtml, children: "Get HTML" })
          ] }),
          /* @__PURE__ */ jsx("div", { class: "a-vw-edt-body", children: /* @__PURE__ */ jsx("div", { class: "edit-view-box" }) })
        ] });
      };
      hEditorDemo = {
        id: "h-editor-demo",
        text: "Rich Text Editor",
        args: {},
        argTypes: {},
        render: () => {
          return /* @__PURE__ */ jsx(HEditorDemoPage, {});
        }
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/h-editor/index.ts
  var init_h_editor2 = __esm({
    "node_modules/lupine.components/src/component-pool/h-editor/index.ts"() {
      init_h_editor();
      init_h_editor_demo();
    }
  });

  // node_modules/lupine.components/src/components/paging-link-demo.tsx
  var db, nextId, mockApi, ContentEditItem, showEditModal, ContentOneRow, PagingLinkPage, pagingLinkDemo;
  var init_paging_link_demo = __esm({
    "node_modules/lupine.components/src/components/paging-link-demo.tsx"() {
      init_src2();
      init_search_input2();
      init_jsx_runtime();
      db = Array.from({ length: 45 }, (_, i) => ({
        id: i + 1,
        name: `User ${i + 1}`,
        email: `user${i + 1}@example.com`,
        role: i % 3 === 0 ? "Admin" : "User",
        status: i % 5 === 0 ? "Inactive" : "Active"
      }));
      nextId = 46;
      mockApi = {
        async getList(searchValue = "", pageIndex = 0, pageLimit = 10) {
          await new Promise((resolve) => setTimeout(resolve, 300));
          let filtered = db;
          if (searchValue) {
            filtered = db.filter(
              (item) => item.name.toLowerCase().includes(searchValue.toLowerCase()) || item.email.toLowerCase().includes(searchValue.toLowerCase())
            );
          }
          const totalCount = filtered.length;
          let maxPages = Math.ceil(totalCount / pageLimit);
          if (maxPages === 0) maxPages = 1;
          if (pageIndex >= maxPages) {
            pageIndex = 0;
          }
          const start = pageIndex * pageLimit;
          const end = start + pageLimit;
          const results = filtered.slice(start, end);
          return {
            status: "ok",
            results,
            pageIndex,
            count: totalCount
          };
        },
        async save(record) {
          await new Promise((resolve) => setTimeout(resolve, 200));
          if (!record.name || !record.email) {
            return { status: "error", message: "Name and Email are required." };
          }
          if (record.id === -1) {
            record.id = nextId++;
            db.unshift(record);
          } else {
            const index = db.findIndex((item) => item.id === record.id);
            if (index > -1) {
              db[index] = { ...record };
            }
          }
          return { status: "ok", id: record.id };
        },
        async remove(id) {
          await new Promise((resolve) => setTimeout(resolve, 200));
          const index = db.findIndex((item) => item.id === id);
          if (index > -1) {
            db.splice(index, 1);
            return { status: "ok" };
          }
          return { status: "error", message: "Record not found." };
        }
      };
      ContentEditItem = (props) => {
        const ref = {};
        const css2 = {
          padding: "10px 0",
          ".pg-edit-label": {
            width: "80px",
            fontWeight: "bold"
          }
        };
        props.hook.save = async () => {
          const name = ref.$("input.pg-e-name").value;
          const email = ref.$("input.pg-e-email").value;
          const role = ref.$("select.pg-e-role").value;
          const status = ref.$("select.pg-e-status").value;
          const newItem = {
            ...props.item,
            name,
            email,
            role,
            status
          };
          const res = await mockApi.save(newItem);
          if (res.status !== "ok") {
            NotificationMessage.sendMessage(res.message || "Error saving record", "var(--error-bg-color)" /* Error */);
            return null;
          }
          newItem.id = res.id;
          return newItem;
        };
        return /* @__PURE__ */ jsx("div", { ref, css: css2, children: [
          /* @__PURE__ */ jsx("div", { class: "row-box mt-m", children: [
            /* @__PURE__ */ jsx("div", { class: "pg-edit-label", children: "Name: " }),
            /* @__PURE__ */ jsx("div", { class: "flex-1", children: /* @__PURE__ */ jsx("input", { type: "text", class: "input-base pg-e-name w-100p", value: props.item.name, placeholder: "Enter name" }) })
          ] }),
          /* @__PURE__ */ jsx("div", { class: "row-box mt-m", children: [
            /* @__PURE__ */ jsx("div", { class: "pg-edit-label", children: "Email: " }),
            /* @__PURE__ */ jsx("div", { class: "flex-1", children: /* @__PURE__ */ jsx("input", { type: "text", class: "input-base pg-e-email w-100p", value: props.item.email, placeholder: "Enter email" }) })
          ] }),
          /* @__PURE__ */ jsx("div", { class: "row-box mt-m", children: [
            /* @__PURE__ */ jsx("div", { class: "pg-edit-label", children: "Role: " }),
            /* @__PURE__ */ jsx("div", { class: "flex-1", children: /* @__PURE__ */ jsx("select", { class: "input-base pg-e-role", children: [
              /* @__PURE__ */ jsx("option", { value: "Admin", selected: props.item.role === "Admin", children: "Admin" }),
              /* @__PURE__ */ jsx("option", { value: "User", selected: props.item.role === "User", children: "User" })
            ] }) })
          ] }),
          /* @__PURE__ */ jsx("div", { class: "row-box mt-m", children: [
            /* @__PURE__ */ jsx("div", { class: "pg-edit-label", children: "Status: " }),
            /* @__PURE__ */ jsx("div", { class: "flex-1", children: /* @__PURE__ */ jsx("select", { class: "input-base pg-e-status", children: [
              /* @__PURE__ */ jsx("option", { value: "Active", selected: props.item.status === "Active", children: "Active" }),
              /* @__PURE__ */ jsx("option", { value: "Inactive", selected: props.item.status === "Inactive", children: "Inactive" })
            ] }) })
          ] })
        ] });
      };
      showEditModal = async (item, onUpdate) => {
        const updateFn = {};
        const handleClicked = async (index) => {
          var _a, _b;
          if (index === 1) {
            (_a = updateFn.cancel) == null ? void 0 : _a.call(updateFn);
            modalClose();
          }
          if (index === 0) {
            const newItem = await ((_b = updateFn.save) == null ? void 0 : _b.call(updateFn));
            if (newItem) {
              onUpdate(newItem);
              modalClose();
            }
          }
        };
        const modalClose = await ModalWindow.show({
          title: item.id === -1 ? "Add New User" : "Edit User",
          buttons: ["Save", "Cancel"],
          handleClicked,
          children: /* @__PURE__ */ jsx(ContentEditItem, { item, hook: updateFn }),
          closeWhenClickOutside: false
        });
      };
      ContentOneRow = (props) => {
        const ref = {};
        const makeDom = (item) => {
          const onEdit = () => {
            const update = async (updatedItem) => {
              await ref.mountInnerComponent(makeDom(updatedItem));
              NotificationMessage.sendMessage("Record saved successfully.", "var(--success-bg-color)" /* Success */);
            };
            showEditModal(item, update);
          };
          const onRemove = async () => {
            await ActionSheetSelect.show({
              title: `Are you sure you want to delete ${item.name}?`,
              options: ["Delete"],
              cancelButtonText: "Cancel",
              handleClicked: async (idx, close) => {
                close();
                if (idx === 0) {
                  const res = await mockApi.remove(item.id);
                  if (res.status === "ok") {
                    NotificationMessage.sendMessage("Record deleted.", "var(--success-bg-color)" /* Success */);
                    props.onRefreshList();
                  } else {
                    NotificationMessage.sendMessage(res.message || "Error deleting.", "var(--error-bg-color)" /* Error */);
                  }
                }
              }
            });
          };
          return /* @__PURE__ */ jsx(Fragment, { children: [
            /* @__PURE__ */ jsx("td", { children: item.id }),
            /* @__PURE__ */ jsx("td", { children: item.name }),
            /* @__PURE__ */ jsx("td", { children: item.email }),
            /* @__PURE__ */ jsx("td", { children: item.role }),
            /* @__PURE__ */ jsx("td", { children: /* @__PURE__ */ jsx("span", { style: { color: item.status === "Active" ? "green" : "red" }, children: item.status }) }),
            /* @__PURE__ */ jsx("td", { class: "pg-lst-row-ctl", children: [
              /* @__PURE__ */ jsx(
                "i",
                {
                  class: "ifc-icon ma-pencil-outline mr-m",
                  onClick: onEdit,
                  title: "Edit",
                  style: { color: "var(--primary-color)" }
                }
              ),
              /* @__PURE__ */ jsx("i", { class: "ifc-icon ma-close color-red", onClick: onRemove, title: "Delete" })
            ] })
          ] });
        };
        return /* @__PURE__ */ jsx("tr", { ref, children: makeDom(props.item) });
      };
      PagingLinkPage = () => {
        let searchValue = "";
        let pageIndex = 0;
        const listDom = new HtmlVar("");
        const ref = {
          onLoad: async () => {
            await onSearch("");
          }
        };
        const css2 = {
          display: "flex",
          flexDirection: "column",
          ".pg-main-tbl": {
            width: "100%",
            borderCollapse: "collapse",
            marginTop: "10px",
            marginBottom: "10px"
          },
          ".pg-main-tbl th, .pg-main-tbl td": {
            border: "1px solid var(--primary-border, #eee)",
            padding: "8px",
            textAlign: "left"
          },
          ".pg-main-tbl th": {
            backgroundColor: "var(--secondary-bg-color, #f9f9f9)"
          },
          ".pg-main-tbl tr:nth-child(odd)": {
            backgroundColor: "var(--secondary-bg-color, #f9f9f9)"
          },
          ".pg-main-tbl tr:hover": {
            backgroundColor: "var(--info-bg-color, #e6f7ff)"
          },
          ".pg-lst-row-ctl i": {
            cursor: "pointer"
          }
        };
        const onSearch = async (search) => {
          searchValue = (search || "").trim();
          pageIndex = 0;
          listDom.value = await makeList();
        };
        const onPageClick = async (index) => {
          pageIndex = index;
          listDom.value = await makeList();
        };
        const onAdd = async () => {
          const newItem = {
            id: -1,
            name: "",
            email: "",
            role: "User",
            status: "Active"
          };
          const update = async () => {
            listDom.value = await makeList();
            NotificationMessage.sendMessage("User added successfully.", "var(--success-bg-color)" /* Success */);
          };
          showEditModal(newItem, update);
        };
        const refreshList = async () => {
          listDom.value = await makeList();
        };
        const makeList = async () => {
          const pageLimit = getDefaultPageLimit();
          const result = await mockApi.getList(searchValue, pageIndex, pageLimit);
          if (result.status !== "ok") {
            return /* @__PURE__ */ jsx("div", { children: "Error loading data." });
          }
          pageIndex = result.pageIndex;
          if (result.results.length === 0) {
            return /* @__PURE__ */ jsx("div", { style: { padding: "20px", textAlign: "center" }, children: "No results found." });
          }
          return /* @__PURE__ */ jsx("div", { children: [
            /* @__PURE__ */ jsx("div", { style: { display: "flex", justifyContent: "flex-end" }, children: /* @__PURE__ */ jsx(
              PagingLink,
              {
                itemsCount: result.count,
                pageIndex,
                baseLink: "",
                onClick: onPageClick,
                textPage: "Page",
                textPerpage: "items per page",
                textTo: "Go to",
                textOk: "OK",
                showControl: true
              }
            ) }),
            /* @__PURE__ */ jsx("table", { class: "pg-main-tbl", children: [
              /* @__PURE__ */ jsx("tr", { children: [
                /* @__PURE__ */ jsx("th", { children: "ID" }),
                /* @__PURE__ */ jsx("th", { children: "Name" }),
                /* @__PURE__ */ jsx("th", { children: "Email" }),
                /* @__PURE__ */ jsx("th", { children: "Role" }),
                /* @__PURE__ */ jsx("th", { children: "Status" }),
                /* @__PURE__ */ jsx("th", { children: "Actions" })
              ] }),
              result.results.map((item) => /* @__PURE__ */ jsx(ContentOneRow, { item, onRefreshList: refreshList }))
            ] }),
            /* @__PURE__ */ jsx("div", { style: { display: "flex", justifyContent: "flex-end" }, children: /* @__PURE__ */ jsx(
              PagingLink,
              {
                itemsCount: result.count,
                pageIndex,
                baseLink: "",
                onClick: onPageClick,
                textPage: "Page",
                textPerpage: "items per page",
                textTo: "Go to",
                textOk: "OK",
                showControl: true
              }
            ) })
          ] });
        };
        return /* @__PURE__ */ jsx("div", { ref, css: css2, style: { padding: "15px" }, children: [
          /* @__PURE__ */ jsx("div", { class: "row-box pb-m", style: { display: "flex", gap: "10px" }, children: [
            /* @__PURE__ */ jsx(SearchInput, { placeholder: "Search by Name/Email...", onSearch, onClear: onSearch, class: "flex-1" }),
            /* @__PURE__ */ jsx("button", { class: "button-base", onClick: onAdd, children: "Add User" })
          ] }),
          /* @__PURE__ */ jsx("div", { class: "list", children: listDom.node })
        ] });
      };
      pagingLinkDemo = {
        id: "paging-link-demo",
        text: "Data List & Paging",
        args: {},
        argTypes: {},
        render: () => {
          return /* @__PURE__ */ jsx(PagingLinkPage, {});
        }
      };
    }
  });

  // node_modules/lupine.components/src/components/slide-tab-component-demo.tsx
  var samplePages, slideTabDemo;
  var init_slide_tab_component_demo = __esm({
    "node_modules/lupine.components/src/components/slide-tab-component-demo.tsx"() {
      init_slide_tab_component();
      init_jsx_runtime();
      samplePages = [
        {
          title: "Overview",
          content: /* @__PURE__ */ jsx("div", { style: { padding: "12px" }, children: [
            /* @__PURE__ */ jsx("h3", { style: { marginTop: 0 }, children: "Overview" }),
            /* @__PURE__ */ jsx("p", { children: "This is the overview tab. It provides a summary of the content." }),
            /* @__PURE__ */ jsx("ul", { children: [
              /* @__PURE__ */ jsx("li", { children: "Feature A: Smooth horizontal scrolling between tabs" }),
              /* @__PURE__ */ jsx("li", { children: "Feature B: Snap-to-slide behaviour" }),
              /* @__PURE__ */ jsx("li", { children: "Feature C: Active tab indicator" })
            ] })
          ] })
        },
        {
          title: "Details",
          content: /* @__PURE__ */ jsx("div", { style: { padding: "12px" }, children: [
            /* @__PURE__ */ jsx("h3", { style: { marginTop: 0 }, children: "Details" }),
            /* @__PURE__ */ jsx("p", { children: "This is the details tab. It shows in-depth information." }),
            /* @__PURE__ */ jsx("p", { children: "The SlideTabComponent uses CSS scroll-snap for smooth, performant tab transitions without any animation libraries." })
          ] })
        },
        {
          title: "Settings",
          content: /* @__PURE__ */ jsx("div", { style: { padding: "12px" }, children: [
            /* @__PURE__ */ jsx("h3", { style: { marginTop: 0 }, children: "Settings" }),
            /* @__PURE__ */ jsx("p", { children: "This is the settings tab. Configure options here." }),
            /* @__PURE__ */ jsx("div", { style: { display: "flex", flexDirection: "column", gap: "8px" }, children: [
              /* @__PURE__ */ jsx("label", { children: [
                /* @__PURE__ */ jsx("input", { type: "checkbox", checked: true }),
                " Enable notifications"
              ] }),
              /* @__PURE__ */ jsx("label", { children: [
                /* @__PURE__ */ jsx("input", { type: "checkbox" }),
                " Dark mode"
              ] }),
              /* @__PURE__ */ jsx("label", { children: [
                /* @__PURE__ */ jsx("input", { type: "checkbox", checked: true }),
                " Auto-save"
              ] })
            ] })
          ] })
        }
      ];
      slideTabDemo = {
        id: "slide-tab-demo",
        text: "Slide Tab",
        args: {
          pages: samplePages
        },
        render: (args) => {
          return /* @__PURE__ */ jsx(
            "div",
            {
              style: {
                height: "300px",
                display: "flex",
                flexDirection: "column",
                border: "var(--primary-border)",
                borderRadius: "8px",
                overflow: "hidden"
              },
              children: /* @__PURE__ */ jsx(SlideTabComponent, { ...args })
            }
          );
        },
        code: `import { SlideTabComponent } from 'lupine.components/components/slide-tab-component';

const pages = [
  { title: 'Tab 1', content: <div>Content for Tab 1</div> },
  { title: 'Tab 2', content: <div>Content for Tab 2</div> },
  { title: 'Tab 3', content: <div>Content for Tab 3</div> },
];

<SlideTabComponent pages={pages} />
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/qrcode/qrcode-algorithm.ts
  function appendBits(val, len, bb) {
    if (len < 0 || len > 31 || val >>> len != 0) throw new RangeError("Value out of range");
    for (let i = len - 1; i >= 0; i--)
      bb.push(val >>> i & 1);
  }
  function getBit(x, i) {
    return (x >>> i & 1) != 0;
  }
  function assert(cond) {
    if (!cond) throw new Error("Assertion error");
  }
  var QrCode, QrSegment, QrCodeEcc, QrSegmentMode;
  var init_qrcode_algorithm = __esm({
    "node_modules/lupine.components/src/component-pool/qrcode/qrcode-algorithm.ts"() {
      "use strict";
      QrCode = class _QrCode {
        /*-- Constructor (low level) and fields --*/
        // Creates a new QR Code with the given version number,
        // error correction level, data codeword bytes, and mask number.
        // This is a low-level API that most users should not use directly.
        // A mid-level API is the encodeSegments() function.
        constructor(version, errorCorrectionLevel, dataCodewords, msk) {
          this.version = version;
          this.errorCorrectionLevel = errorCorrectionLevel;
          if (version < _QrCode.MIN_VERSION || version > _QrCode.MAX_VERSION)
            throw new RangeError("Version value out of range");
          if (msk < -1 || msk > 7) throw new RangeError("Mask value out of range");
          this.size = version * 4 + 17;
          let row = [];
          for (let i = 0; i < this.size; i++) row.push(false);
          for (let i = 0; i < this.size; i++) {
            this.modules.push(row.slice());
            this.isFunction.push(row.slice());
          }
          this.drawFunctionPatterns();
          const allCodewords = this.addEccAndInterleave(dataCodewords);
          this.drawCodewords(allCodewords);
          if (msk == -1) {
            let minPenalty = 1e9;
            for (let i = 0; i < 8; i++) {
              this.applyMask(i);
              this.drawFormatBits(i);
              const penalty = this.getPenaltyScore();
              if (penalty < minPenalty) {
                msk = i;
                minPenalty = penalty;
              }
              this.applyMask(i);
            }
          }
          assert(0 <= msk && msk <= 7);
          this.mask = msk;
          this.applyMask(msk);
          this.drawFormatBits(msk);
          this.isFunction = [];
        }
        /*-- Static factory functions (high level) --*/
        // Returns a QR Code representing the given Unicode text string at the given error correction level.
        // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
        // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible
        // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
        // ecl argument if it can be done without increasing the version.
        static encodeText(text, ecl) {
          const segs = QrSegment.makeSegments(text);
          return _QrCode.encodeSegments(segs, ecl);
        }
        // Returns a QR Code representing the given binary data at the given error correction level.
        // This function always encodes using the binary segment mode, not any text mode. The maximum number of
        // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
        // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
        static encodeBinary(data, ecl) {
          const seg = QrSegment.makeBytes(data);
          return _QrCode.encodeSegments([seg], ecl);
        }
        /*-- Static factory functions (mid level) --*/
        // Returns a QR Code representing the given segments with the given encoding parameters.
        // The smallest possible QR Code version within the given range is automatically
        // chosen for the output. Iff boostEcl is true, then the ECC level of the result
        // may be higher than the ecl argument if it can be done without increasing the
        // version. The mask number is either between 0 to 7 (inclusive) to force that
        // mask, or -1 to automatically choose an appropriate mask (which may be slow).
        // This function allows the user to create a custom sequence of segments that switches
        // between modes (such as alphanumeric and byte) to encode text in less space.
        // This is a mid-level API; the high-level API is encodeText() and encodeBinary().
        static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
          if (!(_QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= _QrCode.MAX_VERSION) || mask < -1 || mask > 7)
            throw new RangeError("Invalid value");
          let version;
          let dataUsedBits;
          for (version = minVersion; ; version++) {
            const dataCapacityBits2 = _QrCode.getNumDataCodewords(version, ecl) * 8;
            const usedBits = QrSegment.getTotalBits(segs, version);
            if (usedBits <= dataCapacityBits2) {
              dataUsedBits = usedBits;
              break;
            }
            if (version >= maxVersion)
              throw new RangeError("Data too long");
          }
          for (const newEcl of [QrCodeEcc.MEDIUM, QrCodeEcc.QUARTILE, QrCodeEcc.HIGH]) {
            if (boostEcl && dataUsedBits <= _QrCode.getNumDataCodewords(version, newEcl) * 8) ecl = newEcl;
          }
          let bb = [];
          for (const seg of segs) {
            appendBits(seg.mode.modeBits, 4, bb);
            appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);
            for (const b of seg.getData()) bb.push(b);
          }
          assert(bb.length == dataUsedBits);
          const dataCapacityBits = _QrCode.getNumDataCodewords(version, ecl) * 8;
          assert(bb.length <= dataCapacityBits);
          appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
          appendBits(0, (8 - bb.length % 8) % 8, bb);
          assert(bb.length % 8 == 0);
          for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17) appendBits(padByte, 8, bb);
          let dataCodewords = [];
          while (dataCodewords.length * 8 < bb.length) dataCodewords.push(0);
          bb.forEach((b, i) => dataCodewords[i >>> 3] |= b << 7 - (i & 7));
          return new _QrCode(version, ecl, dataCodewords, mask);
        }
        /*-- Fields --*/
        // The width and height of this QR Code, measured in modules, between
        // 21 and 177 (inclusive). This is equal to version * 4 + 17.
        size;
        // The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).
        // Even if a QR Code is created with automatic masking requested (mask = -1),
        // the resulting object still has a mask value between 0 and 7.
        mask;
        // The modules of this QR Code (false = light, true = dark).
        // Immutable after constructor finishes. Accessed through getModule().
        modules = [];
        // Indicates function modules that are not subjected to masking. Discarded when constructor finishes.
        isFunction = [];
        /*-- Accessor methods --*/
        // Returns the color of the module (pixel) at the given coordinates, which is false
        // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
        // If the given coordinates are out of bounds, then false (light) is returned.
        getModule(x, y) {
          return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];
        }
        /*-- Private helper methods for constructor: Drawing function modules --*/
        // Reads this object's version field, and draws and marks all function modules.
        drawFunctionPatterns() {
          for (let i = 0; i < this.size; i++) {
            this.setFunctionModule(6, i, i % 2 == 0);
            this.setFunctionModule(i, 6, i % 2 == 0);
          }
          this.drawFinderPattern(3, 3);
          this.drawFinderPattern(this.size - 4, 3);
          this.drawFinderPattern(3, this.size - 4);
          const alignPatPos = this.getAlignmentPatternPositions();
          const numAlign = alignPatPos.length;
          for (let i = 0; i < numAlign; i++) {
            for (let j = 0; j < numAlign; j++) {
              if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))
                this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
            }
          }
          this.drawFormatBits(0);
          this.drawVersion();
        }
        // Draws two copies of the format bits (with its own error correction code)
        // based on the given mask and this object's error correction level field.
        drawFormatBits(mask) {
          const data = this.errorCorrectionLevel.formatBits << 3 | mask;
          let rem = data;
          for (let i = 0; i < 10; i++) rem = rem << 1 ^ (rem >>> 9) * 1335;
          const bits = (data << 10 | rem) ^ 21522;
          assert(bits >>> 15 == 0);
          for (let i = 0; i <= 5; i++) this.setFunctionModule(8, i, getBit(bits, i));
          this.setFunctionModule(8, 7, getBit(bits, 6));
          this.setFunctionModule(8, 8, getBit(bits, 7));
          this.setFunctionModule(7, 8, getBit(bits, 8));
          for (let i = 9; i < 15; i++) this.setFunctionModule(14 - i, 8, getBit(bits, i));
          for (let i = 0; i < 8; i++) this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
          for (let i = 8; i < 15; i++) this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
          this.setFunctionModule(8, this.size - 8, true);
        }
        // Draws two copies of the version bits (with its own error correction code),
        // based on this object's version field, iff 7 <= version <= 40.
        drawVersion() {
          if (this.version < 7) return;
          let rem = this.version;
          for (let i = 0; i < 12; i++) rem = rem << 1 ^ (rem >>> 11) * 7973;
          const bits = this.version << 12 | rem;
          assert(bits >>> 18 == 0);
          for (let i = 0; i < 18; i++) {
            const color = getBit(bits, i);
            const a = this.size - 11 + i % 3;
            const b = Math.floor(i / 3);
            this.setFunctionModule(a, b, color);
            this.setFunctionModule(b, a, color);
          }
        }
        // Draws a 9*9 finder pattern including the border separator,
        // with the center module at (x, y). Modules can be out of bounds.
        drawFinderPattern(x, y) {
          for (let dy = -4; dy <= 4; dy++) {
            for (let dx = -4; dx <= 4; dx++) {
              const dist = Math.max(Math.abs(dx), Math.abs(dy));
              const xx = x + dx;
              const yy = y + dy;
              if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)
                this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
            }
          }
        }
        // Draws a 5*5 alignment pattern, with the center module
        // at (x, y). All modules must be in bounds.
        drawAlignmentPattern(x, y) {
          for (let dy = -2; dy <= 2; dy++) {
            for (let dx = -2; dx <= 2; dx++)
              this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
          }
        }
        // Sets the color of a module and marks it as a function module.
        // Only used by the constructor. Coordinates must be in bounds.
        setFunctionModule(x, y, isDark) {
          this.modules[y][x] = isDark;
          this.isFunction[y][x] = true;
        }
        /*-- Private helper methods for constructor: Codewords and masking --*/
        // Returns a new byte string representing the given data with the appropriate error correction
        // codewords appended to it, based on this object's version and error correction level.
        addEccAndInterleave(data) {
          const ver = this.version;
          const ecl = this.errorCorrectionLevel;
          if (data.length != _QrCode.getNumDataCodewords(ver, ecl)) throw new RangeError("Invalid argument");
          const numBlocks = _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
          const blockEccLen = _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
          const rawCodewords = Math.floor(_QrCode.getNumRawDataModules(ver) / 8);
          const numShortBlocks = numBlocks - rawCodewords % numBlocks;
          const shortBlockLen = Math.floor(rawCodewords / numBlocks);
          let blocks = [];
          const rsDiv = _QrCode.reedSolomonComputeDivisor(blockEccLen);
          for (let i = 0, k = 0; i < numBlocks; i++) {
            let dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
            k += dat.length;
            const ecc = _QrCode.reedSolomonComputeRemainder(dat, rsDiv);
            if (i < numShortBlocks) dat.push(0);
            blocks.push(dat.concat(ecc));
          }
          let result = [];
          for (let i = 0; i < blocks[0].length; i++) {
            blocks.forEach((block2, j) => {
              if (i != shortBlockLen - blockEccLen || j >= numShortBlocks) result.push(block2[i]);
            });
          }
          assert(result.length == rawCodewords);
          return result;
        }
        // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
        // data area of this QR Code. Function modules need to be marked off before this is called.
        drawCodewords(data) {
          if (data.length != Math.floor(_QrCode.getNumRawDataModules(this.version) / 8))
            throw new RangeError("Invalid argument");
          let i = 0;
          for (let right = this.size - 1; right >= 1; right -= 2) {
            if (right == 6) right = 5;
            for (let vert = 0; vert < this.size; vert++) {
              for (let j = 0; j < 2; j++) {
                const x = right - j;
                const upward = (right + 1 & 2) == 0;
                const y = upward ? this.size - 1 - vert : vert;
                if (!this.isFunction[y][x] && i < data.length * 8) {
                  this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
                  i++;
                }
              }
            }
          }
          assert(i == data.length * 8);
        }
        // XORs the codeword modules in this QR Code with the given mask pattern.
        // The function modules must be marked and the codeword bits must be drawn
        // before masking. Due to the arithmetic of XOR, calling applyMask() with
        // the same mask value a second time will undo the mask. A final well-formed
        // QR Code needs exactly one (not zero, two, etc.) mask applied.
        applyMask(mask) {
          if (mask < 0 || mask > 7) throw new RangeError("Mask value out of range");
          for (let y = 0; y < this.size; y++) {
            for (let x = 0; x < this.size; x++) {
              let invert;
              switch (mask) {
                case 0:
                  invert = (x + y) % 2 == 0;
                  break;
                case 1:
                  invert = y % 2 == 0;
                  break;
                case 2:
                  invert = x % 3 == 0;
                  break;
                case 3:
                  invert = (x + y) % 3 == 0;
                  break;
                case 4:
                  invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;
                  break;
                case 5:
                  invert = x * y % 2 + x * y % 3 == 0;
                  break;
                case 6:
                  invert = (x * y % 2 + x * y % 3) % 2 == 0;
                  break;
                case 7:
                  invert = ((x + y) % 2 + x * y % 3) % 2 == 0;
                  break;
                default:
                  throw new Error("Unreachable");
              }
              if (!this.isFunction[y][x] && invert) this.modules[y][x] = !this.modules[y][x];
            }
          }
        }
        // Calculates and returns the penalty score based on state of this QR Code's current modules.
        // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
        getPenaltyScore() {
          let result = 0;
          for (let y = 0; y < this.size; y++) {
            let runColor = false;
            let runX = 0;
            let runHistory = [0, 0, 0, 0, 0, 0, 0];
            for (let x = 0; x < this.size; x++) {
              if (this.modules[y][x] == runColor) {
                runX++;
                if (runX == 5) result += _QrCode.PENALTY_N1;
                else if (runX > 5) result++;
              } else {
                this.finderPenaltyAddHistory(runX, runHistory);
                if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;
                runColor = this.modules[y][x];
                runX = 1;
              }
            }
            result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * _QrCode.PENALTY_N3;
          }
          for (let x = 0; x < this.size; x++) {
            let runColor = false;
            let runY = 0;
            let runHistory = [0, 0, 0, 0, 0, 0, 0];
            for (let y = 0; y < this.size; y++) {
              if (this.modules[y][x] == runColor) {
                runY++;
                if (runY == 5) result += _QrCode.PENALTY_N1;
                else if (runY > 5) result++;
              } else {
                this.finderPenaltyAddHistory(runY, runHistory);
                if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;
                runColor = this.modules[y][x];
                runY = 1;
              }
            }
            result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * _QrCode.PENALTY_N3;
          }
          for (let y = 0; y < this.size - 1; y++) {
            for (let x = 0; x < this.size - 1; x++) {
              const color = this.modules[y][x];
              if (color == this.modules[y][x + 1] && color == this.modules[y + 1][x] && color == this.modules[y + 1][x + 1])
                result += _QrCode.PENALTY_N2;
            }
          }
          let dark = 0;
          for (const row of this.modules) dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);
          const total = this.size * this.size;
          const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
          assert(0 <= k && k <= 9);
          result += k * _QrCode.PENALTY_N4;
          assert(0 <= result && result <= 2568888);
          return result;
        }
        /*-- Private helper functions --*/
        // Returns an ascending list of positions of alignment patterns for this version number.
        // Each position is in the range [0,177), and are used on both the x and y axes.
        // This could be implemented as lookup table of 40 variable-length lists of integers.
        getAlignmentPatternPositions() {
          if (this.version == 1) return [];
          else {
            const numAlign = Math.floor(this.version / 7) + 2;
            const step = Math.floor((this.version * 8 + numAlign * 3 + 5) / (numAlign * 4 - 4)) * 2;
            let result = [6];
            for (let pos = this.size - 7; result.length < numAlign; pos -= step) result.splice(1, 0, pos);
            return result;
          }
        }
        // Returns the number of data bits that can be stored in a QR Code of the given version number, after
        // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
        // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
        static getNumRawDataModules(ver) {
          if (ver < _QrCode.MIN_VERSION || ver > _QrCode.MAX_VERSION) throw new RangeError("Version number out of range");
          let result = (16 * ver + 128) * ver + 64;
          if (ver >= 2) {
            const numAlign = Math.floor(ver / 7) + 2;
            result -= (25 * numAlign - 10) * numAlign - 55;
            if (ver >= 7) result -= 36;
          }
          assert(208 <= result && result <= 29648);
          return result;
        }
        // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
        // QR Code of the given version number and error correction level, with remainder bits discarded.
        // This stateless pure function could be implemented as a (40*4)-cell lookup table.
        static getNumDataCodewords(ver, ecl) {
          return Math.floor(_QrCode.getNumRawDataModules(ver) / 8) - _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
        }
        // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
        // implemented as a lookup table over all possible parameter values, instead of as an algorithm.
        static reedSolomonComputeDivisor(degree) {
          if (degree < 1 || degree > 255) throw new RangeError("Degree out of range");
          let result = [];
          for (let i = 0; i < degree - 1; i++) result.push(0);
          result.push(1);
          let root = 1;
          for (let i = 0; i < degree; i++) {
            for (let j = 0; j < result.length; j++) {
              result[j] = _QrCode.reedSolomonMultiply(result[j], root);
              if (j + 1 < result.length) result[j] ^= result[j + 1];
            }
            root = _QrCode.reedSolomonMultiply(root, 2);
          }
          return result;
        }
        // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
        static reedSolomonComputeRemainder(data, divisor) {
          let result = divisor.map((_) => 0);
          for (const b of data) {
            const factor = b ^ result.shift();
            result.push(0);
            divisor.forEach((coef, i) => result[i] ^= _QrCode.reedSolomonMultiply(coef, factor));
          }
          return result;
        }
        // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
        // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.
        static reedSolomonMultiply(x, y) {
          if (x >>> 8 != 0 || y >>> 8 != 0) throw new RangeError("Byte out of range");
          let z = 0;
          for (let i = 7; i >= 0; i--) {
            z = z << 1 ^ (z >>> 7) * 285;
            z ^= (y >>> i & 1) * x;
          }
          assert(z >>> 8 == 0);
          return z;
        }
        // Can only be called immediately after a light run is added, and
        // returns either 0, 1, or 2. A helper function for getPenaltyScore().
        finderPenaltyCountPatterns(runHistory) {
          const n = runHistory[1];
          assert(n <= this.size * 3);
          const core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;
          return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
        }
        // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
        finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
          if (currentRunColor) {
            this.finderPenaltyAddHistory(currentRunLength, runHistory);
            currentRunLength = 0;
          }
          currentRunLength += this.size;
          this.finderPenaltyAddHistory(currentRunLength, runHistory);
          return this.finderPenaltyCountPatterns(runHistory);
        }
        // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
        finderPenaltyAddHistory(currentRunLength, runHistory) {
          if (runHistory[0] == 0) currentRunLength += this.size;
          runHistory.pop();
          runHistory.unshift(currentRunLength);
        }
        /*-- Constants and tables --*/
        // The minimum version number supported in the QR Code Model 2 standard.
        static MIN_VERSION = 1;
        // The maximum version number supported in the QR Code Model 2 standard.
        static MAX_VERSION = 40;
        // For use in getPenaltyScore(), when evaluating which mask is best.
        static PENALTY_N1 = 3;
        static PENALTY_N2 = 3;
        static PENALTY_N3 = 40;
        static PENALTY_N4 = 10;
        static ECC_CODEWORDS_PER_BLOCK = [
          // Version: (note that index 0 is for padding, and is set to an illegal value)
          //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
          [
            -1,
            7,
            10,
            15,
            20,
            26,
            18,
            20,
            24,
            30,
            18,
            20,
            24,
            26,
            30,
            22,
            24,
            28,
            30,
            28,
            28,
            28,
            28,
            30,
            30,
            26,
            28,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30
          ],
          // Low
          [
            -1,
            10,
            16,
            26,
            18,
            24,
            16,
            18,
            22,
            22,
            26,
            30,
            22,
            22,
            24,
            24,
            28,
            28,
            26,
            26,
            26,
            26,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28
          ],
          // Medium
          [
            -1,
            13,
            22,
            18,
            26,
            18,
            24,
            18,
            22,
            20,
            24,
            28,
            26,
            24,
            20,
            30,
            24,
            28,
            28,
            26,
            30,
            28,
            30,
            30,
            30,
            30,
            28,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30
          ],
          // Quartile
          [
            -1,
            17,
            28,
            22,
            16,
            22,
            28,
            26,
            26,
            24,
            28,
            24,
            28,
            22,
            24,
            24,
            30,
            28,
            28,
            26,
            28,
            30,
            24,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30
          ]
          // High
        ];
        static NUM_ERROR_CORRECTION_BLOCKS = [
          // Version: (note that index 0 is for padding, and is set to an illegal value)
          //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
          [
            -1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            6,
            6,
            6,
            6,
            7,
            8,
            8,
            9,
            9,
            10,
            12,
            12,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            19,
            20,
            21,
            22,
            24,
            25
          ],
          // Low
          [
            -1,
            1,
            1,
            1,
            2,
            2,
            4,
            4,
            4,
            5,
            5,
            5,
            8,
            9,
            9,
            10,
            10,
            11,
            13,
            14,
            16,
            17,
            17,
            18,
            20,
            21,
            23,
            25,
            26,
            28,
            29,
            31,
            33,
            35,
            37,
            38,
            40,
            43,
            45,
            47,
            49
          ],
          // Medium
          [
            -1,
            1,
            1,
            2,
            2,
            4,
            4,
            6,
            6,
            8,
            8,
            8,
            10,
            12,
            16,
            12,
            17,
            16,
            18,
            21,
            20,
            23,
            23,
            25,
            27,
            29,
            34,
            34,
            35,
            38,
            40,
            43,
            45,
            48,
            51,
            53,
            56,
            59,
            62,
            65,
            68
          ],
          // Quartile
          [
            -1,
            1,
            1,
            2,
            4,
            4,
            4,
            5,
            6,
            8,
            8,
            11,
            11,
            16,
            16,
            18,
            16,
            19,
            21,
            25,
            25,
            25,
            34,
            30,
            32,
            35,
            37,
            40,
            42,
            45,
            48,
            51,
            54,
            57,
            60,
            63,
            66,
            70,
            74,
            77,
            81
          ]
          // High
        ];
      };
      QrSegment = class _QrSegment {
        /*-- Constructor (low level) and fields --*/
        // Creates a new QR Code segment with the given attributes and data.
        // The character count (numChars) must agree with the mode and the bit buffer length,
        // but the constraint isn't checked. The given bit buffer is cloned and stored.
        constructor(mode, numChars, bitData) {
          this.mode = mode;
          this.numChars = numChars;
          this.bitData = bitData;
          if (numChars < 0) throw new RangeError("Invalid argument");
          this.bitData = bitData.slice();
        }
        /*-- Static factory functions (mid level) --*/
        // Returns a segment representing the given binary data encoded in
        // byte mode. All input byte arrays are acceptable. Any text string
        // can be converted to UTF-8 bytes and encoded as a byte mode segment.
        static makeBytes(data) {
          let bb = [];
          for (const b of data) appendBits(b, 8, bb);
          return new _QrSegment(QrSegmentMode.BYTE, data.length, bb);
        }
        // Returns a segment representing the given string of decimal digits encoded in numeric mode.
        static makeNumeric(digits) {
          if (!_QrSegment.isNumeric(digits)) throw new RangeError("String contains non-numeric characters");
          let bb = [];
          for (let i = 0; i < digits.length; ) {
            const n = Math.min(digits.length - i, 3);
            appendBits(parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);
            i += n;
          }
          return new _QrSegment(QrSegmentMode.NUMERIC, digits.length, bb);
        }
        // Returns a segment representing the given text string encoded in alphanumeric mode.
        // The characters allowed are: 0 to 9, A to Z (uppercase only), space,
        // dollar, percent, asterisk, plus, hyphen, period, slash, colon.
        static makeAlphanumeric(text) {
          if (!_QrSegment.isAlphanumeric(text))
            throw new RangeError("String contains unencodable characters in alphanumeric mode");
          let bb = [];
          let i;
          for (i = 0; i + 2 <= text.length; i += 2) {
            let temp = _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
            temp += _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
            appendBits(temp, 11, bb);
          }
          if (i < text.length)
            appendBits(_QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
          return new _QrSegment(QrSegmentMode.ALPHANUMERIC, text.length, bb);
        }
        // Returns a new mutable list of zero or more segments to represent the given Unicode text string.
        // The result may use various segment modes and switch modes to optimize the length of the bit stream.
        static makeSegments(text) {
          if (text == "") return [];
          else if (_QrSegment.isNumeric(text)) return [_QrSegment.makeNumeric(text)];
          else if (_QrSegment.isAlphanumeric(text)) return [_QrSegment.makeAlphanumeric(text)];
          else return [_QrSegment.makeBytes(_QrSegment.toUtf8ByteArray(text))];
        }
        // Returns a segment representing an Extended Channel Interpretation
        // (ECI) designator with the given assignment value.
        static makeEci(assignVal) {
          let bb = [];
          if (assignVal < 0) throw new RangeError("ECI assignment value out of range");
          else if (assignVal < 1 << 7) appendBits(assignVal, 8, bb);
          else if (assignVal < 1 << 14) {
            appendBits(2, 2, bb);
            appendBits(assignVal, 14, bb);
          } else if (assignVal < 1e6) {
            appendBits(6, 3, bb);
            appendBits(assignVal, 21, bb);
          } else throw new RangeError("ECI assignment value out of range");
          return new _QrSegment(QrSegmentMode.ECI, 0, bb);
        }
        // Tests whether the given string can be encoded as a segment in numeric mode.
        // A string is encodable iff each character is in the range 0 to 9.
        static isNumeric(text) {
          return _QrSegment.NUMERIC_REGEX.test(text);
        }
        // Tests whether the given string can be encoded as a segment in alphanumeric mode.
        // A string is encodable iff each character is in the following set: 0 to 9, A to Z
        // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
        static isAlphanumeric(text) {
          return _QrSegment.ALPHANUMERIC_REGEX.test(text);
        }
        /*-- Methods --*/
        // Returns a new copy of the data bits of this segment.
        getData() {
          return this.bitData.slice();
        }
        // (Package-private) Calculates and returns the number of bits needed to encode the given segments at
        // the given version. The result is infinity if a segment has too many characters to fit its length field.
        static getTotalBits(segs, version) {
          let result = 0;
          for (const seg of segs) {
            const ccbits = seg.mode.numCharCountBits(version);
            if (seg.numChars >= 1 << ccbits) return Infinity;
            result += 4 + ccbits + seg.bitData.length;
          }
          return result;
        }
        // Returns a new array of bytes representing the given string encoded in UTF-8.
        static toUtf8ByteArray(str2) {
          str2 = encodeURI(str2);
          let result = [];
          for (let i = 0; i < str2.length; i++) {
            if (str2.charAt(i) != "%") result.push(str2.charCodeAt(i));
            else {
              result.push(parseInt(str2.substring(i + 1, i + 3), 16));
              i += 2;
            }
          }
          return result;
        }
        /*-- Constants --*/
        // Describes precisely all strings that are encodable in numeric mode.
        static NUMERIC_REGEX = /^[0-9]*$/;
        // Describes precisely all strings that are encodable in alphanumeric mode.
        static ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
        // The set of all legal characters in alphanumeric mode,
        // where each character value maps to the index in the string.
        static ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
      };
      QrCodeEcc = class _QrCodeEcc {
        // The QR Code can tolerate about 30% erroneous codewords
        /*-- Constructor and fields --*/
        constructor(ordinal, formatBits) {
          this.ordinal = ordinal;
          this.formatBits = formatBits;
        }
        /*-- Constants --*/
        static LOW = new _QrCodeEcc(0, 1);
        // The QR Code can tolerate about  7% erroneous codewords
        static MEDIUM = new _QrCodeEcc(1, 0);
        // The QR Code can tolerate about 15% erroneous codewords
        static QUARTILE = new _QrCodeEcc(2, 3);
        // The QR Code can tolerate about 25% erroneous codewords
        static HIGH = new _QrCodeEcc(3, 2);
      };
      QrSegmentMode = class _QrSegmentMode {
        /*-- Constructor and fields --*/
        constructor(modeBits, numBitsCharCount) {
          this.modeBits = modeBits;
          this.numBitsCharCount = numBitsCharCount;
        }
        /*-- Constants --*/
        static NUMERIC = new _QrSegmentMode(1, [10, 12, 14]);
        static ALPHANUMERIC = new _QrSegmentMode(2, [9, 11, 13]);
        static BYTE = new _QrSegmentMode(4, [8, 16, 16]);
        static KANJI = new _QrSegmentMode(8, [8, 10, 12]);
        static ECI = new _QrSegmentMode(7, [0, 0, 0]);
        /*-- Method --*/
        // (Package-private) Returns the bit width of the character count field for a segment in
        // this mode in a QR Code at the given version number. The result is in the range [0, 16].
        numCharCountBits(ver) {
          return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
        }
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/qrcode/qrcode.tsx
  function generatePath(modules, margin = 0) {
    const ops = [];
    modules.forEach((row, y) => {
      let start = null;
      row.forEach((cell, x) => {
        if (!cell && start !== null) {
          ops.push(`M${start + margin} ${y + margin}h${x - start}v1H${start + margin}z`);
          start = null;
          return;
        }
        if (cell && start === null) {
          start = x;
        }
      });
      if (start !== null) {
        ops.push(`M${start + margin} ${y + margin}h${row.length - start}v1H${start + margin}z`);
      }
    });
    return ops.join("");
  }
  function excavateModules(modules, excavation) {
    const newModules = modules.map((row) => row.slice());
    for (let y = excavation.y; y < excavation.y + excavation.h; y++) {
      for (let x = excavation.x; x < excavation.x + excavation.w; x++) {
        if (y >= 0 && y < newModules.length && x >= 0 && x < newModules.length) {
          newModules[y][x] = false;
        }
      }
    }
    return newModules;
  }
  function QRCode(props) {
    const {
      value,
      size = 128,
      level = "L",
      bgColor = "#FFFFFF",
      fgColor = "#000000",
      className,
      style,
      title,
      imageSettings,
      ...otherProps
    } = props;
    let qrCode;
    try {
      qrCode = QrCode.encodeText(value, ERROR_LEVEL_MAP[level] || QrCodeEcc.LOW);
    } catch (e) {
      if (e instanceof RangeError && e.message === "Data too long") {
        console.error("QRCode data is too long to be encoded.");
      } else {
        console.error("Failed to generate QR Code:", e);
      }
      return null;
    }
    const cells = qrCode.size;
    const margin = 0;
    const totalCells = cells + margin * 2;
    const viewBox = `0 0 ${totalCells} ${totalCells}`;
    const modules = [];
    for (let y = 0; y < cells; y++) {
      const row = [];
      for (let x = 0; x < cells; x++) {
        row.push(qrCode.getModule(x, y));
      }
      modules.push(row);
    }
    let finalModules = modules;
    let imageElementStr = "";
    if (imageSettings == null ? void 0 : imageSettings.src) {
      const isW = imageSettings.width;
      const isH = imageSettings.height;
      const scale = size / totalCells;
      const logicalW = isW / scale;
      const logicalH = isH / scale;
      const destX = imageSettings.x !== void 0 ? imageSettings.x : (size - isW) / 2;
      const destY = imageSettings.y !== void 0 ? imageSettings.y : (size - isH) / 2;
      const logicalX = destX / scale;
      const logicalY = destY / scale;
      if (imageSettings.excavate) {
        const exX = Math.floor(logicalX);
        const exY = Math.floor(logicalY);
        const exW = Math.ceil(logicalW + (logicalX - exX));
        const exH = Math.ceil(logicalH + (logicalY - exY));
        finalModules = excavateModules(modules, {
          x: exX - margin,
          y: exY - margin,
          w: exW,
          h: exH
        });
      }
      imageElementStr = `<image href="${imageSettings.src}" x="${logicalX}" y="${logicalY}" width="${logicalW}" height="${logicalH}" opacity="${imageSettings.opacity || 1}" preserveAspectRatio="none" />`;
    }
    const pathContent = generatePath(finalModules, margin);
    const svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="${viewBox}" role="img" aria-label="${title || "QR Code"}">
    <rect x="0" y="0" width="${totalCells}" height="${totalCells}" fill="${bgColor}" />
    <path fill="${fgColor}" d="${pathContent}" shape-rendering="crispEdges" />
    ${imageElementStr}
  </svg>`;
    return /* @__PURE__ */ jsx(
      "div",
      {
        class: ["lupine-qrcode", className].filter(Boolean).join(" "),
        style: { ...style, width: size, height: size, display: "inline-block" },
        dangerouslySetInnerHTML: svgString,
        ...otherProps
      }
    );
  }
  var ERROR_LEVEL_MAP;
  var init_qrcode = __esm({
    "node_modules/lupine.components/src/component-pool/qrcode/qrcode.tsx"() {
      init_qrcode_algorithm();
      init_jsx_runtime();
      ERROR_LEVEL_MAP = {
        L: QrCodeEcc.LOW,
        M: QrCodeEcc.MEDIUM,
        Q: QrCodeEcc.QUARTILE,
        H: QrCodeEcc.HIGH
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/qrcode/qrcode-demo.tsx
  var qrcodeDemo;
  var init_qrcode_demo = __esm({
    "node_modules/lupine.components/src/component-pool/qrcode/qrcode-demo.tsx"() {
      init_qrcode();
      init_jsx_runtime();
      qrcodeDemo = {
        id: "qrcode-demo",
        text: "QR Code",
        args: {
          value: "https://lupine.js.org/",
          size: 180,
          fgColor: "#000000",
          bgColor: "#FFFFFF",
          level: "H",
          logoSrc: "",
          logoSize: 36
        },
        argTypes: {
          value: { control: "text", description: "URL or text to encode into the QR code" },
          size: { control: "number", description: "Width and height of the QR code (px)" },
          fgColor: { control: "color", description: "Foreground (module) color" },
          bgColor: { control: "color", description: "Background color" },
          level: {
            control: "select",
            options: ["L", "M", "Q", "H"],
            description: "Error correction level (L=7%, M=15%, Q=25%, H=30%)"
          },
          logoSrc: { control: "file", description: "Logo image to embed in center (upload an image file)" },
          logoSize: { control: "number", description: "Logo image width & height (px)" }
        },
        render: (args) => {
          const imageSettings = args.logoSrc ? { src: args.logoSrc, width: args.logoSize, height: args.logoSize, excavate: true } : void 0;
          return /* @__PURE__ */ jsx("div", { style: { padding: "24px", display: "flex", flexDirection: "column", gap: "32px" }, children: [
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginTop: 0, marginBottom: "12px" }, children: "Interactive QR Code" }),
              /* @__PURE__ */ jsx("p", { style: { color: "#666", fontSize: "12px", marginBottom: "16px" }, children: "Customise the settings in the controls panel on the right." }),
              /* @__PURE__ */ jsx(
                QRCode,
                {
                  value: args.value || "https://lupine.js.org/",
                  size: args.size,
                  fgColor: args.fgColor,
                  bgColor: args.bgColor,
                  level: args.level,
                  imageSettings
                }
              )
            ] }),
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginTop: 0, marginBottom: "12px" }, children: "Colored \u2014 High Error Correction" }),
              /* @__PURE__ */ jsx(
                QRCode,
                {
                  value: "https://en.wikipedia.org/wiki/QR_code",
                  size: 150,
                  fgColor: "#004488",
                  bgColor: "#EEF4FF",
                  level: "H"
                }
              )
            ] }),
            /* @__PURE__ */ jsx("div", { children: [
              /* @__PURE__ */ jsx("h3", { style: { marginTop: 0, marginBottom: "12px" }, children: "With Excavated Logo" }),
              /* @__PURE__ */ jsx(
                QRCode,
                {
                  value: "https://github.com/",
                  size: 120,
                  level: "H",
                  imageSettings: {
                    src: "https://cdn-icons-png.flaticon.com/512/25/25231.png",
                    height: 30,
                    width: 30,
                    excavate: true
                  }
                }
              )
            ] })
          ] });
        },
        code: `import { QRCode } from 'lupine.components/component-pool/qrcode';

// Basic usage
<QRCode value="https://example.com" size={180} />

// With logo excavation
<QRCode
  value="https://example.com"
  size={200}
  level="H"
  imageSettings={{ src: '/logo.png', width: 40, height: 40, excavate: true }}
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/qrcode/index.ts
  var init_qrcode2 = __esm({
    "node_modules/lupine.components/src/component-pool/qrcode/index.ts"() {
      init_qrcode();
      init_qrcode_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/i-editor/i-editor-types.ts
  var HANDLE_SIZE;
  var init_i_editor_types = __esm({
    "node_modules/lupine.components/src/component-pool/i-editor/i-editor-types.ts"() {
      HANDLE_SIZE = 8;
    }
  });

  // node_modules/lupine.components/src/component-pool/i-editor/i-editor-geometry.ts
  function getStickerHandles(s, viewScale) {
    const cx = s.x + s.w / 2, cy = s.y + s.h / 2;
    const rotDist = s.h / 2 + 20 / viewScale;
    return {
      rot: { x: cx + rotDist * Math.sin(s.rotation), y: cy - rotDist * Math.cos(s.rotation) },
      resize: {
        x: cx + s.w / 2 * Math.cos(s.rotation) - s.h / 2 * Math.sin(s.rotation),
        y: cy + s.w / 2 * Math.sin(s.rotation) + s.h / 2 * Math.cos(s.rotation)
      },
      del: {
        x: cx - s.w / 2 * Math.cos(s.rotation) + s.h / 2 * Math.sin(s.rotation),
        y: cy - s.w / 2 * Math.sin(s.rotation) - s.h / 2 * Math.cos(s.rotation)
      }
    };
  }
  function hitSticker(cv, s) {
    const cx = s.x + s.w / 2, cy = s.y + s.h / 2;
    const cos = Math.cos(-s.rotation), sin = Math.sin(-s.rotation);
    const lx = cos * (cv.x - cx) - sin * (cv.y - cy);
    const ly = sin * (cv.x - cx) + cos * (cv.y - cy);
    return lx >= -s.w / 2 && lx <= s.w / 2 && ly >= -s.h / 2 && ly <= s.h / 2;
  }
  function getTextHandles(t, viewScale, ctx, textFontFn) {
    ctx.font = textFontFn(t);
    const m = ctx.measureText(t.text);
    const w = m.width;
    const h = t.fontSize;
    const cx = t.x, cy = t.y;
    const rotDist = h / 2 + 20 / viewScale;
    return {
      rot: { x: cx + rotDist * Math.sin(t.rotation), y: cy - rotDist * Math.cos(t.rotation) },
      resize: {
        x: cx + w / 2 * Math.cos(t.rotation) - h / 2 * Math.sin(t.rotation) + 2 * Math.cos(t.rotation),
        y: cy + w / 2 * Math.sin(t.rotation) + h / 2 * Math.cos(t.rotation) + 2 * Math.sin(t.rotation)
      },
      del: {
        x: cx - w / 2 * Math.cos(t.rotation) + h / 2 * Math.sin(t.rotation) - 2 * Math.cos(t.rotation),
        y: cy - w / 2 * Math.sin(t.rotation) - h / 2 * Math.cos(t.rotation) - 2 * Math.sin(t.rotation)
      }
    };
  }
  function hitText(cv, t, ctx, textFontFn) {
    ctx.font = textFontFn(t);
    const m = ctx.measureText(t.text);
    const w = m.width;
    const h = t.fontSize;
    const cx = t.x, cy = t.y;
    const cos = Math.cos(-t.rotation), sin = Math.sin(-t.rotation);
    const lx = cos * (cv.x - cx) - sin * (cv.y - cy);
    const ly = sin * (cv.x - cx) + cos * (cv.y - cy);
    return lx >= -w / 2 - 4 && lx <= w / 2 + 4 && ly >= -h / 2 - 4 && ly <= h / 2 + 4;
  }
  function getShapeBoundingBox(s) {
    if (s.type === "pencil" && s.points && s.points.length > 0) {
      let minX = s.points[0].x, maxX = s.points[0].x;
      let minY = s.points[0].y, maxY = s.points[0].y;
      for (const p of s.points) {
        if (p.x < minX) minX = p.x;
        if (p.x > maxX) maxX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.y > maxY) maxY = p.y;
      }
      return { cx: (minX + maxX) / 2, cy: (minY + maxY) / 2, w: maxX - minX, h: maxY - minY };
    } else if (s.type === "circle" || s.type === "star") {
      const radius = Math.hypot(s.w - s.x, s.h - s.y);
      return { cx: s.x, cy: s.y, w: radius * 2, h: radius * 2 };
    } else {
      const minX = Math.min(s.x, s.w);
      const maxX = Math.max(s.x, s.w);
      const minY = Math.min(s.y, s.h);
      const maxY = Math.max(s.y, s.h);
      return { cx: (minX + maxX) / 2, cy: (minY + maxY) / 2, w: maxX - minX, h: maxY - minY };
    }
  }
  function getShapeHandles(s, viewScale) {
    const { cx, cy, w, h } = getShapeBoundingBox(s);
    const bw = Math.max(w, 20);
    const bh = Math.max(h, 20);
    const rotDist = bh / 2 + 20 / viewScale;
    const rot = s.rotation || 0;
    return {
      rot: { x: cx + rotDist * Math.sin(rot), y: cy - rotDist * Math.cos(rot) },
      resize: {
        x: cx + bw / 2 * Math.cos(rot) - bh / 2 * Math.sin(rot),
        y: cy + bw / 2 * Math.sin(rot) + bh / 2 * Math.cos(rot)
      },
      del: {
        x: cx - bw / 2 * Math.cos(rot) + bh / 2 * Math.sin(rot),
        y: cy - bw / 2 * Math.sin(rot) - bh / 2 * Math.cos(rot)
      }
    };
  }
  function hitShape(cv, s) {
    const { cx, cy, w, h } = getShapeBoundingBox(s);
    const bw = Math.max(w, 20);
    const bh = Math.max(h, 20);
    const rot = s.rotation || 0;
    const cos = Math.cos(-rot), sin = Math.sin(-rot);
    const lx = cos * (cv.x - cx) - sin * (cv.y - cy);
    const ly = sin * (cv.x - cx) + cos * (cv.y - cy);
    const pad = s.strokeWidth / 2 + 6;
    return lx >= -bw / 2 - pad && lx <= bw / 2 + pad && ly >= -bh / 2 - pad && ly <= bh / 2 + pad;
  }
  var init_i_editor_geometry = __esm({
    "node_modules/lupine.components/src/component-pool/i-editor/i-editor-geometry.ts"() {
    }
  });

  // node_modules/lupine.components/src/component-pool/i-editor/i-editor-drawing.ts
  function drawHeartPath(ctx, cx, cy, size) {
    const s = size / 10;
    const x = (v) => cx + (v - 12) * s;
    const y = (v) => cy + (v - 12) * s;
    ctx.moveTo(x(12), y(21.35));
    ctx.lineTo(x(10.55), y(20.03));
    ctx.bezierCurveTo(x(5.4), y(15.36), x(2), y(12.28), x(2), y(8.5));
    ctx.bezierCurveTo(x(2), y(5.42), x(4.42), y(3), x(7.5), y(3));
    ctx.bezierCurveTo(x(9.24), y(3), x(10.91), y(3.81), x(12), y(5.09));
    ctx.bezierCurveTo(x(13.09), y(3.81), x(14.76), y(3), x(16.5), y(3));
    ctx.bezierCurveTo(x(19.58), y(3), x(22), y(5.42), x(22), y(8.5));
    ctx.bezierCurveTo(x(22), y(12.28), x(18.6), y(15.36), x(13.45), y(20.04));
    ctx.closePath();
  }
  function drawDeleteHandle(ctx, x, y, size) {
    ctx.save();
    ctx.translate(x, y);
    ctx.beginPath();
    ctx.arc(0, 0, size, 0, Math.PI * 2);
    ctx.fillStyle = "#ff4d4d";
    ctx.fill();
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.beginPath();
    const offset = size * 0.4;
    ctx.moveTo(-offset, -offset);
    ctx.lineTo(offset, offset);
    ctx.moveTo(offset, -offset);
    ctx.lineTo(-offset, offset);
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.stroke();
    ctx.restore();
  }
  function buildBubblePath(ctx, tw, th, lx, ly, tailActive) {
    ctx.beginPath();
    const pad = 10;
    const hw = tw / 2 + pad;
    const hh = th / 2 + pad;
    if (!tailActive || lx === 0 && ly === 0) {
      ctx.rect(-hw, -hh, hw * 2, hh * 2);
      return;
    }
    const theta = Math.atan2(ly, lx);
    const a1 = Math.atan2(hh, hw);
    const a2 = Math.PI - a1;
    const hb = 8 + th * 0.15;
    let edge = "";
    if (theta >= -a1 && theta <= a1) edge = "right";
    else if (theta > a1 && theta < a2) edge = "bottom";
    else if (theta >= a2 || theta <= -a2) edge = "left";
    else edge = "top";
    ctx.moveTo(-hw, -hh);
    if (edge === "top") {
      let cx = lx * (-hh / ly);
      cx = Math.max(-hw + hb, Math.min(hw - hb, cx));
      ctx.lineTo(cx - hb, -hh);
      ctx.lineTo(lx, ly);
      ctx.lineTo(cx + hb, -hh);
    }
    ctx.lineTo(hw, -hh);
    if (edge === "right") {
      let cy = ly * (hw / lx);
      cy = Math.max(-hh + hb, Math.min(hh - hb, cy));
      ctx.lineTo(hw, cy - hb);
      ctx.lineTo(lx, ly);
      ctx.lineTo(hw, cy + hb);
    }
    ctx.lineTo(hw, hh);
    if (edge === "bottom") {
      let cx = lx * (hh / ly);
      cx = Math.max(-hw + hb, Math.min(hw - hb, cx));
      ctx.lineTo(cx + hb, hh);
      ctx.lineTo(lx, ly);
      ctx.lineTo(cx - hb, hh);
    }
    ctx.lineTo(-hw, hh);
    if (edge === "left") {
      let cy = ly * (-hw / lx);
      cy = Math.max(-hh + hb, Math.min(hh - hb, cy));
      ctx.lineTo(-hw, cy + hb);
      ctx.lineTo(lx, ly);
      ctx.lineTo(-hw, cy - hb);
    }
    ctx.closePath();
  }
  function drawShapePath(ctx, mode, arrowType, color, sw, sh, fx, fy) {
    ctx.beginPath();
    switch (mode) {
      case "line":
        ctx.moveTo(sw, sh);
        ctx.lineTo(fx, fy);
        ctx.stroke();
        break;
      case "circle": {
        const radius = Math.hypot(fx - sw, fy - sh);
        ctx.arc(sw, sh, radius, 0, Math.PI * 2);
        ctx.stroke();
        break;
      }
      case "rect": {
        const w = fx - sw;
        const h = fy - sh;
        ctx.rect(sw, sh, w, h);
        ctx.stroke();
        break;
      }
      case "triangle": {
        ctx.moveTo(sw + (fx - sw) / 2, sh);
        ctx.lineTo(fx, fy);
        ctx.lineTo(sw, fy);
        ctx.closePath();
        ctx.stroke();
        break;
      }
      case "star": {
        const spikes = 5;
        const outerRadius = Math.hypot(fx - sw, fy - sh);
        const innerRadius = outerRadius / 2.5;
        let rot = Math.PI / 2 * 3;
        const step = Math.PI / spikes;
        for (let i = 0; i < spikes; i++) {
          const xOuter = sw + Math.cos(rot) * outerRadius;
          const yOuter = sh + Math.sin(rot) * outerRadius;
          ctx.lineTo(xOuter, yOuter);
          rot += step;
          const xInner = sw + Math.cos(rot) * innerRadius;
          const yInner = sh + Math.sin(rot) * innerRadius;
          ctx.lineTo(xInner, yInner);
          rot += step;
        }
        ctx.closePath();
        ctx.stroke();
        break;
      }
      case "arrow": {
        const dist = Math.hypot(fx - sw, fy - sh);
        if (dist < 2) return;
        const arrowAngle = Math.atan2(fy - sh, fx - sw);
        const headlen = Math.max(10, dist * 0.2);
        const arrowAngleSpan = Math.PI / 6;
        if (arrowType === "standard" || arrowType === "double") {
          ctx.moveTo(sw, sh);
          ctx.lineTo(fx, fy);
          ctx.moveTo(fx, fy);
          ctx.lineTo(
            fx - headlen * Math.cos(arrowAngle - arrowAngleSpan),
            fy - headlen * Math.sin(arrowAngle - arrowAngleSpan)
          );
          ctx.moveTo(fx, fy);
          ctx.lineTo(
            fx - headlen * Math.cos(arrowAngle + arrowAngleSpan),
            fy - headlen * Math.sin(arrowAngle + arrowAngleSpan)
          );
          if (arrowType === "double") {
            ctx.moveTo(sw, sh);
            ctx.lineTo(
              sw + headlen * Math.cos(arrowAngle - arrowAngleSpan),
              sh + headlen * Math.sin(arrowAngle - arrowAngleSpan)
            );
            ctx.moveTo(sw, sh);
            ctx.lineTo(
              sw + headlen * Math.cos(arrowAngle + arrowAngleSpan),
              sh + headlen * Math.sin(arrowAngle + arrowAngleSpan)
            );
          }
          ctx.stroke();
        } else if (arrowType === "thick") {
          const shaftWidth = dist * 0.1;
          const headWidth = dist * 0.25;
          const shaftLength = dist - headlen;
          ctx.save();
          ctx.translate(sw, sh);
          ctx.rotate(arrowAngle);
          ctx.moveTo(0, -shaftWidth / 2);
          ctx.lineTo(shaftLength, -shaftWidth / 2);
          ctx.lineTo(shaftLength, -headWidth);
          ctx.lineTo(dist, 0);
          ctx.lineTo(shaftLength, headWidth);
          ctx.lineTo(shaftLength, shaftWidth / 2);
          ctx.lineTo(0, shaftWidth / 2);
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        } else if (arrowType === "fishtail") {
          const fLen = dist;
          const bodyW = fLen * 0.22;
          const notchX = fLen * 0.15;
          const hLen = Math.max(12, fLen * 0.28);
          const hW = fLen * 0.35;
          ctx.save();
          ctx.translate(sw, sh);
          ctx.rotate(arrowAngle);
          ctx.beginPath();
          ctx.moveTo(0, -bodyW / 2);
          ctx.lineTo(notchX, 0);
          ctx.lineTo(0, bodyW / 2);
          ctx.lineTo(fLen - hLen, bodyW / 2);
          ctx.lineTo(fLen - hLen, hW / 2);
          ctx.lineTo(fLen, 0);
          ctx.lineTo(fLen - hLen, -hW / 2);
          ctx.lineTo(fLen - hLen, -bodyW / 2);
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        } else if (arrowType === "arc") {
          const cpFactor = 0.35;
          const cpOffset = dist * cpFactor;
          const mx = (sw + fx) / 2;
          const my = (sh + fy) / 2;
          const dx = fx - sw;
          const dy = fy - sh;
          const px = -dy / dist * cpOffset;
          const py = dx / dist * cpOffset;
          const cpx = mx + px;
          const cpy = my + py;
          ctx.beginPath();
          ctx.moveTo(sw, sh);
          ctx.quadraticCurveTo(cpx, cpy, fx, fy);
          ctx.stroke();
          const tx = fx - cpx;
          const ty = fy - cpy;
          const tangAngle = Math.atan2(ty, tx);
          const hLen = Math.max(10, dist * 0.18);
          const hAngle = Math.PI / 7;
          ctx.save();
          ctx.translate(fx, fy);
          ctx.rotate(tangAngle);
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(-hLen * Math.cos(hAngle), -hLen * Math.sin(hAngle));
          ctx.lineTo(-hLen * Math.cos(hAngle), hLen * Math.sin(hAngle));
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        }
        break;
      }
    }
  }
  var init_i_editor_drawing = __esm({
    "node_modules/lupine.components/src/component-pool/i-editor/i-editor-drawing.ts"() {
    }
  });

  // node_modules/lupine.components/src/component-pool/i-editor/i-editor-frames.ts
  function drawFrame(ctx, w, h, style, frameColor) {
    ctx.save();
    if (style === "border") {
      ctx.strokeStyle = frameColor;
      ctx.lineWidth = 20;
      ctx.strokeRect(10, 10, w - 20, h - 20);
    } else if (style === "polaroid") {
      ctx.fillStyle = frameColor;
      ctx.beginPath();
      ctx.rect(0, 0, w, h);
      ctx.rect(w * 0.05, h * 0.05, w * 0.9, h * 0.75);
      ctx.fill("evenodd");
      ctx.strokeStyle = "#ddd";
      ctx.lineWidth = 1;
      ctx.strokeRect(w * 0.05, h * 0.05, w * 0.9, h * 0.75);
    } else if (style === "vignette") {
      const grad = ctx.createRadialGradient(w / 2, h / 2, Math.min(w, h) * 0.3, w / 2, h / 2, Math.max(w, h) * 0.6);
      grad.addColorStop(0, "rgba(0,0,0,0)");
      grad.addColorStop(1, "rgba(0,0,0,0.7)");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);
    } else if (style === "film") {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, w, h * 0.1);
      ctx.fillRect(0, h * 0.9, w, h);
      ctx.fillStyle = frameColor;
      for (let x = 10; x < w; x += 30) {
        ctx.fillRect(x, h * 0.02, 15, h * 0.06);
        ctx.fillRect(x, h * 0.92, 15, h * 0.06);
      }
    } else if (style === "double") {
      ctx.strokeStyle = frameColor;
      ctx.lineWidth = 4;
      ctx.strokeRect(10, 10, w - 20, h - 20);
      ctx.strokeRect(20, 20, w - 40, h - 40);
    }
    ctx.restore();
  }
  var init_i_editor_frames = __esm({
    "node_modules/lupine.components/src/component-pool/i-editor/i-editor-frames.ts"() {
    }
  });

  // node_modules/lupine.components/src/component-pool/i-editor/i-editor-image.ts
  function applyMosaic(imageData, targetWidth, targetHeight, x0, y0, cx, cy, mosaicSize) {
    const r = 20;
    const minX = Math.max(0, Math.floor(x0 - r));
    const maxX = Math.min(targetWidth - 1, Math.ceil(x0 + r));
    const minY = Math.max(0, Math.floor(y0 - r));
    const maxY = Math.min(targetHeight - 1, Math.ceil(y0 + r));
    const newImgData = new ImageData(new Uint8ClampedArray(imageData.data), imageData.width, imageData.height);
    const data = newImgData.data;
    const startBX = Math.floor(minX / mosaicSize) * mosaicSize;
    const startBY = Math.floor(minY / mosaicSize) * mosaicSize;
    for (let by = startBY; by <= maxY; by += mosaicSize) {
      for (let bx = startBX; bx <= maxX; bx += mosaicSize) {
        const blockCX = bx + mosaicSize / 2;
        const blockCY = by + mosaicSize / 2;
        const distToLine = Math.abs((cy - y0) * blockCX - (cx - x0) * blockCY + cx * y0 - cy * x0) / Math.hypot(cy - y0, cx - x0) || Math.hypot(blockCX - x0, blockCY - y0);
        if (distToLine < r + mosaicSize) {
          let rSum = 0, gSum = 0, bSum = 0, aSum = 0, count = 0;
          const eY = Math.min(by + mosaicSize, targetHeight);
          const eX = Math.min(bx + mosaicSize, targetWidth);
          for (let y = by; y < eY; y++) {
            for (let x = bx; x < eX; x++) {
              const i = (y * targetWidth + x) * 4;
              rSum += data[i];
              gSum += data[i + 1];
              bSum += data[i + 2];
              aSum += data[i + 3];
              count++;
            }
          }
          if (count > 0) {
            const rAvg = rSum / count;
            const gAvg = gSum / count;
            const bAvg = bSum / count;
            const aAvg = aSum / count;
            for (let y = by; y < eY; y++) {
              for (let x = bx; x < eX; x++) {
                const dot = (x - x0) * (cx - x0) + (y - y0) * (cy - y0);
                const lenSq = (cx - x0) ** 2 + (cy - y0) ** 2;
                let param = -1;
                if (lenSq !== 0) param = dot / lenSq;
                let px, py;
                if (param < 0) {
                  px = x0;
                  py = y0;
                } else if (param > 1) {
                  px = cx;
                  py = cy;
                } else {
                  px = x0 + param * (cx - x0);
                  py = y0 + param * (cy - y0);
                }
                if (Math.hypot(x - px, y - py) < r) {
                  const i = (y * targetWidth + x) * 4;
                  data[i] = rAvg;
                  data[i + 1] = gAvg;
                  data[i + 2] = bAvg;
                  data[i + 3] = aAvg;
                }
              }
            }
          }
        }
      }
    }
    return newImgData;
  }
  function flipImageDataVertical(imgData) {
    const { width, height, data } = imgData;
    const newData = new Uint8ClampedArray(data.length);
    for (let y = 0; y < height; y++) {
      const srcY = height - 1 - y;
      const srcOffset = srcY * width * 4;
      const destOffset = y * width * 4;
      newData.set(data.subarray(srcOffset, srcOffset + width * 4), destOffset);
    }
    return new ImageData(newData, width, height);
  }
  var init_i_editor_image = __esm({
    "node_modules/lupine.components/src/component-pool/i-editor/i-editor-image.ts"() {
    }
  });

  // node_modules/lupine.components/src/component-pool/i-editor/i-editor-styles.ts
  var EDITOR_STYLES;
  var init_i_editor_styles = __esm({
    "node_modules/lupine.components/src/component-pool/i-editor/i-editor-styles.ts"() {
      EDITOR_STYLES = `
  .ie-toolbar { display:flex;flex-wrap:wrap;gap:2px;padding:6px 8px;background:var(--secondary-bg-color,#2a2a2a);border-bottom:1px solid #444;user-select:none;flex-shrink:0; }
  .ie-grp { display:flex;gap:2px;align-items:center;padding:0 4px;border-right:1px solid #555; }
  .ie-grp:last-child { border-right:none; }
  .ie-btn { display:inline-flex;align-items:center;justify-content:center;border:1px solid transparent;border-radius:4px;cursor:pointer;color:var(--primary-color,#ccc);transition:background .15s;flex-shrink:0; }
  .ie-btn:hover { background:var(--primary-accent-color,#0a74c9);color:#fff; }
  .ie-btn.active { background:var(--primary-accent-color,#0a74c9);color:#fff; }
  
  .ie-canvas-wrap { flex:1;overflow:hidden;position:relative;background:repeating-conic-gradient(#888 0% 25%,#aaa 0% 50%) 0 0/20px 20px;cursor:crosshair; }
  .ie-canvas { position:absolute;top:0;left:0; }
  .ie-opts { display:flex;flex-wrap:wrap;gap:6px;align-items:center;padding:4px 10px;background:#eee;border-top:1px solid #ccc;font-size:12px;color:#333;flex-shrink:0;min-height:36px; }
  .ie-sub-opts { display:flex;flex-wrap:wrap;gap:6px;align-items:center;padding:4px 10px;background:#ddd;border-top:1px solid #ccc;font-size:12px;color:#333;flex-shrink:0;min-height:36px; }
  .ie-opts label { display:flex;align-items:center;gap:4px;color:#333; }
  .ie-opts input[type=color] { width:24px;height:24px;border:none;padding:0;cursor:pointer;background:none; }
  .ie-opts input[type=range] { width:80px;cursor:pointer; }
  .ie-opts button { display:inline-flex;align-items:center;justify-content:center;padding:2px 8px;border-radius:3px;border:1px solid #ccc;color:#333;cursor:pointer;font-size:12px;min-height:30px;mask-size: 19px 19px; }
  .ie-opts button:hover { background-color: var(--primary-accent-color, #0a74c9); }
  .ie-text-input { position:absolute;z-index:200;font-size:18px;border:2px dashed #0af;background:rgba(0,0,0,.7);color:#fff;padding:2px 8px;min-width:100px;border-radius:3px;outline:none; }
  .ie-crop-overlay { position:absolute;inset:0;z-index:100;cursor:default; }
  .ie-crop-frame { position:absolute;box-shadow:0 0 0 9999px rgba(0,0,0,.55);border:2px solid #fff;cursor:move;box-sizing:border-box; }
  .ie-handle { position:absolute;width:10px;height:10px;background:#fff;border:1px solid #333;border-radius:2px; }
`;
    }
  });

  // node_modules/lupine.components/src/component-pool/i-editor/i-editor.ts
  var IEditor;
  var init_i_editor = __esm({
    "node_modules/lupine.components/src/component-pool/i-editor/i-editor.ts"() {
      init_i_editor_types();
      init_i_editor_geometry();
      init_i_editor_drawing();
      init_i_editor_frames();
      init_i_editor_image();
      init_i_editor_styles();
      init_svg_icons();
      init_action_sheet();
      IEditor = class _IEditor {
        container;
        canvas;
        ctx;
        offCanvas = document.createElement("canvas");
        offCtx;
        displayObjects = [];
        viewScale = 1;
        viewOffX = 0;
        viewOffY = 0;
        get textLayers() {
          return this.displayObjects.filter((o) => o.type === "text").map((o) => o.layer);
        }
        get stickerLayers() {
          return this.displayObjects.filter((o) => o.type === "sticker").map((o) => o.layer);
        }
        get shapes() {
          return this.displayObjects.filter((o) => o.type === "shape").map((o) => o.layer);
        }
        undoStack = [];
        redoStack = [];
        activeTool = "pan";
        isPointerDown = false;
        lastX = 0;
        lastY = 0;
        zoomSliderRange;
        zoomSliderLabel;
        resizeBgColor = null;
        eraserSize = 20;
        isErasing = false;
        eraserLastX = 0;
        eraserLastY = 0;
        mosaicLastX = 0;
        mosaicLastY = 0;
        activePointers = /* @__PURE__ */ new Map();
        initialPinchDist = 0;
        initialPinchScale = 1;
        pinchCenter = { x: 0, y: 0 };
        brushSizeInput;
        brushSizeVal;
        optsWrap;
        rotSliderRange;
        penColor = "#e74c3c";
        penSize = 8;
        penMode = "pencil";
        penArrowType = "standard";
        penStartX = 0;
        penStartY = 0;
        mosaicSize = 16;
        // Select tool state
        selStartX = 0;
        selStartY = 0;
        selEndX = 0;
        selEndY = 0;
        hasSelection = false;
        // Crop overlay state (DOM-based)
        cropOverlayEl = null;
        cropFrameEl = null;
        cropX = 50;
        cropY = 50;
        cropW = 200;
        cropH = 150;
        cropDragMode = null;
        cropDragStartX = 0;
        cropDragStartY = 0;
        cropStartState = { x: 0, y: 0, w: 0, h: 0 };
        // Active draggable layers
        activeText = null;
        activeSticker = null;
        rotatingSticker = null;
        resizingSticker = null;
        resizingText = null;
        rotatingText = null;
        movingTail = null;
        selectedSticker = null;
        selectedText = null;
        selectedShape = null;
        activeShape = null;
        // Used during active path drawing
        movingShape = null;
        rotatingShape = null;
        resizingShape = null;
        editingTextId = null;
        textColor = "#ff0000";
        textFontSize = 24;
        textFontFamily = "sans-serif";
        textBold = false;
        textItalic = false;
        textStrokeColor = "#000000";
        textStrokeWidth = 0;
        textTailActive = false;
        penDrawing = false;
        // Clipboard (copied region)
        clipboardImg = null;
        // Adjustments (Brightness and Contrast and Color Balance)
        adjustBrightness = 100;
        adjustContrast = 100;
        adjustRed = 100;
        adjustGreen = 100;
        adjustBlue = 100;
        // Round Corners Tool
        roundRadius = 0;
        roundIsCircle = false;
        roundIsHeart = false;
        // Frame Tool
        currentFrame = "none";
        frameColor = "#ffffff";
        rotateValue = 0;
        textInput = null;
        subOptionsBarEl;
        optionsBarEl;
        static getEditor(container, options3) {
          return new _IEditor(container, options3);
        }
        constructor(container, options3) {
          this.container = container;
          this.offCtx = this.offCanvas.getContext("2d", { willReadFrequently: true });
          Object.assign(container.style, {
            display: "flex",
            flexDirection: "column",
            height: "100%",
            overflow: "hidden",
            fontFamily: "sans-serif",
            background: "var(--primary-bg-color, #1a1a1a)"
          });
          this._injectStyles();
          this._buildToolbar();
          const wrap2 = document.createElement("div");
          wrap2.className = "ie-canvas-wrap";
          container.appendChild(wrap2);
          this.canvas = document.createElement("canvas");
          this.canvas.className = "ie-canvas";
          wrap2.appendChild(this.canvas);
          this.ctx = this.canvas.getContext("2d");
          const zoomOverlay = document.createElement("div");
          Object.assign(zoomOverlay.style, {
            position: "absolute",
            left: "10px",
            bottom: "10px",
            display: "flex",
            alignItems: "center",
            gap: "8px",
            background: "rgba(40,40,40,0.85)",
            padding: "4px 10px",
            borderRadius: "20px",
            boxShadow: "0 2px 6px rgba(0,0,0,0.5)",
            color: "#ccc",
            fontSize: "12px",
            zIndex: "var(--layer-cover, 200)"
          });
          this.zoomSliderRange = document.createElement("input");
          this.zoomSliderRange.type = "range";
          this.zoomSliderRange.min = "0.05";
          this.zoomSliderRange.max = "8";
          this.zoomSliderRange.step = "0.05";
          this.zoomSliderRange.value = "1";
          this.zoomSliderRange.style.width = "100px";
          this.zoomSliderRange.style.cursor = "pointer";
          this.zoomSliderLabel = document.createElement("span");
          this.zoomSliderLabel.textContent = "100%";
          this.zoomSliderLabel.style.minWidth = "36px";
          this.zoomSliderLabel.style.textAlign = "right";
          this.zoomSliderRange.oninput = () => {
            const ns = parseFloat(this.zoomSliderRange.value);
            const cx = this.canvas.width / 2, cy = this.canvas.height / 2;
            this.viewOffX = cx - (cx - this.viewOffX) * (ns / this.viewScale);
            this.viewOffY = cy - (cy - this.viewOffY) * (ns / this.viewScale);
            this.viewScale = ns;
            this.zoomSliderLabel.textContent = `${Math.round(this.viewScale * 100)}%`;
            if (this.activeTool === "pan") this._updateOpts();
            this._redraw();
          };
          zoomOverlay.appendChild(this.zoomSliderRange);
          zoomOverlay.appendChild(this.zoomSliderLabel);
          wrap2.appendChild(zoomOverlay);
          this.subOptionsBarEl = document.createElement("div");
          this.subOptionsBarEl.className = "ie-sub-opts";
          this.subOptionsBarEl.style.display = "none";
          container.appendChild(this.subOptionsBarEl);
          this.optionsBarEl = document.createElement("div");
          this.optionsBarEl.className = "ie-opts";
          container.appendChild(this.optionsBarEl);
          this._attachEvents();
          this._setTool("pan");
          if (options3 == null ? void 0 : options3.imageSrc) this.loadImageFromUrl(options3.imageSrc);
          else this._initBlank(800, 600);
        }
        _injectStyles() {
          if (document.getElementById("ie-styles")) return;
          loadSvgIconStyles();
          const s = document.createElement("style");
          s.id = "ie-styles";
          s.textContent = EDITOR_STYLES;
          document.head.appendChild(s);
        }
        _btn(id, title, iconClass, fn) {
          const b = document.createElement("button");
          b.className = `ie-btn ${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${iconClass}`;
          b.title = title;
          b.id = `ieb-${id}`;
          b.addEventListener("click", fn);
          return b;
        }
        _grp(...btns) {
          const g = document.createElement("div");
          g.className = "ie-grp";
          btns.forEach((b) => g.appendChild(b));
          return g;
        }
        _buildToolbar() {
          var _a;
          const tb = document.createElement("div");
          tb.className = "ie-toolbar";
          tb.appendChild(
            this._grp(
              this._btn("undo", "Undo", SvgIconNames.undo, () => this.undo()),
              this._btn("redo", "Redo", SvgIconNames.redo, () => this.redo())
            )
          );
          tb.appendChild(
            this._grp(
              this._btn("upload", "Upload Image", SvgIconNames.upload, () => this._triggerUpload()),
              this._btn("download", "Download", SvgIconNames.download, () => this._showDownload())
            )
          );
          tb.appendChild(
            this._grp(
              this._btn("zoomIn", "Zoom In", SvgIconNames.zoomIn, () => this._zoom(0.15)),
              this._btn("zoomOut", "Zoom Out", SvgIconNames.zoomOut, () => this._zoom(-0.15))
            )
          );
          tb.appendChild(
            this._grp(
              this._btn("rotate", "Rotate / Flip", SvgIconNames.rotate, () => this._setTool("rotate")),
              this._btn("resize", "Resize", SvgIconNames.resize, () => this._promptResize())
            )
          );
          tb.appendChild(
            this._grp(
              this._btn("pan", "Pan", SvgIconNames.pan, () => this._setTool("pan")),
              this._btn("select", "Select / Copy", SvgIconNames.select, () => this._setTool("select")),
              this._btn("crop", "Crop Frame", SvgIconNames.crop, () => this._setTool("crop")),
              this._btn("pencil", "Draw", SvgIconNames.pencil, () => this._setTool("pencil")),
              this._btn("mosaic", "Mosaic", SvgIconNames.mosaic, () => this._setTool("mosaic")),
              this._btn("eraser", "Eraser", SvgIconNames.removeformat, () => this._setTool("eraser")),
              this._btn("text", "Text", SvgIconNames.text, () => this._setTool("text")),
              this._btn("sticker", "Sticker", SvgIconNames.sticker, () => this._setTool("sticker")),
              this._btn("adjust", "Adjust Color", SvgIconNames.adjust, () => this._setTool("adjust")),
              this._btn("round", "Round Corners", SvgIconNames.round, () => this._setTool("round")),
              this._btn("frame", "Frame", SvgIconNames.frame, () => this._setTool("frame"))
            )
          );
          this.container.insertBefore(tb, ((_a = this.optionsBarEl) == null ? void 0 : _a.parentElement) ?? this.container.firstChild);
          this.container.appendChild(tb);
          document.addEventListener("keydown", (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === "z") {
              e.preventDefault();
              this.undo();
            }
            if ((e.ctrlKey || e.metaKey) && (e.key === "y" || e.key === "Z")) {
              e.preventDefault();
              this.redo();
            }
            if ((e.ctrlKey || e.metaKey) && e.key === "v") {
              e.preventDefault();
              this._pasteClipboard();
            }
          });
        }
        _setTool(t, keepSelection = false) {
          if (this.textInput) this._commitText();
          this._removeCropOverlay();
          if (!keepSelection && (t === "pencil" || t === "text" || t === "sticker" || t === "mosaic" || t === "eraser")) {
            this.hasSelection = false;
            this.selectedSticker = null;
            this.selectedText = null;
            this.selectedShape = null;
          }
          this.activeTool = t;
          [
            "pan",
            "select",
            "crop",
            "pencil",
            "mosaic",
            "eraser",
            "text",
            "sticker",
            "adjust",
            "round",
            "frame",
            "rotate"
          ].forEach((name) => {
            const el = this.container.querySelector(`#ieb-${name}`);
            if (el) el.classList.toggle("active", name === t);
          });
          this._updateOpts();
          if (t === "crop") this._initCropOverlay();
          this._redraw();
        }
        _updateOpts() {
          const el = this.optionsBarEl;
          const subEl = this.subOptionsBarEl;
          el.innerHTML = "";
          subEl.innerHTML = "";
          subEl.style.display = "none";
          const txt = (s) => el.appendChild(Object.assign(document.createElement("span"), { textContent: s }));
          const btn = (label, fn) => {
            const b = document.createElement("button");
            b.textContent = label;
            b.addEventListener("click", fn);
            el.appendChild(b);
          };
          const lbl = (html2, fn, type = "text", val = "") => {
            const l = document.createElement("label");
            l.innerHTML = html2;
            const i = l.querySelector("input");
            if (val) i.value = val;
            i.oninput = () => fn(i.value);
            el.appendChild(l);
          };
          const isUniversalMode = this.activeTool === "pan" || this.activeTool === "select" || this.activeTool === "mosaic" || this.activeTool === "eraser" || this.activeTool === "text" || this.activeTool === "pencil" || this.activeTool === "sticker";
          const showShapeOpts = this.activeTool === "pencil" || this.selectedShape && ["pan", "select", "mosaic", "eraser"].includes(this.activeTool);
          const showTextOpts = this.activeTool === "text" || this.selectedText && ["pan", "select", "mosaic", "eraser"].includes(this.activeTool);
          if (showShapeOpts) {
            const curShape = this.selectedShape;
            const curColor = curShape ? curShape.color : this.penColor;
            const curSize = curShape ? curShape.strokeWidth : this.penSize;
            lbl(`Color:<input type="color" value="${curColor}"/>`, (v) => {
              this.penColor = v;
              if (curShape) {
                curShape.color = v;
                this._redraw();
              }
            });
            const ls = document.createElement("label");
            ls.innerHTML = `Size:<input type="range" min="1" max="60" value="${curSize}"/><span>${curSize}px</span>`;
            const si = ls.querySelector("input");
            const ss = ls.querySelector("span");
            si.oninput = () => {
              const v = Number(si.value);
              this.penSize = v;
              ss.textContent = `${v}px`;
              if (curShape) {
                curShape.strokeWidth = v;
                this._redraw();
              }
            };
            el.appendChild(ls);
            const curMode = curShape ? curShape.type : this.penMode;
            const modeLbl = document.createElement("label");
            modeLbl.innerHTML = `Mode:<select style="padding:2px;border:1px solid #555;background:#333;color:#ccc;border-radius:3px">
        <option value="pencil" ${curMode === "pencil" ? "selected" : ""}>Pencil</option>
        <option value="line" ${curMode === "line" ? "selected" : ""}>Line</option>
        <option value="arrow" ${curMode === "arrow" ? "selected" : ""}>Arrow</option>
        <option value="circle" ${curMode === "circle" ? "selected" : ""}>Ellipse</option>
        <option value="rect" ${curMode === "rect" ? "selected" : ""}>Rectangle</option>
        <option value="triangle" ${curMode === "triangle" ? "selected" : ""}>Triangle</option>
        <option value="star" ${curMode === "star" ? "selected" : ""}>Star</option>
      </select>`;
            const ms = modeLbl.querySelector("select");
            ms.onchange = () => {
              this.penMode = ms.value;
              if (curShape) {
                curShape.type = this.penMode;
                this._redraw();
              }
              this._updateOpts();
            };
            el.appendChild(modeLbl);
            if (curMode === "arrow") {
              const atLbl = document.createElement("label");
              const curArrowType = curShape ? curShape.arrowType || "standard" : this.penArrowType;
              atLbl.innerHTML = `Type:<select style="padding:2px;border:1px solid #555;background:#333;color:#ccc;border-radius:3px">
          <option value="standard" ${curArrowType === "standard" ? "selected" : ""}>Standard</option>
          <option value="double" ${curArrowType === "double" ? "selected" : ""}>Double</option>
          <option value="thick" ${curArrowType === "thick" ? "selected" : ""}>Thick</option>
          <option value="fishtail" ${curArrowType === "fishtail" ? "selected" : ""}>Fishtail</option>
          <option value="arc" ${curArrowType === "arc" ? "selected" : ""}>Arc</option>
        </select>`;
              const as = atLbl.querySelector("select");
              as.onchange = () => {
                this.penArrowType = as.value;
                if (curShape) {
                  curShape.arrowType = this.penArrowType;
                  this._redraw();
                }
              };
              el.appendChild(atLbl);
            }
            txt(" (Hold Shift for constraints)");
          } else if (showTextOpts) {
            if (this.textInput) {
              const lbl2 = document.createElement("span");
              lbl2.textContent = "Typing text... (Use floating toolbar above)";
              lbl2.style.padding = "0 8px";
              lbl2.style.color = "#888";
              el.appendChild(lbl2);
              return;
            }
            const t = this.selectedText;
            const curColor = t ? t.color : this.textColor;
            const curSize = t ? t.fontSize : this.textFontSize;
            const curFamily = t ? t.fontFamily : this.textFontFamily;
            const curBold = t ? t.bold : this.textBold;
            const curItalic = t ? t.italic : this.textItalic;
            if (t) {
              lbl(
                `Text:<input type="text" value="${t.text}" style="width:100px;padding:2px;border:1px solid #555;background:#333;color:#ccc;border-radius:3px"/>`,
                (v) => {
                  t.text = v;
                  this._redraw();
                }
              );
            }
            lbl(`Color:<input type="color" value="${curColor}"/>`, (v) => {
              this.textColor = v;
              if (t) {
                t.color = v;
                this._redraw();
              }
            });
            const fsLbl = document.createElement("label");
            fsLbl.innerHTML = `Size:<input type="range" min="12" max="120" value="${curSize}"/><span>${curSize}px</span>`;
            const fi = fsLbl.querySelector("input");
            const fsp = fsLbl.querySelector("span");
            fi.oninput = () => {
              const v = Number(fi.value);
              this.textFontSize = v;
              fsp.textContent = `${v}px`;
              if (t) {
                t.fontSize = v;
                this._redraw();
              }
            };
            el.appendChild(fsLbl);
            const fLbl = document.createElement("label");
            fLbl.innerHTML = `Font:<select style="padding:2px;border:1px solid #555;background:#333;color:#ccc;border-radius:3px">
        <option value="sans-serif" ${curFamily === "sans-serif" ? "selected" : ""}>Sans</option>
        <option value="serif" ${curFamily === "serif" ? "selected" : ""}>Serif</option>
        <option value="monospace" ${curFamily === "monospace" ? "selected" : ""}>Mono</option>
        <option value="cursive" ${curFamily === "cursive" ? "selected" : ""}>Cursive</option>
      </select>`;
            const fs = fLbl.querySelector("select");
            fs.onchange = () => {
              this.textFontFamily = fs.value;
              if (t) {
                t.fontFamily = fs.value;
                this._redraw();
              }
            };
            el.appendChild(fLbl);
            const bB = document.createElement("button");
            bB.textContent = "B";
            bB.style.fontWeight = "bold";
            bB.style.background = curBold ? "var(--primary-accent-color,#0a74c9)" : "#eee";
            bB.addEventListener("click", () => {
              this.textBold = !this.textBold;
              if (t) {
                t.bold = this.textBold;
              }
              this._updateOpts();
              this._redraw();
            });
            el.appendChild(bB);
            const bI = document.createElement("button");
            bI.textContent = "I";
            bI.style.fontStyle = "italic";
            bI.style.background = curItalic ? "var(--primary-accent-color,#0a74c9)" : "#eee";
            bI.addEventListener("click", () => {
              this.textItalic = !this.textItalic;
              if (t) {
                t.italic = this.textItalic;
              }
              this._updateOpts();
              this._redraw();
            });
            el.appendChild(bI);
            const strokColorLbl = document.createElement("label");
            strokColorLbl.innerHTML = `OutLine:<input type="color" value="${t ? t.strokeColor : this.textStrokeColor}"/>`;
            const strokColorInp = strokColorLbl.querySelector("input");
            strokColorInp.oninput = () => {
              const v = strokColorInp.value;
              this.textStrokeColor = v;
              if (t) {
                if (!t.strokeWidth || t.strokeWidth === 0) {
                  t.strokeWidth = 2;
                  this.textStrokeWidth = 2;
                }
                t.strokeColor = v;
                this._redraw();
                this._updateOpts();
              }
            };
            el.appendChild(strokColorLbl);
            const widthVal = t && t.strokeWidth !== void 0 ? t.strokeWidth : this.textStrokeWidth;
            if (widthVal > 0) {
              const strokWidthLbl = document.createElement("label");
              strokWidthLbl.innerHTML = `<input type="range" min="1" max="50" value="${widthVal}" style="width:60px" /><span>${widthVal}</span>`;
              const strokWidthInp = strokWidthLbl.querySelector("input");
              const strokWidthSpan = strokWidthLbl.querySelector("span");
              strokWidthInp.oninput = () => {
                const w = Number(strokWidthInp.value);
                this.textStrokeWidth = w;
                strokWidthSpan.textContent = `${w}`;
                if (t) {
                  t.strokeWidth = w;
                  this._redraw();
                }
              };
              el.appendChild(strokWidthLbl);
            }
            const bT = document.createElement("button");
            bT.textContent = "\u{1F5EF}";
            bT.title = "Bubble";
            bT.style.background = (t ? t.tailActive : this.textTailActive) ? "var(--primary-accent-color,#0a74c9)" : "transparent";
            bT.style.fontSize = "14px";
            bT.style.lineHeight = "1";
            bT.style.padding = "2px 4px";
            bT.style.minHeight = "0";
            bT.addEventListener("click", () => {
              this.textTailActive = !this.textTailActive;
              if (t) {
                t.tailActive = this.textTailActive;
              }
              this._updateOpts();
              this._redraw();
            });
            el.appendChild(bT);
            txt("  Click canvas to place.");
          } else if (this.activeTool === "mosaic") {
            const l = document.createElement("label");
            l.innerHTML = `Brush:<input type="range" min="4" max="64" value="${this.mosaicSize}"/><span>${this.mosaicSize}px</span>`;
            const i = l.querySelector("input");
            const sp = l.querySelector("span");
            i.oninput = () => {
              this.mosaicSize = Number(i.value);
              sp.textContent = `${this.mosaicSize}px`;
            };
            el.appendChild(l);
          } else if (this.activeTool === "eraser") {
            const l = document.createElement("label");
            l.innerHTML = `Brush:<input type="range" min="4" max="100" step="2" value="${this.eraserSize}"/><span>${this.eraserSize}px</span>`;
            const i = l.querySelector("input");
            const sp = l.querySelector("span");
            i.oninput = () => {
              this.eraserSize = Number(i.value);
              sp.textContent = `${this.eraserSize}px`;
            };
            el.appendChild(l);
          } else if (this.activeTool === "select") {
            txt("Drag to select. ");
            btn("Copy as Layer", () => this._copySelectionAsSticker());
            if (this.clipboardImg) btn("Paste", () => this._pasteClipboard());
            btn("Clear", () => {
              this.hasSelection = false;
              this._redraw();
            });
          } else if (this.activeTool === "rotate") {
            const g = (iconName, hint, fn) => {
              const b = document.createElement("button");
              b.className = `ie-tool-btn ${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames[iconName]}`;
              b.title = hint;
              b.addEventListener("click", fn);
              el.appendChild(b);
            };
            g("rotL", "Rotate 90\xB0 CCW", () => {
              this._rotate(-90);
              this.rotateValue = 0;
              this._updateOpts();
              this._redraw();
            });
            g("rotR", "Rotate 90\xB0 CW", () => {
              this._rotate(90);
              this.rotateValue = 0;
              this._updateOpts();
              this._redraw();
            });
            g("flipH", "Flip Horizontal", () => {
              this._flip();
              this._updateOpts();
            });
            g("flipV", "Flip Vertical", () => {
              this._flipV();
              this._updateOpts();
            });
            const sL = document.createElement("label");
            sL.style.cssText = "display:flex;align-items:center;gap:6px;margin-left:8px;font-size:13px";
            sL.innerHTML = `Rotate:<input type="range" min="-180" max="180" value="${this.rotateValue}" style="width:80px"/><span>${this.rotateValue}\xB0</span>`;
            const sI = sL.querySelector("input");
            const sS = sL.querySelector("span");
            sI.oninput = () => {
              this.rotateValue = Number(sI.value);
              sS.textContent = `${this.rotateValue}\xB0`;
              this._redraw();
            };
            el.appendChild(sL);
            const aB = document.createElement("button");
            aB.textContent = "Apply";
            aB.addEventListener("click", () => {
              if (this.rotateValue !== 0) {
                const val = this.rotateValue;
                this.rotateValue = 0;
                this._rotate(val);
                this._updateOpts();
              }
              this._redraw();
            });
            el.appendChild(aB);
            const rB = document.createElement("button");
            rB.textContent = "Reset";
            rB.addEventListener("click", () => {
              this.rotateValue = 0;
              this._updateOpts();
              this._redraw();
            });
            el.appendChild(rB);
          } else if (this.activeTool === "crop") {
            txt("Drag handles or frame. ");
            btn("Apply Crop", () => this._applyCrop());
            btn("Cancel", () => this._setTool("pan"));
          } else if (this.activeTool === "sticker") {
            btn("Upload Sticker", () => this._triggerStickerUpload());
            if (this.clipboardImg) btn("Paste Copied Layer", () => this._pasteClipboard());
            txt(" Drag to move, corner=resize, top=rotate.");
          } else if (this.activeTool === "pan") {
            if (this.clipboardImg) btn("Paste", () => this._pasteClipboard());
            txt(` Drag=pan, scroll/pinch=zoom. Scale: ${Math.round(this.viewScale * 100)}%`);
          } else if (this.activeTool === "adjust") {
            const bL = document.createElement("label");
            bL.innerHTML = `Brightness:<input type="range" min="0" max="200" value="${this.adjustBrightness}"/><span style="display:inline-block;width:35px;text-align:right">${this.adjustBrightness}%</span>`;
            const bI = bL.querySelector("input");
            const bS = bL.querySelector("span");
            bI.oninput = () => {
              this.adjustBrightness = Number(bI.value);
              bS.textContent = `${this.adjustBrightness}%`;
              this._redraw();
            };
            el.appendChild(bL);
            const cL = document.createElement("label");
            cL.innerHTML = `Contrast:<input type="range" min="0" max="200" value="${this.adjustContrast}"/><span style="display:inline-block;width:35px;text-align:right">${this.adjustContrast}%</span>`;
            const cI = cL.querySelector("input");
            const cS = cL.querySelector("span");
            cI.oninput = () => {
              this.adjustContrast = Number(cI.value);
              cS.textContent = `${this.adjustContrast}%`;
              this._redraw();
            };
            el.appendChild(cL);
            const mkColorSlider = (lbl2, val, bg, onChange) => {
              const row = document.createElement("label");
              row.style.background = bg;
              row.style.padding = "0 4px";
              row.style.borderRadius = "3px";
              row.innerHTML = `<span style="display:inline-block;width:20px">${lbl2}:</span><input type="range" min="0" max="200" value="${val}"/><span style="display:inline-block;width:35px;text-align:right">${val}%</span>`;
              const rt = row.querySelector("input");
              const rs = row.querySelectorAll("span")[1];
              rt.oninput = () => {
                onChange(Number(rt.value));
                rs.textContent = `${rt.value}%`;
                this._redraw();
              };
              el.appendChild(row);
            };
            mkColorSlider("R", this.adjustRed, "rgba(255,0,0,0.2)", (v) => this.adjustRed = v);
            mkColorSlider("G", this.adjustGreen, "rgba(0,255,0,0.2)", (v) => this.adjustGreen = v);
            mkColorSlider("B", this.adjustBlue, "rgba(0,0,255,0.2)", (v) => this.adjustBlue = v);
            btn("Apply", () => {
              if (this.adjustBrightness === 100 && this.adjustContrast === 100 && this.adjustRed === 100 && this.adjustGreen === 100 && this.adjustBlue === 100) {
                this._setTool("pan");
                return;
              }
              this._mergeLayersToOff();
              this._pushUndo();
              const tmp = document.createElement("canvas");
              tmp.width = this.offCanvas.width;
              tmp.height = this.offCanvas.height;
              const ctx = tmp.getContext("2d");
              ctx.filter = `brightness(${this.adjustBrightness}%) contrast(${this.adjustContrast}%)`;
              ctx.drawImage(this.offCanvas, 0, 0);
              if (this.adjustRed !== 100 || this.adjustGreen !== 100 || this.adjustBlue !== 100) {
                const imgD = ctx.getImageData(0, 0, tmp.width, tmp.height);
                const rf = this.adjustRed / 100;
                const gf = this.adjustGreen / 100;
                const bf = this.adjustBlue / 100;
                for (let i = 0; i < imgD.data.length; i += 4) {
                  imgD.data[i] = Math.min(255, imgD.data[i] * rf);
                  imgD.data[i + 1] = Math.min(255, imgD.data[i + 1] * gf);
                  imgD.data[i + 2] = Math.min(255, imgD.data[i + 2] * bf);
                }
                ctx.putImageData(imgD, 0, 0);
              }
              this.offCtx.clearRect(0, 0, this.offCanvas.width, this.offCanvas.height);
              this.offCtx.drawImage(tmp, 0, 0);
              this.adjustBrightness = 100;
              this.adjustContrast = 100;
              this.adjustRed = 100;
              this.adjustGreen = 100;
              this.adjustBlue = 100;
              this._setTool("pan");
            });
            const g = (iconName, hint, fn) => {
              const b = document.createElement("button");
              b.className = `ie-tool-btn ${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames[iconName]}`;
              b.title = hint;
              b.addEventListener("click", fn);
              el.appendChild(b);
            };
            g("bw", "Black & White", () => {
              this._mergeLayersToOff();
              this._pushUndo();
              const imgD = this.offCtx.getImageData(0, 0, this.offCanvas.width, this.offCanvas.height);
              for (let i = 0; i < imgD.data.length; i += 4) {
                const gray = Math.round(imgD.data[i] * 0.299 + imgD.data[i + 1] * 0.587 + imgD.data[i + 2] * 0.114);
                imgD.data[i] = imgD.data[i + 1] = imgD.data[i + 2] = gray;
              }
              this.offCtx.putImageData(imgD, 0, 0);
              this.adjustBrightness = 100;
              this.adjustContrast = 100;
              this.adjustRed = 100;
              this.adjustGreen = 100;
              this.adjustBlue = 100;
              this._setTool("pan");
            });
            btn("Cancel", () => this._setTool("pan"));
          } else if (this.activeTool === "round") {
            const maxR = Math.min(this.offCanvas.width, this.offCanvas.height) / 2;
            const rL = document.createElement("label");
            rL.innerHTML = `Radius:<input type="range" min="0" max="${Math.round(maxR)}" value="${this.roundRadius}"/><span>${this.roundRadius}px</span>`;
            const rI = rL.querySelector("input");
            const rS = rL.querySelector("span");
            rI.oninput = () => {
              this.roundRadius = Number(rI.value);
              this.roundIsCircle = false;
              rS.textContent = `${this.roundRadius}px`;
              this._redraw();
            };
            el.appendChild(rL);
            const g = (iconName, hint, fn) => {
              const b = document.createElement("button");
              b.className = `ie-tool-btn ${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames[iconName]}`;
              b.title = hint;
              b.addEventListener("click", fn);
              el.appendChild(b);
            };
            g("circle", "Max (Circle)", () => {
              this.roundRadius = Math.round(maxR);
              this.roundIsCircle = true;
              this.roundIsHeart = false;
              rI.value = String(this.roundRadius);
              rS.textContent = `${this.roundRadius}px`;
              this._redraw();
            });
            g("heart", "Heart Shape", () => {
              this.roundIsHeart = true;
              this.roundIsCircle = false;
              this.roundRadius = Math.round(maxR);
              this._redraw();
            });
            const aB = document.createElement("button");
            aB.textContent = "Apply";
            aB.style.marginLeft = "8px";
            aB.addEventListener("click", () => {
              if (this.roundRadius <= 0 && !this.roundIsHeart) {
                this._setTool("pan");
                return;
              }
              this._mergeLayersToOff();
              this._pushUndo();
              const tmp = document.createElement("canvas");
              tmp.width = this.offCanvas.width;
              tmp.height = this.offCanvas.height;
              const ctx = tmp.getContext("2d");
              const r = this.roundRadius;
              const w = tmp.width;
              const h = tmp.height;
              ctx.beginPath();
              if (this.roundIsHeart) {
                drawHeartPath(ctx, w / 2, h / 2, Math.min(w, h) * 0.45);
              } else if (this.roundIsCircle) {
                ctx.arc(w / 2, h / 2, Math.min(w, h) / 2, 0, Math.PI * 2);
              } else {
                ctx.moveTo(r, 0);
                ctx.arcTo(w, 0, w, h, r);
                ctx.arcTo(w, h, 0, h, r);
                ctx.arcTo(0, h, 0, 0, r);
                ctx.arcTo(0, 0, w, 0, r);
              }
              ctx.closePath();
              ctx.clip();
              ctx.drawImage(this.offCanvas, 0, 0);
              this.offCtx.clearRect(0, 0, this.offCanvas.width, this.offCanvas.height);
              this.offCtx.drawImage(tmp, 0, 0);
              this.roundRadius = 0;
              this.roundIsCircle = false;
              this.roundIsHeart = false;
              this._setTool("pan");
            });
            el.appendChild(aB);
            btn("Cancel", () => this._setTool("pan"));
          } else if (this.activeTool === "frame") {
            const fLbl = document.createElement("label");
            fLbl.innerHTML = `Style:<select style="padding:2px;border:1px solid #555;background:#333;color:#ccc;border-radius:3px">
        <option value="none" ${this.currentFrame === "none" ? "selected" : ""}>None</option>
        <option value="border" ${this.currentFrame === "border" ? "selected" : ""}>Simple Border</option>
        <option value="polaroid" ${this.currentFrame === "polaroid" ? "selected" : ""}>Polaroid</option>
        <option value="vignette" ${this.currentFrame === "vignette" ? "selected" : ""}>Vignette</option>
        <option value="film" ${this.currentFrame === "film" ? "selected" : ""}>Film Strip</option>
        <option value="double" ${this.currentFrame === "double" ? "selected" : ""}>Double Border</option>
      </select>`;
            const fSel = fLbl.querySelector("select");
            fSel.onchange = () => {
              this.currentFrame = fSel.value;
              this._redraw();
            };
            el.appendChild(fLbl);
            const cL = document.createElement("label");
            cL.style.marginLeft = "8px";
            cL.innerHTML = `Color:<input type="color" value="${this.frameColor}" style="width:24px;height:24px;padding:0;border:none;background:none;cursor:pointer"/>`;
            const cI = cL.querySelector("input");
            cI.oninput = () => {
              this.frameColor = cI.value;
              this._redraw();
            };
            el.appendChild(cL);
            btn("Apply Frame", () => {
              if (this.currentFrame === "none") {
                this._setTool("pan");
                return;
              }
              this._mergeLayersToOff();
              this._pushUndo();
              const tmp = document.createElement("canvas");
              tmp.width = this.offCanvas.width;
              tmp.height = this.offCanvas.height;
              const ctx = tmp.getContext("2d");
              ctx.drawImage(this.offCanvas, 0, 0);
              drawFrame(ctx, tmp.width, tmp.height, this.currentFrame, this.frameColor);
              this.offCtx.clearRect(0, 0, this.offCanvas.width, this.offCanvas.height);
              this.offCtx.drawImage(tmp, 0, 0);
              this.currentFrame = "none";
              this._setTool("pan");
            });
            btn("Cancel", () => this._setTool("pan"));
          }
          if (["pan", "select", "pencil", "mosaic", "eraser", "text", "sticker"].includes(this.activeTool)) {
            if (this.selectedShape) {
              subEl.style.display = "flex";
              this._addShadowUI(subEl, this.selectedShape);
              this._addLayerUI(subEl, this.selectedShape, this.shapes);
            }
            if (this.selectedSticker) {
              subEl.style.display = "flex";
              this._addShadowUI(subEl, this.selectedSticker);
              this._addLayerUI(subEl, this.selectedSticker, this.stickerLayers);
            }
            if (this.selectedText) {
              subEl.style.display = "flex";
              this._addShadowUI(subEl, this.selectedText);
              this._addLayerUI(subEl, this.selectedText, this.textLayers);
            }
          }
        }
        _addLayerUI(el, item, list2) {
          const isText = item.text !== void 0;
          const isShape = item.type !== void 0 && !isText;
          const oType = isText ? "text" : isShape ? "shape" : "sticker";
          const activeObj = item;
          const wrap2 = document.createElement("span");
          wrap2.style.marginLeft = "8px";
          const btnUp = document.createElement("button");
          btnUp.className = `ie-tool-btn ${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_layerUp`;
          btnUp.title = "Bring to front";
          btnUp.addEventListener("click", () => {
            const objIndex = this.displayObjects.findIndex((o) => o.id === activeObj.id);
            if (objIndex !== -1 && objIndex < this.displayObjects.length - 1) {
              this._pushUndo();
              this.displayObjects.splice(objIndex, 1);
              this.displayObjects.push({ type: oType, id: activeObj.id, layer: activeObj });
              this._redraw();
            }
          });
          const btnDown = document.createElement("button");
          btnDown.className = `ie-tool-btn ${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_layerDown`;
          btnDown.title = "Send to back";
          btnDown.addEventListener("click", () => {
            const objIndex = this.displayObjects.findIndex((o) => o.id === activeObj.id);
            if (objIndex > 0) {
              this._pushUndo();
              this.displayObjects.splice(objIndex, 1);
              this.displayObjects.unshift({ type: oType, id: activeObj.id, layer: activeObj });
              this._redraw();
            }
          });
          const btnMerge = document.createElement("button");
          btnMerge.className = `ie-tool-btn ${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_merge`;
          btnMerge.title = "Merge layer down";
          btnMerge.addEventListener("click", () => {
            this._mergeSingleLayerToOff(activeObj, oType);
          });
          wrap2.appendChild(btnMerge);
          wrap2.appendChild(btnDown);
          wrap2.appendChild(btnUp);
          el.appendChild(wrap2);
        }
        _mergeSingleLayerToOff(targetLayer, type) {
          const idx = this.displayObjects.findIndex((o) => o.id === targetLayer.id);
          if (idx === -1) return;
          this._pushUndo();
          const [obj] = this.displayObjects.splice(idx, 1);
          const tempStore = this.displayObjects;
          this.displayObjects = [obj];
          this._mergeLayersToOff(false);
          this.displayObjects = tempStore;
          if (type === "shape") this.selectedShape = null;
          if (type === "sticker") this.selectedSticker = null;
          if (type === "text") this.selectedText = null;
          this._updateOpts();
          this._redraw();
        }
        //  Events 
        _attachEvents() {
          const c = this.canvas;
          c.addEventListener("pointerdown", (e) => this._onDown(e));
          c.addEventListener("pointermove", (e) => this._onMove(e));
          c.addEventListener("pointerup", (e) => this._onUp(e));
          c.addEventListener("pointerleave", (e) => this._onUp(e));
          c.addEventListener("dblclick", (e) => this._onDblClick(e));
          c.addEventListener(
            "wheel",
            (e) => {
              e.preventDefault();
              this._zoom(e.deltaY < 0 ? 0.033 : -0.033);
            },
            { passive: false }
          );
          c.addEventListener("dragover", (e) => e.preventDefault());
          c.addEventListener("drop", (e) => {
            var _a;
            e.preventDefault();
            const f = (_a = e.dataTransfer) == null ? void 0 : _a.files[0];
            if (f == null ? void 0 : f.type.startsWith("image/")) this._loadFile(f);
          });
          window.addEventListener("keydown", (e) => {
            if (this.textInput) return;
            const target = e.target;
            if (target.tagName === "INPUT" || target.tagName === "TEXTAREA") return;
            if (e.key === "Delete" || e.key === "Backspace") {
              if (this.selectedSticker || this.selectedText) {
                this._deleteSelected();
              }
            } else if (e.ctrlKey || e.metaKey) {
              if (e.key === "c" || e.key === "C") {
                if (this.hasSelection) this._copySelectionAsSticker();
              } else if (e.key === "x" || e.key === "X") {
                if (this.hasSelection) {
                  this._copySelectionAsSticker();
                  this._pushUndo();
                  const sx = Math.min(this.selStartX, this.selEndX);
                  const sy = Math.min(this.selStartY, this.selEndY);
                  const sw = Math.abs(this.selEndX - this.selStartX);
                  const sh = Math.abs(this.selEndY - this.selStartY);
                  this.offCtx.clearRect(sx, sy, sw, sh);
                  this.hasSelection = false;
                  this._redraw();
                }
              } else if (e.key === "v" || e.key === "V") {
                this._pasteClipboard();
              }
            }
          });
        }
        _drawShapePath(ctx, dx, dy, shift) {
          const sw = this.penStartX;
          const sh = this.penStartY;
          const cx = sw + dx;
          const cy = sh + dy;
          let fx = cx;
          let fy = cy;
          let dist = Math.hypot(dx, dy);
          if (shift) {
            if (this.penMode === "line" || this.penMode === "arrow") {
              const angle = Math.atan2(dy, dx);
              const snapped = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
              fx = sw + Math.cos(snapped) * dist;
              fy = sh + Math.sin(snapped) * dist;
            } else {
              const maxDim = Math.max(Math.abs(dx), Math.abs(dy));
              fx = sw + maxDim * Math.sign(dx);
              fy = sh + maxDim * Math.sign(dy);
            }
          }
          drawShapePath(ctx, this.penMode, this.penArrowType, this.penColor, sw, sh, fx, fy);
        }
        // Double-click on a text layer (in pan or text mode) to re-edit it
        _onDblClick(e) {
          if (this.activeTool !== "pan" && this.activeTool !== "text") return;
          const cv = this._scr2cv(e.clientX, e.clientY);
          for (const t of [...this.textLayers].reverse()) {
            if (hitText(cv, t, this.offCtx, (l) => this._textFont(l))) {
              const r = this.canvas.getBoundingClientRect();
              this.ctx.font = this._textFont(t);
              const tw = this.ctx.measureText(t.text).width;
              const cvLeftX = t.x - tw / 2;
              const sx = cvLeftX * this.viewScale + this.viewOffX + r.left;
              const sy = t.y * this.viewScale + this.viewOffY + r.top;
              this.textColor = t.color;
              this.textFontSize = t.fontSize;
              this.textFontFamily = t.fontFamily;
              this.textBold = !!t.bold;
              this.textItalic = !!t.italic;
              this._showTextInput(sx, sy, cvLeftX, t.y, t.id, t.text);
              return;
            }
          }
        }
        _scr2cv(cx, cy) {
          const r = this.canvas.getBoundingClientRect();
          return { x: (cx - r.left - this.viewOffX) / this.viewScale, y: (cy - r.top - this.viewOffY) / this.viewScale };
        }
        _scr2wrap(cx, cy) {
          const r = this.canvas.getBoundingClientRect();
          return { x: cx - r.left, y: cy - r.top };
        }
        _hitTestInteract(cv) {
          const hs = 10 / this.viewScale;
          if (this.selectedShape) {
            const s = this.selectedShape;
            const handles = getShapeHandles(s, this.viewScale);
            if (Math.hypot(cv.x - handles.rot.x, cv.y - handles.rot.y) < hs) {
              const box = getShapeBoundingBox(s);
              this.rotatingShape = {
                layer: s,
                cx: box.cx,
                cy: box.cy,
                startAngle: Math.atan2(cv.y - box.cy, cv.x - box.cx),
                startRotation: s.rotation || 0
              };
              return true;
            }
            if (Math.hypot(cv.x - handles.resize.x, cv.y - handles.resize.y) < hs) {
              const box = getShapeBoundingBox(s);
              this.resizingShape = {
                layer: s,
                startX: cv.x,
                startY: cv.y,
                boxW: box.w,
                boxH: box.h,
                boxCX: box.cx,
                boxCY: box.cy,
                origX: s.x,
                origY: s.y,
                origW: s.w,
                origH: s.h,
                origPoints: s.points ? s.points.map((p) => ({ ...p })) : []
              };
              return true;
            }
            if (Math.hypot(cv.x - handles.del.x, cv.y - handles.del.y) < hs) {
              this._deleteSelected();
              return true;
            }
          }
          if (this.selectedSticker) {
            const s = this.selectedSticker;
            const handles = getStickerHandles(s, this.viewScale);
            if (Math.hypot(cv.x - handles.rot.x, cv.y - handles.rot.y) < hs) {
              this.rotatingSticker = {
                layer: s,
                cx: s.x + s.w / 2,
                cy: s.y + s.h / 2,
                startAngle: Math.atan2(cv.y - (s.y + s.h / 2), cv.x - (s.x + s.w / 2)),
                startRotation: s.rotation
              };
              return true;
            }
            if (Math.hypot(cv.x - handles.resize.x, cv.y - handles.resize.y) < hs) {
              this.resizingSticker = { layer: s, startX: cv.x, startY: cv.y, startW: s.w, startH: s.h };
              return true;
            }
            if (Math.hypot(cv.x - handles.del.x, cv.y - handles.del.y) < hs) {
              this._deleteSelected();
              return true;
            }
          }
          if (this.selectedText) {
            const t = this.selectedText;
            const h = getTextHandles(t, this.viewScale, this.offCtx, (l) => this._textFont(l));
            if (Math.hypot(cv.x - h.rot.x, cv.y - h.rot.y) < hs) {
              this.rotatingText = {
                layer: t,
                cx: t.x,
                cy: t.y,
                startAngle: Math.atan2(cv.y - t.y, cv.x - t.x),
                startRotation: t.rotation
              };
              return true;
            }
            if (Math.hypot(cv.x - h.resize.x, cv.y - h.resize.y) < hs) {
              this.resizingText = { layer: t, startX: cv.x, startFontSize: t.fontSize };
              return true;
            }
            if (Math.hypot(cv.x - h.del.x, cv.y - h.del.y) < hs) {
              this._deleteSelected();
              return true;
            }
            if (t.tailActive && Math.hypot(cv.x - (t.tailX || 0), cv.y - (t.tailY || 0)) < hs) {
              this.movingTail = { layer: t };
              this._pushUndo();
              return true;
            }
          }
          for (const obj of [...this.displayObjects].reverse()) {
            if (obj.type === "sticker") {
              const s = obj.layer;
              if (hitSticker(cv, s)) {
                this.selectedSticker = s;
                this.selectedText = null;
                this.selectedShape = null;
                this.activeSticker = { layer: s, offX: cv.x - s.x, offY: cv.y - s.y };
                this._pushUndo();
                if (this.activeTool === "sticker" || this.activeTool === "text" || this.activeTool === "pencil") {
                  this._setTool("pan", true);
                } else {
                  this._updateOpts();
                  this._redraw();
                }
                return true;
              }
            } else if (obj.type === "text") {
              const t = obj.layer;
              if (hitText(cv, t, this.offCtx, this._textFont.bind(this))) {
                this.selectedText = t;
                this.selectedSticker = null;
                this.selectedShape = null;
                this.activeText = { layer: t, offX: cv.x - t.x, offY: cv.y - t.y };
                this._pushUndo();
                if (this.activeTool === "sticker" || this.activeTool === "text" || this.activeTool === "pencil") {
                  this._setTool("pan", true);
                } else {
                  this._updateOpts();
                  this._redraw();
                }
                return true;
              }
            } else if (obj.type === "shape") {
              const s = obj.layer;
              if (hitShape(cv, s)) {
                this.selectedShape = s;
                this.selectedSticker = null;
                this.selectedText = null;
                this.movingShape = { layer: s, lastX: cv.x, lastY: cv.y };
                this._pushUndo();
                if (this.activeTool === "sticker" || this.activeTool === "text" || this.activeTool === "pencil") {
                  this._setTool("pan", true);
                } else {
                  this._updateOpts();
                  this._redraw();
                }
                return true;
              }
            }
          }
          return false;
        }
        _onDown(e) {
          this.activePointers.set(e.pointerId, e);
          if (this.textInput) {
            this._commitText();
            return;
          }
          this.canvas.setPointerCapture(e.pointerId);
          this.isPointerDown = true;
          if (this.activePointers.size === 2 && this.activeTool === "pan") {
            const pts = Array.from(this.activePointers.values());
            const dx = pts[0].clientX - pts[1].clientX;
            const dy = pts[0].clientY - pts[1].clientY;
            this.initialPinchDist = Math.hypot(dx, dy);
            this.initialPinchScale = this.viewScale;
            this.pinchCenter = {
              x: (pts[0].clientX + pts[1].clientX) / 2,
              y: (pts[0].clientY + pts[1].clientY) / 2
            };
            this.activeSticker = null;
            this.activeText = null;
            return;
          }
          const cv = this._scr2cv(e.clientX, e.clientY);
          const sc = this._scr2wrap(e.clientX, e.clientY);
          this.lastX = sc.x;
          this.lastY = sc.y;
          if (this.activeTool === "pan" || this.activeTool === "select" || this.activeTool === "pencil" || this.activeTool === "mosaic" || this.activeTool === "eraser" || this.activeTool === "sticker" || this.activeTool === "text") {
            if (this._hitTestInteract(cv)) return;
          }
          if (this.activeTool === "pan") {
            this.selectedSticker = null;
            this.selectedText = null;
            this.selectedShape = null;
            this._updateOpts();
            this._redraw();
          } else if (this.activeTool === "select") {
            this.selectedSticker = null;
            this.selectedText = null;
            this.selectedShape = null;
            this._updateOpts();
            this._redraw();
            this.selStartX = cv.x;
            this.selStartY = cv.y;
            this.selEndX = cv.x;
            this.selEndY = cv.y;
            this.hasSelection = false;
          } else if (this.activeTool === "pencil") {
            this._pushUndo();
            this.selectedSticker = null;
            this.selectedText = null;
            this.selectedShape = null;
            this._redraw();
            this.penStartX = cv.x;
            this.penStartY = cv.y;
            this.penDrawing = true;
            this.activeShape = {
              id: `shp_${Date.now()}`,
              type: this.penMode,
              color: this.penColor,
              strokeWidth: this.penSize,
              rotation: 0,
              x: cv.x,
              y: cv.y,
              w: cv.x,
              h: cv.y,
              arrowType: this.penArrowType,
              points: this.penMode === "pencil" ? [{ x: cv.x, y: cv.y }] : void 0
            };
          } else if (this.activeTool === "mosaic") {
            this.selectedSticker = null;
            this.selectedText = null;
            this.selectedShape = null;
            this._updateOpts();
            this._pushUndo();
            this.mosaicLastX = cv.x;
            this.mosaicLastY = cv.y;
            this._applyMosaic(cv.x, cv.y);
            this._redraw();
          } else if (this.activeTool === "eraser") {
            this.selectedSticker = null;
            this.selectedText = null;
            this.selectedShape = null;
            this._updateOpts();
            this._pushUndo();
            this.isErasing = true;
            this.eraserLastX = cv.x;
            this.eraserLastY = cv.y;
            this._eraseStroke(cv.x, cv.y, cv.x, cv.y);
          } else if (this.activeTool === "text") {
            this.selectedSticker = null;
            this.selectedText = null;
            this.selectedShape = null;
            this._redraw();
            this._showTextInput(e.clientX, e.clientY, cv.x, cv.y);
          } else if (this.activeTool === "sticker") {
            this.selectedSticker = null;
            this.selectedText = null;
            this.selectedShape = null;
            this._redraw();
          }
        }
        _onMove(e) {
          if (this.activePointers.has(e.pointerId)) {
            this.activePointers.set(e.pointerId, e);
          }
          if (!this.isPointerDown) return;
          if (this.activePointers.size === 2 && this.activeTool === "pan") {
            const pts = Array.from(this.activePointers.values());
            const dx = pts[0].clientX - pts[1].clientX;
            const dy = pts[0].clientY - pts[1].clientY;
            const dist = Math.hypot(dx, dy);
            if (this.initialPinchDist > 0) {
              const scaleRatio = dist / this.initialPinchDist;
              const ns = Math.max(0.05, Math.min(8, this.initialPinchScale * scaleRatio));
              const r = this.canvas.getBoundingClientRect();
              const cx = this.pinchCenter.x - r.left, cy = this.pinchCenter.y - r.top;
              this.viewOffX = cx - (cx - this.viewOffX) * (ns / this.viewScale);
              this.viewOffY = cy - (cy - this.viewOffY) * (ns / this.viewScale);
              this.viewScale = ns;
              const currentPinchCenter = {
                x: (pts[0].clientX + pts[1].clientX) / 2,
                y: (pts[0].clientY + pts[1].clientY) / 2
              };
              this.viewOffX += currentPinchCenter.x - this.pinchCenter.x;
              this.viewOffY += currentPinchCenter.y - this.pinchCenter.y;
              this.pinchCenter = currentPinchCenter;
              this.initialPinchDist = dist;
              this.initialPinchScale = ns;
              this._updateZoomSlider();
              this._updateOpts();
              this._redraw();
            }
            return;
          }
          const cv = this._scr2cv(e.clientX, e.clientY);
          const sc = this._scr2wrap(e.clientX, e.clientY);
          if (this.resizingText) {
            const dx = cv.x - this.resizingText.startX;
            this.resizingText.layer.fontSize = Math.max(8, Math.round(this.resizingText.startFontSize + dx));
            this._redraw();
            return;
          }
          if (this.rotatingText) {
            const r = this.rotatingText;
            const angle = Math.atan2(cv.y - r.cy, cv.x - r.cx);
            r.layer.rotation = r.startRotation + (angle - r.startAngle);
            this._redraw();
            return;
          }
          if (this.movingTail) {
            this.movingTail.layer.tailX = cv.x;
            this.movingTail.layer.tailY = cv.y;
            this._redraw();
            return;
          }
          if (this.rotatingShape) {
            const r = this.rotatingShape;
            const angle = Math.atan2(cv.y - r.cy, cv.x - r.cx);
            r.layer.rotation = r.startRotation + (angle - r.startAngle);
            this._redraw();
            return;
          }
          if (this.resizingShape) {
            const r = this.resizingShape;
            const dx = cv.x - r.startX;
            const dy = cv.y - r.startY;
            const rot = r.layer.rotation || 0;
            const cos = Math.cos(-rot);
            const sin = Math.sin(-rot);
            const unDx = dx * cos - dy * sin;
            const unDy = dx * sin + dy * cos;
            const scaleX = Math.max(0.1, r.boxW + unDx * 2) / Math.max(0.1, r.boxW);
            const scaleY = Math.max(0.1, r.boxH + unDy * 2) / Math.max(0.1, r.boxH);
            if (r.layer.type === "pencil" && r.layer.points) {
              for (let i = 0; i < r.layer.points.length; i++) {
                r.layer.points[i].x = r.boxCX + (r.origPoints[i].x - r.boxCX) * scaleX;
                r.layer.points[i].y = r.boxCY + (r.origPoints[i].y - r.boxCY) * scaleY;
              }
              r.startX = cv.x;
              r.startY = cv.y;
              r.boxW = Math.max(1, r.boxW + unDx * 2);
              r.boxH = Math.max(1, r.boxH + unDy * 2);
              r.origPoints = r.layer.points.map((p) => ({ ...p }));
            } else if (r.layer.type === "circle" || r.layer.type === "star") {
              const radScale = Math.max(scaleX, scaleY);
              r.layer.w = r.layer.x + (r.origW - r.layer.x) * radScale;
              r.layer.h = r.layer.y + (r.origH - r.layer.y) * radScale;
            } else {
              r.layer.x = r.boxCX + (r.origX - r.boxCX) * scaleX;
              r.layer.y = r.boxCY + (r.origY - r.boxCY) * scaleY;
              r.layer.w = r.boxCX + (r.origW - r.boxCX) * scaleX;
              r.layer.h = r.boxCY + (r.origH - r.boxCY) * scaleY;
            }
            this._redraw();
            return;
          }
          if (this.movingShape) {
            const m = this.movingShape;
            const dx = cv.x - m.lastX;
            const dy = cv.y - m.lastY;
            if (m.layer.type === "pencil" && m.layer.points) {
              for (const p of m.layer.points) {
                p.x += dx;
                p.y += dy;
              }
            } else {
              m.layer.x += dx;
              m.layer.y += dy;
              m.layer.w += dx;
              m.layer.h += dy;
            }
            m.lastX = cv.x;
            m.lastY = cv.y;
            this._redraw();
            return;
          }
          if (this.rotatingSticker) {
            const r = this.rotatingSticker;
            const angle = Math.atan2(cv.y - r.cy, cv.x - r.cx);
            r.layer.rotation = r.startRotation + (angle - r.startAngle);
            this._redraw();
            return;
          }
          if (this.resizingSticker) {
            const r = this.resizingSticker;
            const dx = cv.x - r.startX;
            const dy = cv.y - r.startY;
            let targetW = r.startW + dx;
            let targetH = r.startH + dy;
            if (e.shiftKey) {
              const ratio = r.startW / r.startH;
              if (Math.abs(targetW) / Math.abs(targetH) > ratio) {
                targetW = targetH * ratio;
              } else {
                targetH = targetW / ratio;
              }
            }
            r.layer.w = Math.max(20, targetW);
            r.layer.h = Math.max(20, targetH);
            this._redraw();
            return;
          }
          if (this.activeSticker) {
            const s = this.activeSticker;
            s.layer.x = cv.x - s.offX;
            s.layer.y = cv.y - s.offY;
            this._redraw();
            return;
          }
          if (this.activeText) {
            const t = this.activeText;
            t.layer.x = cv.x - t.offX;
            t.layer.y = cv.y - t.offY;
            this._redraw();
            return;
          }
          if (!this.isPointerDown) return;
          if (this.activeTool === "pan") {
            this.viewOffX += sc.x - this.lastX;
            this.viewOffY += sc.y - this.lastY;
            this._redraw();
          } else if (this.activeTool === "select") {
            this.selEndX = cv.x;
            this.selEndY = cv.y;
            this.hasSelection = true;
            this._redraw();
          } else if (this.activeTool === "text" || this.activeTool === "sticker") {
          } else if (this.activeTool === "pencil") {
            if (!this.activeShape) return;
            let dx = cv.x - this.penStartX;
            let dy = cv.y - this.penStartY;
            if (e.shiftKey && this.penMode !== "pencil") {
              const dist = Math.hypot(dx, dy);
              if (this.penMode === "line" || this.penMode === "arrow") {
                const angle = Math.atan2(dy, dx);
                const snapped = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
                dx = Math.cos(snapped) * dist;
                dy = Math.sin(snapped) * dist;
              } else {
                const maxDim = Math.max(Math.abs(dx), Math.abs(dy));
                dx = maxDim * Math.sign(dx);
                dy = maxDim * Math.sign(dy);
              }
            }
            if (this.penMode === "pencil") {
              this.activeShape.points.push({ x: cv.x, y: cv.y });
              this.activeShape.w = Math.max(this.activeShape.w, cv.x);
              this.activeShape.h = Math.max(this.activeShape.h, cv.y);
            } else {
              this.activeShape.w = this.penStartX + dx;
              this.activeShape.h = this.penStartY + dy;
            }
            this._redraw();
          } else if (this.activeTool === "mosaic") {
            this._applyMosaic(cv.x, cv.y);
            this.mosaicLastX = cv.x;
            this.mosaicLastY = cv.y;
            this._redraw();
          } else if (this.activeTool === "eraser" && this.isErasing) {
            this._eraseStroke(this.eraserLastX, this.eraserLastY, cv.x, cv.y);
            this.eraserLastX = cv.x;
            this.eraserLastY = cv.y;
          }
          this.lastX = sc.x;
          this.lastY = sc.y;
          this.penStartX = cv.x;
          this.penStartY = cv.y;
        }
        _eraseStroke(x1, y1, x2, y2) {
          this.offCtx.save();
          if (this.resizeBgColor) {
            this.offCtx.globalCompositeOperation = "source-over";
            this.offCtx.strokeStyle = this.resizeBgColor;
          } else {
            this.offCtx.globalCompositeOperation = "destination-out";
            this.offCtx.strokeStyle = "rgba(0,0,0,1)";
          }
          this.offCtx.lineWidth = this.eraserSize;
          this.offCtx.lineCap = "round";
          this.offCtx.lineJoin = "round";
          this.offCtx.beginPath();
          this.offCtx.moveTo(x1, y1);
          if (x1 === x2 && y1 === y2) this.offCtx.lineTo(x2 + 0.1, y2);
          else this.offCtx.lineTo(x2, y2);
          this.offCtx.stroke();
          this.offCtx.restore();
          this._redraw();
        }
        _onUp(e) {
          this.activePointers.delete(e.pointerId);
          const wasPointerDown = this.isPointerDown;
          if (this.activePointers.size === 0) {
            this.isPointerDown = false;
          } else if (this.activePointers.size === 1) {
            const remaining = Array.from(this.activePointers.values())[0];
            const sc = this._scr2wrap(remaining.clientX, remaining.clientY);
            this.lastX = sc.x;
            this.lastY = sc.y;
            return;
          } else {
            return;
          }
          if (this.rotatingSticker || this.resizingSticker || this.resizingText || this.rotatingText || this.movingTail || this.rotatingShape || this.resizingShape) {
            this.resizingText = null;
            this.rotatingSticker = null;
            this.rotatingText = null;
            this.movingTail = null;
            this.resizingSticker = null;
            this.rotatingShape = null;
            this.resizingShape = null;
            return;
          }
          if (this.activeSticker) {
            this.activeSticker = null;
            return;
          }
          if (this.activeText) {
            this.activeText = null;
            return;
          }
          if (this.movingShape) {
            this.movingShape = null;
            return;
          }
          if (this.isErasing) {
            this.isErasing = false;
            return;
          }
          if (this.activeTool === "pencil") {
            if (!wasPointerDown) return;
            if (!this.penDrawing) return;
            this.penDrawing = false;
            if (this.activeShape) {
              let keep = false;
              if (this.penMode === "pencil") {
                keep = this.activeShape.points.length > 1;
              } else {
                keep = Math.abs(this.activeShape.w - this.activeShape.x) > 0 || Math.abs(this.activeShape.h - this.activeShape.y) > 0;
              }
              if (keep) {
                this.displayObjects.push({
                  id: this.activeShape.id,
                  type: "shape",
                  layer: this.activeShape
                });
                this.selectedShape = this.activeShape;
                this.activeShape = null;
                this._setTool("pan", true);
              } else {
                this.activeShape = null;
                this._updateOpts();
                this._redraw();
              }
            }
          }
        }
        //  Select / Copy / Paste 
        _copySelectionAsSticker() {
          if (!this.hasSelection) return;
          const x = Math.round(Math.min(this.selStartX, this.selEndX));
          const y = Math.round(Math.min(this.selStartY, this.selEndY));
          const w = Math.round(Math.abs(this.selEndX - this.selStartX));
          const h = Math.round(Math.abs(this.selEndY - this.selStartY));
          if (w < 4 || h < 4) return;
          const tmp = document.createElement("canvas");
          tmp.width = w;
          tmp.height = h;
          tmp.getContext("2d").drawImage(this.offCanvas, x, y, w, h, 0, 0, w, h);
          const img = new Image();
          img.src = tmp.toDataURL();
          img.onload = () => {
            this.clipboardImg = img;
            this.hasSelection = false;
            this._updateOpts();
          };
        }
        _pasteClipboard() {
          if (!this.clipboardImg) return;
          this._pushUndo();
          const img = this.clipboardImg;
          const s = {
            id: `st_${Date.now()}`,
            img,
            x: (this.offCanvas.width - img.naturalWidth) / 2,
            y: (this.offCanvas.height - img.naturalHeight) / 2,
            w: img.naturalWidth,
            h: img.naturalHeight,
            rotation: 0
          };
          this.stickerLayers.push(s);
          this.selectedSticker = s;
          this._redraw();
        }
        //  Crop overlay 
        _initCropOverlay() {
          const wrap2 = this.canvas.parentElement;
          const vW = this.offCanvas.width * this.viewScale, vH = this.offCanvas.height * this.viewScale;
          const pad = vW * 0.15;
          this.cropX = this.viewOffX + pad;
          this.cropY = this.viewOffY + pad;
          this.cropW = Math.max(60, vW - pad * 2);
          this.cropH = Math.max(60, vH - pad * 2);
          const overlay = document.createElement("div");
          overlay.className = "ie-crop-overlay";
          const frame = document.createElement("div");
          frame.className = "ie-crop-frame";
          overlay.appendChild(frame);
          wrap2.appendChild(overlay);
          this.cropOverlayEl = overlay;
          this.cropFrameEl = frame;
          const handles = [
            ["nw", "0", "0"],
            ["n", "calc(50% - 5px)", "0"],
            ["ne", "calc(100% - 10px)", "0"],
            ["w", "0", "calc(50% - 5px)"],
            ["e", "calc(100% - 10px)", "calc(50% - 5px)"],
            ["sw", "0", "calc(100% - 10px)"],
            ["s", "calc(50% - 5px)", "calc(100% - 10px)"],
            ["se", "calc(100% - 10px)", "calc(100% - 10px)"]
          ];
          handles.forEach(([tag2, l, t]) => {
            const h = document.createElement("div");
            h.className = "ie-handle";
            h.dataset.h = tag2;
            h.style.left = l;
            h.style.top = t;
            const cursorMap = {
              nw: "nw-resize",
              n: "n-resize",
              ne: "ne-resize",
              w: "w-resize",
              e: "e-resize",
              sw: "sw-resize",
              s: "s-resize",
              se: "se-resize"
            };
            h.style.cursor = cursorMap[tag2] || "pointer";
            h.addEventListener("pointerdown", (ev) => this._cropHandleDown(ev, tag2));
            frame.appendChild(h);
          });
          frame.addEventListener("pointerdown", (ev) => {
            if (ev.target.dataset.h) return;
            this._cropHandleDown(ev, "move");
          });
          this._updateCropFrame();
        }
        _updateCropFrame() {
          if (!this.cropFrameEl) return;
          Object.assign(this.cropFrameEl.style, {
            left: `${this.cropX}px`,
            top: `${this.cropY}px`,
            width: `${this.cropW}px`,
            height: `${this.cropH}px`
          });
        }
        _cropHandleDown(e, tag2) {
          e.stopPropagation();
          e.target.setPointerCapture(e.pointerId);
          this.cropDragMode = tag2;
          this.cropDragStartX = e.clientX;
          this.cropDragStartY = e.clientY;
          this.cropStartState = { x: this.cropX, y: this.cropY, w: this.cropW, h: this.cropH };
          const onMove = (ev) => {
            if (!this.cropDragMode) return;
            const dx = ev.clientX - this.cropDragStartX, dy = ev.clientY - this.cropDragStartY;
            const s = this.cropStartState;
            const MIN = 30;
            const minX = this.viewOffX, minY = this.viewOffY;
            const maxX = this.viewOffX + this.offCanvas.width * this.viewScale;
            const maxY = this.viewOffY + this.offCanvas.height * this.viewScale;
            if (this.cropDragMode === "move") {
              this.cropX = Math.max(minX, Math.min(s.x + dx, maxX - this.cropW));
              this.cropY = Math.max(minY, Math.min(s.y + dy, maxY - this.cropH));
            } else {
              let { x, y, w, h } = s;
              if (this.cropDragMode.includes("e")) w = Math.max(MIN, Math.min(s.w + dx, maxX - x));
              if (this.cropDragMode.includes("s")) h = Math.max(MIN, Math.min(s.h + dy, maxY - y));
              if (this.cropDragMode.includes("w")) {
                x = Math.max(minX, s.x + dx);
                w = Math.max(MIN, s.w - (x - s.x));
              }
              if (this.cropDragMode.includes("n")) {
                y = Math.max(minY, s.y + dy);
                h = Math.max(MIN, s.h - (y - s.y));
              }
              this.cropX = x;
              this.cropY = y;
              this.cropW = w;
              this.cropH = h;
            }
            this._updateCropFrame();
          };
          const onUp = () => {
            this.cropDragMode = null;
            e.target.removeEventListener("pointermove", onMove);
          };
          e.target.addEventListener("pointermove", onMove);
          e.target.addEventListener("pointerup", onUp, { once: true });
        }
        _removeCropOverlay() {
          var _a;
          (_a = this.cropOverlayEl) == null ? void 0 : _a.remove();
          this.cropOverlayEl = null;
          this.cropFrameEl = null;
        }
        _applyCrop() {
          const ox = (this.cropX - this.viewOffX) / this.viewScale;
          const oy = (this.cropY - this.viewOffY) / this.viewScale;
          const ow = this.cropW / this.viewScale, oh = this.cropH / this.viewScale;
          const rx = Math.max(0, Math.round(ox)), ry = Math.max(0, Math.round(oy));
          const rw = Math.min(Math.round(ow), this.offCanvas.width - rx);
          const rh = Math.min(Math.round(oh), this.offCanvas.height - ry);
          if (rw < 4 || rh < 4) return;
          this._mergeLayersToOff();
          this._pushUndo();
          const id = this.offCtx.getImageData(rx, ry, rw, rh);
          this.offCanvas.width = rw;
          this.offCanvas.height = rh;
          this.offCtx.putImageData(id, 0, 0);
          this._setTool("pan");
          this._fitView();
        }
        //  Mosaic 
        _applyMosaic(cx, cy) {
          const currentImg = this.offCtx.getImageData(0, 0, this.offCanvas.width, this.offCanvas.height);
          const newImgData = applyMosaic(
            currentImg,
            this.offCanvas.width,
            this.offCanvas.height,
            this.mosaicLastX,
            this.mosaicLastY,
            cx,
            cy,
            this.mosaicSize
          );
          this.offCtx.putImageData(newImgData, 0, 0);
        }
        __checkerPattern = null;
        _getCheckerPattern() {
          if (this.__checkerPattern) return this.__checkerPattern;
          const c = document.createElement("canvas");
          c.width = 16;
          c.height = 16;
          const ctx = c.getContext("2d");
          ctx.fillStyle = "#222";
          ctx.fillRect(0, 0, 16, 16);
          ctx.fillStyle = "#3a3a3a";
          ctx.fillRect(0, 0, 8, 8);
          ctx.fillRect(8, 8, 8, 8);
          this.__checkerPattern = this.ctx.createPattern(c, "repeat");
          return this.__checkerPattern;
        }
        //  Redraw 
        _redraw() {
          const wrap2 = this.canvas.parentElement;
          this.canvas.width = wrap2.clientWidth;
          this.canvas.height = wrap2.clientHeight;
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.ctx.save();
          this.ctx.translate(this.viewOffX, this.viewOffY);
          this.ctx.scale(this.viewScale, this.viewScale);
          if (this.activeTool === "rotate" && this.rotateValue !== 0) {
            const cx = this.offCanvas.width / 2;
            const cy = this.offCanvas.height / 2;
            this.ctx.translate(cx, cy);
            this.ctx.rotate(this.rotateValue * Math.PI / 180);
            this.ctx.translate(-cx, -cy);
          }
          this.ctx.save();
          this.ctx.fillStyle = this._getCheckerPattern();
          this.ctx.fillRect(0, 0, this.offCanvas.width, this.offCanvas.height);
          this.ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
          this.ctx.lineWidth = 1 / this.viewScale;
          this.ctx.strokeRect(0, 0, this.offCanvas.width, this.offCanvas.height);
          this.ctx.restore();
          if (this.activeTool === "adjust") {
            if (this.adjustBrightness !== 100 || this.adjustContrast !== 100) {
              this.ctx.filter = `brightness(${this.adjustBrightness}%) contrast(${this.adjustContrast}%)`;
            }
          }
          if (this.activeTool === "round" && this.roundRadius > 0) {
            this.ctx.save();
            const r = this.roundRadius;
            const w = this.offCanvas.width;
            const h = this.offCanvas.height;
            this.ctx.beginPath();
            if (this.roundIsHeart) {
              drawHeartPath(this.ctx, w / 2, h / 2, Math.min(w, h) * 0.45);
            } else if (this.roundIsCircle) {
              this.ctx.arc(w / 2, h / 2, Math.min(w, h) / 2, 0, Math.PI * 2);
            } else {
              this.ctx.moveTo(r, 0);
              this.ctx.arcTo(w, 0, w, h, r);
              this.ctx.arcTo(w, h, 0, h, r);
              this.ctx.arcTo(0, h, 0, 0, r);
              this.ctx.arcTo(0, 0, w, 0, r);
            }
            this.ctx.closePath();
            this.ctx.clip();
          }
          if (this.activeTool === "adjust" && (this.adjustRed !== 100 || this.adjustGreen !== 100 || this.adjustBlue !== 100)) {
            const tcv = document.createElement("canvas");
            tcv.width = this.offCanvas.width;
            tcv.height = this.offCanvas.height;
            const tctx = tcv.getContext("2d");
            tctx.drawImage(this.offCanvas, 0, 0);
            const tImg = tctx.getImageData(0, 0, tcv.width, tcv.height);
            const rf = this.adjustRed / 100;
            const gf = this.adjustGreen / 100;
            const bf = this.adjustBlue / 100;
            for (let i = 0; i < tImg.data.length; i += 4) {
              tImg.data[i] = Math.min(255, tImg.data[i] * rf);
              tImg.data[i + 1] = Math.min(255, tImg.data[i + 1] * gf);
              tImg.data[i + 2] = Math.min(255, tImg.data[i + 2] * bf);
            }
            tctx.putImageData(tImg, 0, 0);
            this.ctx.drawImage(tcv, 0, 0);
          } else {
            this.ctx.drawImage(this.offCanvas, 0, 0);
          }
          if (this.activeTool === "frame" && this.currentFrame !== "none") {
            drawFrame(this.ctx, this.offCanvas.width, this.offCanvas.height, this.currentFrame, this.frameColor);
          }
          if (this.activeTool === "round" && this.roundRadius > 0) {
            this.ctx.restore();
          }
          this.ctx.filter = "none";
          this.displayObjects.forEach((obj) => {
            if (obj.type === "text") {
              const t = obj.layer;
              this.ctx.font = this._textFont(t);
              const m = this.ctx.measureText(t.text);
              const tw = m.width;
              const th = t.fontSize;
              const cx = t.x;
              const cy = t.y;
              let lx = 0, ly = 0;
              if (t.tailActive && t.tailX !== void 0 && t.tailY !== void 0) {
                const dx = t.tailX - cx;
                const dy = t.tailY - cy;
                const cos = Math.cos(-t.rotation);
                const sin = Math.sin(-t.rotation);
                lx = dx * cos - dy * sin;
                ly = dx * sin + dy * cos;
              }
              this.ctx.save();
              this.ctx.translate(cx, cy);
              this.ctx.rotate(t.rotation);
              if (t.shadow && t.shadow.type !== "none") {
                this.ctx.shadowBlur = t.shadow.blur;
                this.ctx.shadowColor = t.shadow.color;
                if (t.shadow.type === "drop") {
                  this.ctx.shadowOffsetX = t.shadow.offsetX;
                  this.ctx.shadowOffsetY = t.shadow.offsetY;
                } else {
                  this.ctx.shadowOffsetX = 0;
                  this.ctx.shadowOffsetY = 0;
                }
                this.ctx.globalAlpha = t.shadow.opacity / 100;
              }
              this.ctx.font = this._textFont(t);
              if (t.strokeWidth && t.strokeWidth > 0) {
                this.ctx.strokeStyle = t.strokeColor || "#000000";
                this.ctx.lineWidth = t.strokeWidth;
                this.ctx.lineJoin = "round";
                buildBubblePath(this.ctx, tw, th, lx, ly, !!t.tailActive);
                this.ctx.stroke();
              }
              this.ctx.fillStyle = t.color;
              this.ctx.fillText(t.text, -tw / 2, th / 2 - 2);
              this.ctx.restore();
              if (this.activeTool === "pan" || this.activeTool === "text" || this.activeTool === "select" || this.activeTool === "pencil" || this.activeTool === "mosaic" || this.activeTool === "sticker") {
                const iss = this.selectedText === t;
                const h = getTextHandles(t, this.viewScale, this.offCtx, (l) => this._textFont(l));
                this.ctx.save();
                this.ctx.translate(cx, cy);
                this.ctx.rotate(t.rotation);
                this.ctx.strokeStyle = iss ? "rgba(255,200,0,0.8)" : "rgba(80,140,255,0.4)";
                this.ctx.lineWidth = 1 / this.viewScale;
                this.ctx.strokeRect(-tw / 2 - 2, -th / 2 - 2, tw + 4, th + 8);
                this.ctx.restore();
                if (iss) {
                  const hs = 10 / this.viewScale;
                  this.ctx.fillStyle = "#0a74c9";
                  this.ctx.beginPath();
                  this.ctx.arc(h.rot.x, h.rot.y, hs / 2, 0, Math.PI * 2);
                  this.ctx.fill();
                  this.ctx.fillStyle = "#fff";
                  this.ctx.strokeStyle = "#0a74c9";
                  this.ctx.lineWidth = 2 / this.viewScale;
                  this.ctx.beginPath();
                  this.ctx.arc(h.resize.x, h.resize.y, hs / 2, 0, Math.PI * 2);
                  this.ctx.fill();
                  this.ctx.stroke();
                  drawDeleteHandle(this.ctx, h.del.x, h.del.y, hs);
                  if (t.tailActive && t.tailX !== void 0 && t.tailY !== void 0) {
                    this.ctx.fillStyle = "#ff00ff";
                    this.ctx.beginPath();
                    this.ctx.moveTo(t.tailX, t.tailY - hs);
                    this.ctx.lineTo(t.tailX + hs, t.tailY);
                    this.ctx.lineTo(t.tailX, t.tailY + hs);
                    this.ctx.lineTo(t.tailX - hs, t.tailY);
                    this.ctx.closePath();
                    this.ctx.fill();
                  }
                }
              }
            } else if (obj.type === "sticker") {
              const s = obj.layer;
              const cx = s.x + s.w / 2, cy = s.y + s.h / 2;
              this.ctx.save();
              this.ctx.translate(cx, cy);
              this.ctx.rotate(s.rotation);
              if (s.shadow && s.shadow.type !== "none") {
                this.ctx.shadowBlur = s.shadow.blur;
                this.ctx.shadowColor = s.shadow.color;
                if (s.shadow.type === "drop") {
                  this.ctx.shadowOffsetX = s.shadow.offsetX;
                  this.ctx.shadowOffsetY = s.shadow.offsetY;
                } else {
                  this.ctx.shadowOffsetX = 0;
                  this.ctx.shadowOffsetY = 0;
                }
              }
              this.ctx.drawImage(s.img, -s.w / 2, -s.h / 2, s.w, s.h);
              this.ctx.shadowBlur = 0;
              this.ctx.shadowOffsetX = 0;
              this.ctx.shadowOffsetY = 0;
              if (this.activeTool === "pan" || this.activeTool === "sticker" || this.activeTool === "select" || this.activeTool === "mosaic" || this.activeTool === "pencil" || this.activeTool === "text") {
                const iss = this.selectedSticker === s;
                this.ctx.strokeStyle = iss ? "rgba(255,200,0,0.9)" : "rgba(80,140,255,0.4)";
                this.ctx.lineWidth = 1 / this.viewScale;
                this.ctx.strokeRect(-s.w / 2, -s.h / 2, s.w, s.h);
                if (iss) {
                  const hs = HANDLE_SIZE / this.viewScale;
                  this.ctx.fillStyle = "#fff";
                  this.ctx.strokeStyle = "#333";
                  this.ctx.fillRect(s.w / 2 - hs, s.h / 2 - hs, hs, hs);
                  this.ctx.strokeRect(s.w / 2 - hs, s.h / 2 - hs, hs, hs);
                  this.ctx.beginPath();
                  this.ctx.arc(0, -s.h / 2 - 16 / this.viewScale, 6 / this.viewScale, 0, Math.PI * 2);
                  this.ctx.fillStyle = "#0af";
                  this.ctx.fill();
                  this.ctx.strokeStyle = "#fff";
                  this.ctx.stroke();
                  this.ctx.beginPath();
                  this.ctx.moveTo(0, -s.h / 2);
                  this.ctx.lineTo(0, -s.h / 2 - 10 / this.viewScale);
                  this.ctx.strokeStyle = "#0af";
                  this.ctx.stroke();
                  drawDeleteHandle(this.ctx, -s.w / 2, -s.h / 2, hs);
                }
              }
              this.ctx.restore();
            } else if (obj.type === "shape") {
              const s = obj.layer;
              const isSelected = this.selectedShape === s;
              this.ctx.save();
              if (s.type === "pencil" && s.points) {
                this.ctx.beginPath();
                this.ctx.strokeStyle = s.color;
                this.ctx.lineWidth = s.strokeWidth;
                this.ctx.lineCap = "round";
                this.ctx.lineJoin = "round";
                const box = getShapeBoundingBox(s);
                this.ctx.translate(box.cx, box.cy);
                this.ctx.rotate(s.rotation || 0);
                this.ctx.translate(-box.cx, -box.cy);
                if (s.points.length > 0) {
                  this.ctx.moveTo(s.points[0].x, s.points[0].y);
                  for (let i = 1; i < s.points.length; i++) {
                    this.ctx.lineTo(s.points[i].x, s.points[i].y);
                  }
                  this.ctx.stroke();
                }
              } else {
                const cx = s.x + (s.w - s.x) / 2;
                const cy = s.y + (s.h - s.y) / 2;
                this.ctx.translate(cx, cy);
                this.ctx.rotate(s.rotation || 0);
                this.ctx.translate(-cx, -cy);
                if (s.shadow && s.shadow.type !== "none") {
                  this.ctx.shadowBlur = s.shadow.blur;
                  this.ctx.shadowColor = s.shadow.color;
                  if (s.shadow.type === "drop") {
                    this.ctx.shadowOffsetX = s.shadow.offsetX;
                    this.ctx.shadowOffsetY = s.shadow.offsetY;
                  } else {
                    this.ctx.shadowOffsetX = 0;
                    this.ctx.shadowOffsetY = 0;
                  }
                }
                this.ctx.strokeStyle = s.color;
                this.ctx.fillStyle = s.color;
                this.ctx.lineWidth = s.strokeWidth;
                this.ctx.lineCap = "round";
                this.ctx.lineJoin = "round";
                drawShapePath(this.ctx, s.type, s.arrowType || "standard", s.color, s.x, s.y, s.w, s.h);
              }
              this.ctx.restore();
              if (isSelected && (this.activeTool === "pan" || this.activeTool === "select" || this.activeTool === "pencil" || this.activeTool === "sticker" || this.activeTool === "mosaic" || this.activeTool === "text")) {
                const box = getShapeBoundingBox(s);
                const bw = Math.max(box.w, 20);
                const bh = Math.max(box.h, 20);
                const handles = getShapeHandles(s, this.viewScale);
                const hs = HANDLE_SIZE / this.viewScale;
                this.ctx.save();
                this.ctx.translate(box.cx, box.cy);
                this.ctx.rotate(s.rotation || 0);
                this.ctx.strokeStyle = "rgba(255,200,0,0.9)";
                this.ctx.lineWidth = 1 / this.viewScale;
                this.ctx.strokeRect(-bw / 2 - 2, -bh / 2 - 2, bw + 4, bh + 4);
                this.ctx.beginPath();
                this.ctx.moveTo(0, -box.h / 2 - 2);
                this.ctx.lineTo(0, -box.h / 2 - 2 - 10 / this.viewScale);
                this.ctx.strokeStyle = "#0af";
                this.ctx.lineWidth = 1 / this.viewScale;
                this.ctx.stroke();
                this.ctx.restore();
                this.ctx.fillStyle = "#fff";
                this.ctx.strokeStyle = "#333";
                this.ctx.fillRect(handles.resize.x - hs, handles.resize.y - hs, hs, hs);
                this.ctx.strokeRect(handles.resize.x - hs, handles.resize.y - hs, hs, hs);
                this.ctx.beginPath();
                this.ctx.arc(handles.rot.x, handles.rot.y, 6 / this.viewScale, 0, Math.PI * 2);
                this.ctx.fillStyle = "#0af";
                this.ctx.fill();
                this.ctx.strokeStyle = "#fff";
                this.ctx.stroke();
                drawDeleteHandle(this.ctx, handles.del.x, handles.del.y, hs);
              }
            }
          });
          if (this.activeShape) {
            this.ctx.save();
            const s = this.activeShape;
            if (s.type === "pencil" && s.points) {
              this.ctx.beginPath();
              this.ctx.strokeStyle = s.color;
              this.ctx.lineWidth = s.strokeWidth;
              this.ctx.lineCap = "round";
              this.ctx.lineJoin = "round";
              const box = getShapeBoundingBox(s);
              this.ctx.translate(box.cx, box.cy);
              this.ctx.rotate(s.rotation || 0);
              this.ctx.translate(-box.cx, -box.cy);
              if (s.points.length > 0) {
                this.ctx.moveTo(s.points[0].x, s.points[0].y);
                for (let i = 1; i < s.points.length; i++) {
                  this.ctx.lineTo(s.points[i].x, s.points[i].y);
                }
                this.ctx.stroke();
              }
            } else {
              const cx = s.x + (s.w - s.x) / 2;
              const cy = s.y + (s.h - s.y) / 2;
              this.ctx.translate(cx, cy);
              this.ctx.rotate(s.rotation || 0);
              this.ctx.translate(-cx, -cy);
              this.ctx.strokeStyle = s.color;
              this.ctx.fillStyle = s.color;
              this.ctx.lineWidth = s.strokeWidth;
              this.ctx.lineCap = "round";
              this.ctx.lineJoin = "round";
              drawShapePath(this.ctx, s.type, s.arrowType || "standard", s.color, s.x, s.y, s.w, s.h);
            }
            this.ctx.restore();
          }
          if (this.hasSelection) {
            const x = Math.min(this.selStartX, this.selEndX), y = Math.min(this.selStartY, this.selEndY);
            const w = Math.abs(this.selEndX - this.selStartX), h = Math.abs(this.selEndY - this.selStartY);
            this.ctx.strokeStyle = "rgba(80,200,255,0.9)";
            this.ctx.lineWidth = 1 / this.viewScale;
            this.ctx.setLineDash([6 / this.viewScale, 3 / this.viewScale]);
            this.ctx.strokeRect(x, y, w, h);
            this.ctx.setLineDash([]);
          }
          this.ctx.restore();
        }
        //  Zoom / fit 
        _updateZoomSlider() {
          if (this.zoomSliderRange && this.zoomSliderLabel) {
            this.zoomSliderRange.value = String(this.viewScale);
            this.zoomSliderLabel.textContent = `${Math.round(this.viewScale * 100)}%`;
          }
        }
        _zoom(delta) {
          const ns = Math.max(0.05, Math.min(8, this.viewScale + delta));
          const cx = this.canvas.width / 2, cy = this.canvas.height / 2;
          this.viewOffX = cx - (cx - this.viewOffX) * (ns / this.viewScale);
          this.viewOffY = cy - (cy - this.viewOffY) * (ns / this.viewScale);
          this.viewScale = ns;
          this._updateZoomSlider();
          if (this.activeTool === "pan") this._updateOpts();
          this._redraw();
        }
        _fitView() {
          const wrap2 = this.canvas.parentElement;
          const cw = wrap2.clientWidth || this.canvas.width, ch = wrap2.clientHeight || this.canvas.height;
          this.viewScale = Math.min(cw / this.offCanvas.width, ch / this.offCanvas.height, 1);
          this.viewOffX = (cw - this.offCanvas.width * this.viewScale) / 2;
          this.viewOffY = (ch - this.offCanvas.height * this.viewScale) / 2;
          this._updateZoomSlider();
          if (this.activeTool === "pan") this._updateOpts();
          this._redraw();
        }
        //  Rotate / Flip 
        _rotate(deg) {
          this._mergeLayersToOff();
          this._pushUndo();
          const rad = deg * Math.PI / 180, cos = Math.abs(Math.cos(rad)), sin = Math.abs(Math.sin(rad));
          const ow = this.offCanvas.width;
          const oh = this.offCanvas.height;
          const nw = Math.round(this.offCanvas.width * cos + this.offCanvas.height * sin);
          const nh = Math.round(this.offCanvas.width * sin + this.offCanvas.height * cos);
          const tmp = document.createElement("canvas");
          tmp.width = nw;
          tmp.height = nh;
          const tc = tmp.getContext("2d");
          if (deg === 90 || deg === -90) {
            tc.translate(nw / 2, nh / 2);
            tc.rotate(rad);
          } else {
            tc.translate(nw / 2, nh / 2);
            tc.rotate(rad);
          }
          tc.drawImage(this.offCanvas, -this.offCanvas.width / 2, -this.offCanvas.height / 2);
          this.offCanvas.width = nw;
          this.offCanvas.height = nh;
          this.offCtx.drawImage(tmp, 0, 0);
          this.viewOffX += (ow / 2 - nw / 2) * this.viewScale;
          this.viewOffY += (oh / 2 - nh / 2) * this.viewScale;
        }
        _flip() {
          this._mergeLayersToOff();
          this._pushUndo();
          const tmp = document.createElement("canvas");
          tmp.width = this.offCanvas.width;
          tmp.height = this.offCanvas.height;
          const tc = tmp.getContext("2d");
          tc.translate(tmp.width, 0);
          tc.scale(-1, 1);
          tc.drawImage(this.offCanvas, 0, 0);
          this.offCtx.clearRect(0, 0, this.offCanvas.width, this.offCanvas.height);
          this.offCtx.drawImage(tmp, 0, 0);
          this._redraw();
        }
        _flipV() {
          this._mergeLayersToOff();
          this._pushUndo();
          const currentImg = this.offCtx.getImageData(0, 0, this.offCanvas.width, this.offCanvas.height);
          const flippedImg = flipImageDataVertical(currentImg);
          this.offCtx.putImageData(flippedImg, 0, 0);
          this._redraw();
        }
        _promptResize() {
          const bd = document.createElement("div");
          Object.assign(bd.style, {
            position: "fixed",
            inset: "0",
            zIndex: "var(--layer-modal, 600)",
            background: "rgba(0,0,0,.45)"
          });
          const box = document.createElement("div");
          Object.assign(box.style, {
            position: "fixed",
            top: "50%",
            left: "50%",
            transform: "translate(-50%,-50%)",
            background: "var(--secondary-bg-color,#2a2a2a)",
            border: "1px solid #555",
            borderRadius: "8px",
            padding: "20px",
            zIndex: "var(--layer-modal, 600)",
            color: "var(--primary-color,#ccc)",
            minWidth: "260px"
          });
          const inp = (label, val) => {
            const l = document.createElement("label");
            l.style.cssText = "display:flex;align-items:center;gap:8px;margin-bottom:10px;font-size:13px";
            l.innerHTML = `<span style="width:55px">${label}</span>`;
            const i = document.createElement("input");
            i.type = "number";
            i.value = String(val);
            i.min = "1";
            i.max = "10000";
            i.style.cssText = "flex:1;padding:4px 8px;border:1px solid #555;background:#333;color:#ccc;border-radius:4px;font-size:13px";
            this.optsWrap = l;
            l.appendChild(i);
            box.appendChild(l);
            return i;
          };
          box.innerHTML = '<p style="margin:0 0 14px;font-weight:bold;font-size:14px">Resize Canvas</p>';
          const wI = inp("Width (px)", this.offCanvas.width);
          const hI = inp("Height (px)", this.offCanvas.height);
          const scaleL = document.createElement("label");
          scaleL.style.cssText = "display:flex;align-items:center;gap:8px;margin-bottom:14px;font-size:13px";
          scaleL.innerHTML = `<span style="width:55px">Scale (%)</span>`;
          const scaleI = document.createElement("input");
          scaleI.type = "range";
          scaleI.min = "1";
          scaleI.max = "300";
          scaleI.value = "100";
          scaleI.style.flex = "1";
          const scaleSpan = document.createElement("span");
          scaleSpan.style.width = "40px";
          scaleSpan.style.textAlign = "right";
          scaleSpan.textContent = "100%";
          scaleL.appendChild(scaleI);
          scaleL.appendChild(scaleSpan);
          box.appendChild(scaleL);
          const propL = document.createElement("label");
          propL.style.cssText = "display:flex;align-items:center;gap:8px;margin-bottom:14px;font-size:13px;cursor:pointer";
          propL.innerHTML = '<input type="checkbox" checked/><span>Maintain aspect ratio</span>';
          const propCb = propL.querySelector("input");
          box.appendChild(propL);
          const anchorWrap = document.createElement("div");
          Object.assign(anchorWrap.style, {
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            marginBottom: "14px",
            opacity: "0.4",
            pointerEvents: "none",
            transition: "opacity 0.2s"
          });
          anchorWrap.innerHTML = '<div style="font-size:12px;margin-bottom:4px;color:#999">Anchor Position</div>';
          const grid = document.createElement("div");
          Object.assign(grid.style, {
            display: "grid",
            gridTemplateColumns: "repeat(3, 24px)",
            gap: "2px",
            background: "#555",
            padding: "2px",
            borderRadius: "4px"
          });
          let selectedAnchor = 4;
          const cells = [];
          for (let i = 0; i < 9; i++) {
            const cell = document.createElement("div");
            Object.assign(cell.style, {
              width: "24px",
              height: "24px",
              background: i === selectedAnchor ? "#0a74c9" : "#333",
              cursor: "pointer"
            });
            cell.onclick = () => {
              selectedAnchor = i;
              cells.forEach((c, idx) => c.style.background = idx === selectedAnchor ? "#0a74c9" : "#333");
            };
            cells.push(cell);
            grid.appendChild(cell);
          }
          anchorWrap.appendChild(grid);
          box.appendChild(anchorWrap);
          const aspect = this.offCanvas.width / this.offCanvas.height;
          const origW = this.offCanvas.width;
          const origH = this.offCanvas.height;
          const updateScaleSpan = (v) => scaleSpan.textContent = `${v}%`;
          wI.oninput = () => {
            if (propCb.checked) hI.value = String(Math.round(Number(wI.value) / aspect));
            scaleI.value = String(Math.round(Number(wI.value) / origW * 100));
            updateScaleSpan(scaleI.value);
          };
          hI.oninput = () => {
            if (propCb.checked) {
              wI.value = String(Math.round(Number(hI.value) * aspect));
              scaleI.value = String(Math.round(Number(wI.value) / origW * 100));
            } else {
              scaleI.value = String(Math.round(Number(hI.value) / origH * 100));
            }
            updateScaleSpan(scaleI.value);
          };
          scaleI.oninput = () => {
            const s = Math.max(0.01, Number(scaleI.value) / 100);
            wI.value = String(Math.max(1, Math.round(origW * s)));
            hI.value = String(Math.max(1, Math.round(origH * s)));
            updateScaleSpan(scaleI.value);
          };
          propCb.onchange = () => {
            anchorWrap.style.opacity = propCb.checked ? "0.4" : "1";
            anchorWrap.style.pointerEvents = propCb.checked ? "none" : "auto";
            if (propCb.checked) {
              hI.value = String(Math.round(Number(wI.value) / aspect));
              scaleI.value = String(Math.round(Number(wI.value) / origW * 100));
              updateScaleSpan(scaleI.value);
            }
          };
          const rowStyle = "display:flex;gap:8px;justify-content:space-between;align-items:center";
          const row = Object.assign(document.createElement("div"), {
            innerHTML: `<div style="display:flex;align-items:center;gap:6px;font-size:12px"><label style="display:flex;align-items:center;gap:4px;cursor:pointer"><input type="checkbox" id="bgcb">Fill BG</label><input type="color" id="bgcol" value="#ffffff" disabled style="width:22px;height:22px;padding:0;border:none;background:none;cursor:pointer"></div><div><button id="clearBtn" style="padding:6px 16px;border-radius:4px;border:1px solid #c92a2a;background:#b30000;color:#fff;cursor:pointer;font-size:13px;margin-right:8px">Clear all</button><button id="rc" style="padding:6px 16px;border-radius:4px;border:1px solid #555;background:#333;color:#ccc;cursor:pointer;font-size:13px">Cancel</button><button id="ra" style="padding:6px 16px;border-radius:4px;border:none;background:var(--primary-accent-color,#0a74c9);color:#fff;cursor:pointer;font-size:13px;margin-left:8px">Apply</button></div>`
          });
          box.appendChild(row);
          const bgCb = box.querySelector("#bgcb");
          const bgCol = box.querySelector("#bgcol");
          bgCb.onchange = () => bgCol.disabled = !bgCb.checked;
          document.body.appendChild(bd);
          document.body.appendChild(box);
          const close = () => {
            bd.remove();
            box.remove();
          };
          bd.addEventListener("click", close);
          box.querySelector("#rc").onclick = close;
          box.querySelector("#clearBtn").onclick = async () => {
            const index = await ActionSheetSelectPromise({
              title: "Clear all shapes, texts, and stickers?",
              options: ["Confirm"],
              cancelButtonText: "Cancel"
            });
            if (index === 0) {
              this._pushUndo();
              this.displayObjects = [];
              this.selectedShape = null;
              this.selectedSticker = null;
              this.selectedText = null;
              this.offCtx.clearRect(0, 0, this.offCanvas.width, this.offCanvas.height);
              if (bgCb.checked) {
                this.offCtx.fillStyle = bgCol.value;
                this.offCtx.fillRect(0, 0, this.offCanvas.width, this.offCanvas.height);
              }
              close();
              this._redraw();
            }
          };
          box.querySelector("#ra").onclick = () => {
            const nw = parseInt(wI.value, 10), nh = parseInt(hI.value, 10);
            if (isNaN(nw) || isNaN(nh) || nw < 1 || nh < 1) return;
            close();
            this._mergeLayersToOff();
            this._pushUndo();
            const tmp = document.createElement("canvas");
            tmp.width = nw;
            tmp.height = nh;
            const ctx = tmp.getContext("2d");
            if (bgCb.checked) {
              ctx.fillStyle = bgCol.value;
              ctx.fillRect(0, 0, nw, nh);
              this.resizeBgColor = bgCol.value;
            } else {
              this.resizeBgColor = null;
            }
            if (propCb.checked) {
              ctx.drawImage(this.offCanvas, 0, 0, nw, nh);
            } else {
              const ow = this.offCanvas.width;
              const oh = this.offCanvas.height;
              let dx = 0;
              let dy = 0;
              if (selectedAnchor % 3 === 0) {
                dx = 0;
              } else if (selectedAnchor % 3 === 1) {
                dx = (nw - ow) / 2;
              } else {
                dx = nw - ow;
              }
              if (selectedAnchor < 3) {
                dy = 0;
              } else if (selectedAnchor < 6) {
                dy = (nh - oh) / 2;
              } else {
                dy = nh - oh;
              }
              ctx.drawImage(this.offCanvas, dx, dy);
            }
            this.offCanvas.width = nw;
            this.offCanvas.height = nh;
            this.offCtx.drawImage(tmp, 0, 0);
            this._fitView();
          };
        }
        //  Text 
        _showTextInput(screenX, screenY, cvX, cvY, editId, prefill) {
          const wrap2 = this.canvas.parentElement;
          const rect = wrap2.getBoundingClientRect();
          const left = screenX - rect.left;
          const top = screenY - rect.top - 28;
          const applyStyle = (inp2) => {
            inp2.style.fontFamily = this.textFontFamily;
            inp2.style.fontSize = "18px";
            inp2.style.fontWeight = this.textBold ? "bold" : "normal";
            inp2.style.fontStyle = this.textItalic ? "italic" : "normal";
            inp2.style.color = this.textColor;
          };
          const inp = document.createElement("input");
          inp.type = "text";
          inp.className = "ie-text-input";
          inp.placeholder = "Type text\u2026";
          inp.style.left = `${left}px`;
          inp.style.top = `${top + 28}px`;
          inp.style.transform = "translateY(-50%)";
          inp.style.textAlign = "left";
          inp.dataset.cvx = String(cvX);
          inp.dataset.cvy = String(cvY);
          if (editId) inp.dataset.editid = editId;
          if (prefill) inp.value = prefill;
          applyStyle(inp);
          inp.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              this._commitText();
            }
            if (e.key === "Escape") {
              this._cancelText();
            }
          });
          wrap2.appendChild(inp);
          this.textInput = inp;
          setTimeout(() => {
            inp.focus();
            if (prefill) inp.select();
          }, 50);
        }
        _commitText() {
          if (!this.textInput) return;
          const txt = this.textInput.value.trim();
          const cvX = Number(this.textInput.dataset.cvx), cvY = Number(this.textInput.dataset.cvy);
          const editId = this.textInput.dataset.editid || null;
          this.textInput.remove();
          this.textInput = null;
          if (!txt) return;
          this.ctx.font = this._textFont({
            fontFamily: this.textFontFamily,
            fontSize: this.textFontSize,
            bold: this.textBold,
            italic: this.textItalic
          });
          const tw = this.ctx.measureText(txt).width;
          this._pushUndo();
          if (editId) {
            const idx = this.displayObjects.findIndex((x) => x.id === editId);
            if (idx !== -1) {
              const oldLayer = this.displayObjects[idx].layer;
              const newLayer = {
                ...oldLayer,
                text: txt,
                x: Math.round(cvX + tw / 2),
                y: cvY,
                color: this.textColor,
                fontSize: this.textFontSize,
                fontFamily: this.textFontFamily,
                bold: this.textBold,
                italic: this.textItalic,
                strokeColor: this.textStrokeColor,
                strokeWidth: this.textStrokeWidth,
                tailActive: this.textTailActive
              };
              if (newLayer.tailActive && (newLayer.tailX === void 0 || newLayer.tailY === void 0)) {
                newLayer.tailX = newLayer.x + 50;
                newLayer.tailY = newLayer.y + 50;
              }
              this.displayObjects[idx].layer = newLayer;
            }
          } else {
            const newId = `txt_${Date.now()}`;
            const layer = {
              id: newId,
              text: txt,
              x: Math.round(cvX + tw / 2),
              y: cvY,
              color: this.textColor,
              fontSize: this.textFontSize,
              fontFamily: this.textFontFamily,
              bold: this.textBold,
              italic: this.textItalic,
              rotation: 0,
              strokeColor: this.textStrokeColor,
              strokeWidth: this.textStrokeWidth,
              tailActive: this.textTailActive
            };
            if (layer.tailActive) {
              layer.tailX = layer.x + 50;
              layer.tailY = layer.y + 50;
            }
            this.displayObjects.push({ id: newId, type: "text", layer });
            this.selectedText = layer;
          }
          this._setTool("pan", true);
        }
        _cancelText() {
          var _a;
          (_a = this.textInput) == null ? void 0 : _a.remove();
          this.textInput = null;
        }
        //  Sticker 
        _triggerStickerUpload() {
          const inp = document.createElement("input");
          inp.type = "file";
          inp.accept = "image/*";
          inp.onchange = () => {
            var _a;
            const f = (_a = inp.files) == null ? void 0 : _a[0];
            if (!f) return;
            const r = new FileReader();
            r.onload = (ev) => this._addStickerFromUrl(ev.target.result);
            r.readAsDataURL(f);
          };
          inp.click();
        }
        _addStickerFromUrl(src) {
          const img = new Image();
          img.onload = () => {
            this._pushUndo();
            const maxW = Math.min(img.naturalWidth, 200), h = Math.round(maxW * (img.naturalHeight / img.naturalWidth));
            const newId = `stk_${Date.now()}`;
            const s = {
              id: newId,
              img,
              x: (this.offCanvas.width - maxW) / 2,
              y: (this.offCanvas.height - h) / 2,
              w: maxW,
              h,
              rotation: 0
            };
            this.displayObjects.push({ id: newId, type: "sticker", layer: s });
            this.selectedSticker = s;
            this._setTool("pan", true);
          };
          img.src = src;
        }
        _mergeSelectedSticker() {
          if (!this.selectedSticker) return;
          const s = this.selectedSticker;
          const cx = s.x + s.w / 2, cy = s.y + s.h / 2;
          this.offCtx.save();
          this.offCtx.translate(cx, cy);
          this.offCtx.rotate(s.rotation);
          this.offCtx.drawImage(s.img, -s.w / 2, -s.h / 2, s.w, s.h);
          this.offCtx.restore();
          this.displayObjects = this.displayObjects.filter((x) => x.layer !== s);
          this.selectedSticker = null;
          this._updateOpts();
          this._redraw();
        }
        _mergeSelectedText() {
          if (!this.selectedText) return;
          const t = this.selectedText;
          this.offCtx.font = this._textFont(t);
          const m = this.offCtx.measureText(t.text);
          const tw = m.width;
          const th = t.fontSize;
          const cx = t.x;
          const cy = t.y;
          let lx = 0, ly = 0;
          if (t.tailActive && t.tailX !== void 0 && t.tailY !== void 0) {
            const dx = t.tailX - cx;
            const dy = t.tailY - cy;
            const cos = Math.cos(-t.rotation);
            const sin = Math.sin(-t.rotation);
            lx = dx * cos - dy * sin;
            ly = dx * sin + dy * cos;
          }
          this.offCtx.save();
          this.offCtx.translate(cx, cy);
          this.offCtx.rotate(t.rotation);
          if (t.strokeWidth && t.strokeWidth > 0) {
            this.offCtx.strokeStyle = t.strokeColor || "#000000";
            this.offCtx.lineWidth = t.strokeWidth;
            this.offCtx.lineJoin = "round";
            buildBubblePath(this.offCtx, tw, th, lx, ly, !!t.tailActive);
            this.offCtx.stroke();
          }
          this.offCtx.fillStyle = t.color;
          this.offCtx.fillText(t.text, -tw / 2, th / 2 - 2);
          this.offCtx.restore();
          this.displayObjects = this.displayObjects.filter((x) => x.layer !== t);
          this.selectedText = null;
          this._updateOpts();
          this._redraw();
        }
        //  Helpers 
        _textFont(t) {
          return `${t.italic ? "italic " : ""}${t.bold ? "bold " : ""}${t.fontSize}px ${t.fontFamily}`;
        }
        //  Upload / Layers merge 
        _triggerUpload() {
          const inp = document.createElement("input");
          inp.type = "file";
          inp.accept = "image/*";
          inp.onchange = () => {
            var _a;
            if ((_a = inp.files) == null ? void 0 : _a[0]) this._loadFile(inp.files[0]);
          };
          inp.click();
        }
        _loadFile(file) {
          const r = new FileReader();
          r.onload = (ev) => this.loadImageFromUrl(ev.target.result);
          r.readAsDataURL(file);
        }
        loadImageFromUrl(src) {
          const img = new Image();
          img.crossOrigin = "anonymous";
          const load = (el) => {
            this.displayObjects = [];
            this.undoStack = [];
            this.redoStack = [];
            this.offCanvas.width = el.naturalWidth;
            this.offCanvas.height = el.naturalHeight;
            this.offCtx.drawImage(el, 0, 0);
            setTimeout(() => this._fitView(), 0);
          };
          img.onload = () => load(img);
          img.onerror = () => {
            const img2 = new Image();
            img2.onload = () => load(img2);
            img2.src = src;
          };
          img.src = src;
        }
        //  Download 
        _showDownload() {
          const fmts = ["png", "jpeg", "webp"];
          const bd = document.createElement("div");
          Object.assign(bd.style, {
            position: "fixed",
            inset: "0",
            zIndex: "var(--layer-modal, 600)",
            background: "rgba(0,0,0,.4)"
          });
          const menu = document.createElement("div");
          Object.assign(menu.style, {
            position: "fixed",
            top: "50%",
            left: "50%",
            transform: "translate(-50%,-50%)",
            background: "var(--secondary-bg-color,#2a2a2a)",
            border: "1px solid #555",
            borderRadius: "8px",
            padding: "16px",
            zIndex: "var(--layer-modal, 600)",
            color: "var(--primary-color,#ccc)",
            minWidth: "200px"
          });
          menu.innerHTML = '<p style="margin:0 0 12px;font-weight:bold">Download as</p>';
          fmts.forEach((fmt) => {
            const b = document.createElement("button");
            Object.assign(b.style, {
              display: "block",
              width: "100%",
              padding: "8px",
              marginBottom: "6px",
              cursor: "pointer",
              borderRadius: "4px",
              border: "1px solid #555",
              background: "#333",
              color: "#eee",
              fontSize: "13px"
            });
            b.textContent = fmt.toUpperCase();
            b.onclick = () => {
              this._download(fmt);
              menu.remove();
              bd.remove();
            };
            menu.appendChild(b);
          });
          const cancel = document.createElement("button");
          Object.assign(cancel.style, {
            display: "block",
            width: "100%",
            padding: "8px",
            cursor: "pointer",
            borderRadius: "4px",
            border: "1px solid #555",
            background: "transparent",
            color: "#999",
            fontSize: "13px"
          });
          cancel.textContent = "Cancel";
          cancel.onclick = () => {
            menu.remove();
            bd.remove();
          };
          menu.appendChild(cancel);
          bd.onclick = () => {
            menu.remove();
            bd.remove();
          };
          document.body.appendChild(bd);
          document.body.appendChild(menu);
        }
        _download(fmt) {
          this._mergeLayersToOff(false);
          const type = fmt === "jpeg" ? "image/jpeg" : fmt === "webp" ? "image/webp" : "image/png";
          const a = document.createElement("a");
          a.href = this.offCanvas.toDataURL(type, 0.92);
          a.download = `image.${fmt}`;
          a.click();
        }
        //  Undo / Redo 
        _pushUndo() {
          this.undoStack.push({
            imageData: this.offCtx.getImageData(0, 0, this.offCanvas.width, this.offCanvas.height),
            displayObjects: this.displayObjects.map((obj) => ({
              id: obj.id,
              type: obj.type,
              layer: { ...obj.layer, ...obj.type === "sticker" ? { img: obj.layer.img } : {} }
            }))
          });
          this.redoStack = [];
          if (this.undoStack.length > 50) this.undoStack.shift();
        }
        undo() {
          if (!this.undoStack.length) return;
          this.redoStack.push({
            imageData: this.offCtx.getImageData(0, 0, this.offCanvas.width, this.offCanvas.height),
            displayObjects: this.displayObjects.map((obj) => ({
              id: obj.id,
              type: obj.type,
              layer: { ...obj.layer, ...obj.type === "sticker" ? { img: obj.layer.img } : {} }
            }))
          });
          const st = this.undoStack.pop();
          this._restoreSnapshot(st);
        }
        redo() {
          if (!this.redoStack.length) return;
          this.undoStack.push({
            imageData: this.offCtx.getImageData(0, 0, this.offCanvas.width, this.offCanvas.height),
            displayObjects: this.displayObjects.map((obj) => ({
              id: obj.id,
              type: obj.type,
              layer: { ...obj.layer, ...obj.type === "sticker" ? { img: obj.layer.img } : {} }
            }))
          });
          const st = this.redoStack.pop();
          this._restoreSnapshot(st);
        }
        _restoreSnapshot(st) {
          this.offCanvas.width = st.imageData.width;
          this.offCanvas.height = st.imageData.height;
          this.offCtx.putImageData(st.imageData, 0, 0);
          this.displayObjects = st.displayObjects.map((obj) => {
            if (obj.type === "shape" && obj.layer.points) {
              return { ...obj, layer: { ...obj.layer, points: [...obj.layer.points || []] } };
            }
            return { ...obj, layer: { ...obj.layer } };
          });
          this._redraw();
        }
        _mergeLayersToOff(clearLayers = true) {
          this.displayObjects.forEach((obj) => {
            if (obj.type === "text") {
              const t = obj.layer;
              this.offCtx.font = this._textFont(t);
              const m = this.offCtx.measureText(t.text);
              const tw = m.width;
              const th = t.fontSize;
              const cx = t.x;
              const cy = t.y;
              let lx = 0, ly = 0;
              if (t.tailActive && t.tailX !== void 0 && t.tailY !== void 0) {
                const dx = t.tailX - cx;
                const dy = t.tailY - cy;
                const cos = Math.cos(-t.rotation);
                const sin = Math.sin(-t.rotation);
                lx = dx * cos - dy * sin;
                ly = dx * sin + dy * cos;
              }
              this.offCtx.save();
              this.offCtx.translate(cx, cy);
              this.offCtx.rotate(t.rotation);
              if (t.shadow && t.shadow.type !== "none") {
                this.offCtx.shadowBlur = t.shadow.blur;
                this.offCtx.shadowColor = t.shadow.color;
                if (t.shadow.type === "drop") {
                  this.offCtx.shadowOffsetX = t.shadow.offsetX;
                  this.offCtx.shadowOffsetY = t.shadow.offsetY;
                } else {
                  this.offCtx.shadowOffsetX = 0;
                  this.offCtx.shadowOffsetY = 0;
                }
                this.offCtx.globalAlpha = t.shadow.opacity / 100;
              }
              if (t.strokeWidth && t.strokeWidth > 0) {
                this.offCtx.strokeStyle = t.strokeColor || "#000000";
                this.offCtx.lineWidth = t.strokeWidth;
                this.offCtx.lineJoin = "round";
                buildBubblePath(this.offCtx, tw, th, lx, ly, !!t.tailActive);
                this.offCtx.stroke();
              }
              this.offCtx.fillStyle = t.color;
              this.offCtx.fillText(t.text, -tw / 2, th / 2 - 2);
              this.offCtx.restore();
            } else if (obj.type === "sticker") {
              const s = obj.layer;
              const cx = s.x + s.w / 2, cy = s.y + s.h / 2;
              this.offCtx.save();
              this.offCtx.translate(cx, cy);
              this.offCtx.rotate(s.rotation);
              if (s.shadow && s.shadow.type !== "none") {
                this.offCtx.shadowBlur = s.shadow.blur;
                this.offCtx.shadowColor = s.shadow.color;
                if (s.shadow.type === "drop") {
                  this.offCtx.shadowOffsetX = s.shadow.offsetX;
                  this.offCtx.shadowOffsetY = s.shadow.offsetY;
                } else {
                  this.offCtx.shadowOffsetX = 0;
                  this.offCtx.shadowOffsetY = 0;
                }
              }
              this.offCtx.drawImage(s.img, -s.w / 2, -s.h / 2, s.w, s.h);
              this.offCtx.restore();
            } else if (obj.type === "shape") {
              const s = obj.layer;
              this.offCtx.save();
              if (s.type === "pencil" && s.points) {
                this.offCtx.beginPath();
                this.offCtx.strokeStyle = s.color;
                this.offCtx.lineWidth = s.strokeWidth;
                this.offCtx.lineCap = "round";
                this.offCtx.lineJoin = "round";
                const box = getShapeBoundingBox(s);
                this.offCtx.translate(box.cx, box.cy);
                this.offCtx.rotate(s.rotation || 0);
                this.offCtx.translate(-box.cx, -box.cy);
                if (s.shadow && s.shadow.type !== "none") {
                  this.offCtx.shadowBlur = s.shadow.blur;
                  this.offCtx.shadowColor = s.shadow.color;
                  if (s.shadow.type === "drop") {
                    this.offCtx.shadowOffsetX = s.shadow.offsetX;
                    this.offCtx.shadowOffsetY = s.shadow.offsetY;
                  } else {
                    this.offCtx.shadowOffsetX = 0;
                    this.offCtx.shadowOffsetY = 0;
                  }
                }
                if (s.points.length > 0) {
                  this.offCtx.moveTo(s.points[0].x, s.points[0].y);
                  for (let i = 1; i < s.points.length; i++) {
                    this.offCtx.lineTo(s.points[i].x, s.points[i].y);
                  }
                  this.offCtx.stroke();
                }
              } else {
                const box = getShapeBoundingBox(s);
                this.offCtx.translate(box.cx, box.cy);
                this.offCtx.rotate(s.rotation || 0);
                this.offCtx.translate(-box.cx, -box.cy);
                if (s.shadow && s.shadow.type !== "none") {
                  this.offCtx.shadowBlur = s.shadow.blur;
                  this.offCtx.shadowColor = s.shadow.color;
                  if (s.shadow.type === "drop") {
                    this.offCtx.shadowOffsetX = s.shadow.offsetX;
                    this.offCtx.shadowOffsetY = s.shadow.offsetY;
                  } else {
                    this.offCtx.shadowOffsetX = 0;
                    this.offCtx.shadowOffsetY = 0;
                  }
                }
                this.offCtx.strokeStyle = s.color;
                this.offCtx.fillStyle = s.color;
                this.offCtx.lineWidth = s.strokeWidth;
                this.offCtx.lineCap = "round";
                this.offCtx.lineJoin = "round";
                drawShapePath(this.offCtx, s.type, s.arrowType || "standard", s.color, s.x, s.y, s.w, s.h);
              }
              this.offCtx.restore();
            }
          });
          if (clearLayers) {
            this.displayObjects = [];
          }
        }
        _initBlank(w, h) {
          this.offCanvas.width = w;
          this.offCanvas.height = h;
          this.offCtx.fillStyle = "#ffffff";
          this.offCtx.fillRect(0, 0, w, h);
          setTimeout(() => this._fitView(), 0);
        }
        _deleteSelected() {
          this._pushUndo();
          if (this.selectedShape) {
            const idx = this.displayObjects.findIndex((o) => o.layer === this.selectedShape);
            if (idx !== -1) this.displayObjects.splice(idx, 1);
            this.selectedShape = null;
          }
          if (this.selectedSticker) {
            const idx = this.displayObjects.findIndex((o) => o.layer === this.selectedSticker);
            if (idx !== -1) this.displayObjects.splice(idx, 1);
            this.selectedSticker = null;
          }
          if (this.selectedText) {
            const idx = this.displayObjects.findIndex((o) => o.layer === this.selectedText);
            if (idx !== -1) this.displayObjects.splice(idx, 1);
            this.selectedText = null;
            this._updateOpts();
          }
        }
        _addShadowUI(el, layer) {
          const sh = layer.shadow || { type: "none", offsetX: 5, offsetY: 5, blur: 10, color: "#000000", opacity: 50 };
          layer.shadow = sh;
          const row = document.createElement("div");
          row.style.display = "flex";
          row.style.alignItems = "center";
          row.style.gap = "4px";
          row.innerHTML = `<div style="font-size:12px;color:#888;margin-top:0px">Shadow:</div>`;
          const controls = document.createElement("div");
          controls.style.display = "flex";
          controls.style.gap = "4px";
          controls.style.alignItems = "center";
          const typeSel = document.createElement("select");
          typeSel.style.background = "#333";
          typeSel.style.color = "#ccc";
          typeSel.style.padding = "2px";
          typeSel.style.borderRadius = "3px";
          typeSel.innerHTML = `<option value="none" ${sh.type === "none" ? "selected" : ""}>None</option><option value="drop" ${sh.type === "drop" ? "selected" : ""}>Shadow</option><option value="glow" ${sh.type === "glow" ? "selected" : ""}>Glow</option>`;
          typeSel.onchange = () => {
            sh.type = typeSel.value;
            this._redraw();
          };
          controls.appendChild(typeSel);
          const colorI = document.createElement("input");
          colorI.type = "color";
          colorI.value = sh.color;
          colorI.style.width = "24px";
          colorI.style.height = "24px";
          colorI.style.padding = "0";
          colorI.oninput = () => {
            sh.color = colorI.value;
            this._redraw();
          };
          controls.appendChild(colorI);
          const blurL = document.createElement("label");
          blurL.innerHTML = `B:<input type="range" min="0" max="60" value="${sh.blur}" style="width:40px"/>`;
          blurL.querySelector("input").oninput = (e) => {
            sh.blur = Number(e.target.value);
            this._redraw();
          };
          controls.appendChild(blurL);
          const opL = document.createElement("label");
          opL.innerHTML = `O:<input type="range" min="0" max="100" value="${sh.opacity}" style="width:40px"/>`;
          opL.querySelector("input").oninput = (e) => {
            sh.opacity = Number(e.target.value);
            this._redraw();
          };
          controls.appendChild(opL);
          row.appendChild(controls);
          el.appendChild(row);
        }
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/i-editor/i-editor-demo.tsx
  var IEditorDemoPage, iEditorDemo;
  var init_i_editor_demo = __esm({
    "node_modules/lupine.components/src/component-pool/i-editor/i-editor-demo.tsx"() {
      init_i_editor();
      init_jsx_runtime();
      IEditorDemoPage = () => {
        let editor;
        const ref = {
          onLoad: async () => {
            const container = ref.$(".i-edit-view-box");
            if (container) {
              editor = IEditor.getEditor(container);
            }
          }
        };
        const css2 = {
          display: "flex",
          flexDirection: "column",
          height: "600px",
          padding: "16px",
          boxSizing: "border-box",
          ".i-editor-demo-header": {
            display: "flex",
            flexDirection: "row",
            alignItems: "center",
            justifyContent: "space-between",
            paddingBottom: "12px"
          },
          ".i-editor-demo-desc": {
            fontSize: "12px",
            color: "var(--secondary-color, #888)",
            marginLeft: "8px"
          },
          ".i-edt-body": {
            flex: 1,
            border: "1px solid var(--primary-border, #444)",
            borderRadius: "8px",
            overflow: "hidden"
          },
          ".i-edit-view-box": {
            width: "100%",
            height: "100%"
          }
        };
        return /* @__PURE__ */ jsx("div", { ref, css: css2, children: [
          /* @__PURE__ */ jsx("div", { class: "i-editor-demo-header", children: [
            /* @__PURE__ */ jsx("h3", { style: { margin: 0 }, children: "Image Editor" }),
            /* @__PURE__ */ jsx("span", { class: "i-editor-demo-desc", children: "Upload an image or start with a blank canvas. Use the toolbar to draw, crop, rotate, add text, add stickers, and more." })
          ] }),
          /* @__PURE__ */ jsx("div", { class: "i-edt-body", children: /* @__PURE__ */ jsx("div", { class: "i-edit-view-box" }) })
        ] });
      };
      iEditorDemo = {
        id: "i-editor-demo",
        text: "Image Editor",
        args: {},
        argTypes: {},
        render: () => {
          return /* @__PURE__ */ jsx(IEditorDemoPage, {});
        }
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/i-editor/index.ts
  var init_i_editor2 = __esm({
    "node_modules/lupine.components/src/component-pool/i-editor/index.ts"() {
      init_i_editor();
      init_i_editor_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/youtube-player/youtube-player.tsx
  var YouTubePlayer;
  var init_youtube_player = __esm({
    "node_modules/lupine.components/src/component-pool/youtube-player/youtube-player.tsx"() {
      init_jsx_runtime();
      YouTubePlayer = (props) => {
        const {
          videoId,
          width = "100%",
          height = "100%",
          autoplay = false,
          allowFullScreen = true,
          style,
          class: className
        } = props;
        const src = `https://www.youtube.com/embed/${videoId}?autoplay=${autoplay ? 1 : 0}`;
        return /* @__PURE__ */ jsx("div", { class: className, css: { position: "relative", width, height, ...style }, children: /* @__PURE__ */ jsx(
          "iframe",
          {
            width: "100%",
            height: "100%",
            src,
            title: "YouTube video player",
            frameBorder: "0",
            allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",
            allowFullScreen,
            style: { border: "none", display: "block" }
          }
        ) });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/youtube-player/youtube-player-demo.tsx
  var youtubePlayerDemo;
  var init_youtube_player_demo = __esm({
    "node_modules/lupine.components/src/component-pool/youtube-player/youtube-player-demo.tsx"() {
      init_youtube_player();
      init_jsx_runtime();
      youtubePlayerDemo = {
        id: "youtubePlayerDemo",
        text: "YouTube Player",
        args: {
          videoId: "dQw4w9WgXcQ",
          width: "100%",
          height: "400px",
          autoplay: false
        },
        argTypes: {
          videoId: { control: "text", description: "YouTube Video ID" },
          width: { control: "text" },
          height: { control: "text" },
          autoplay: { control: "boolean" }
        },
        render: (args) => {
          return /* @__PURE__ */ jsx(
            "div",
            {
              style: {
                padding: "20px",
                display: "flex",
                flexDirection: "column",
                gap: "40px",
                width: "100%",
                maxWidth: "800px"
              },
              children: [
                /* @__PURE__ */ jsx("section", { children: [
                  /* @__PURE__ */ jsx("div", { class: "section-title", children: "Basic Usage" }),
                  /* @__PURE__ */ jsx("p", { style: { fontSize: "14px", color: "#666", marginBottom: "16px" }, children: "Embed a YouTube video simply by providing its ID." }),
                  /* @__PURE__ */ jsx(YouTubePlayer, { ...args })
                ] }),
                /* @__PURE__ */ jsx("section", { children: [
                  /* @__PURE__ */ jsx("div", { class: "section-title", children: "Custom Size" }),
                  /* @__PURE__ */ jsx("div", { style: { display: "flex", gap: "20px", alignItems: "center" }, children: [
                    /* @__PURE__ */ jsx(YouTubePlayer, { videoId: "jNQXAC9IVRw", width: "300px", height: "200px" }),
                    /* @__PURE__ */ jsx(YouTubePlayer, { videoId: "M7lc1UVf-VE", width: "400px", height: "250px" })
                  ] })
                ] })
              ]
            }
          );
        },
        code: `import { YouTubePlayer } from 'lupine.components/component-pool';

<YouTubePlayer 
  videoId="dQw4w9WgXcQ" 
  width="100%" 
  height="400px" 
/>
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/youtube-player/index.ts
  var init_youtube_player2 = __esm({
    "node_modules/lupine.components/src/component-pool/youtube-player/index.ts"() {
      init_youtube_player();
      init_youtube_player_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/p-editor/p-editor-types.ts
  var HANDLE_SIZE2;
  var init_p_editor_types = __esm({
    "node_modules/lupine.components/src/component-pool/p-editor/p-editor-types.ts"() {
      HANDLE_SIZE2 = 8;
    }
  });

  // node_modules/lupine.components/src/component-pool/p-editor/p-editor-utils.ts
  var loadPdfScripts;
  var init_p_editor_utils = __esm({
    "node_modules/lupine.components/src/component-pool/p-editor/p-editor-utils.ts"() {
      loadPdfScripts = () => {
        return new Promise((resolve, reject) => {
          let loadedCount = 0;
          const depsToLoad = [];
          if (!window.pdfjsLib) {
            depsToLoad.push("https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js");
          }
          if (!window.PDFLib) {
            depsToLoad.push("https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js");
          }
          if (depsToLoad.length === 0) {
            resolve();
            return;
          }
          const checkDone = () => {
            loadedCount++;
            if (loadedCount === depsToLoad.length) {
              if (window.pdfjsLib) {
                window.pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
              }
              resolve();
            }
          };
          depsToLoad.forEach((url) => {
            const script = document.createElement("script");
            script.src = url;
            script.onload = checkDone;
            script.onerror = () => reject(new Error(`Failed to load ${url}`));
            document.head.appendChild(script);
          });
        });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/p-editor/p-editor-styles.ts
  var PEDITOR_STYLES;
  var init_p_editor_styles = __esm({
    "node_modules/lupine.components/src/component-pool/p-editor/p-editor-styles.ts"() {
      PEDITOR_STYLES = `
  .pe-container { display:flex;flex-direction:column;width:100%;height:100%;overflow:hidden;background:#333;color:#eee; }
  .pe-toolbar { display:flex;flex-wrap:wrap;gap:2px;padding:6px 8px;background:var(--secondary-bg-color,#2a2a2a);border-bottom:1px solid #444;user-select:none;flex-shrink:0;align-items:center; }
  .pe-grp { display:flex;gap:2px;align-items:center;padding:0 4px;border-right:1px solid #555; }
  .pe-grp:last-child { border-right:none; }
  .pe-btn { display:inline-flex;align-items:center;justify-content:center;border:1px solid transparent;border-radius:4px;cursor:pointer;color:var(--primary-color,#ccc);transition:background .15s;flex-shrink:0; }
  .pe-btn:hover { background:var(--primary-accent-color,#0a74c9);color:#fff; }
  .pe-btn.active { background:var(--primary-accent-color,#0a74c9);color:#fff; }
  .pe-btn:disabled { opacity:0.5;cursor:not-allowed; }
  
  .pe-main { display:flex;flex:1;overflow:hidden; }
  
  .pe-sidebar { width:180px;background:#222;border-right:1px solid #444;overflow-y:auto;display:flex;flex-direction:column;padding:8px;gap:8px; }
  .pe-thumb-wrap { position:relative;background:#fff;border:2px solid transparent;cursor:pointer;transition:border-color 0.2s; }
  .pe-thumb-wrap.active { border-color:var(--primary-accent-color,#0a74c9); }
  .pe-thumb-wrap.drag-over { border-top: 2px solid #0f0; }
  .pe-thumb-canvas { width:100%;height:auto;display:block; }
  .pe-thumb-num { position:absolute;bottom:4px;right:4px;background:rgba(0,0,0,0.6);color:#fff;font-size:10px;padding:2px 4px;border-radius:4px; }
  .pe-thumb-del { position:absolute;top:4px;right:4px;background:rgba(255,0,0,0.8);color:#fff;font-size:12px;width:18px;height:18px;line-height:18px;text-align:center;border-radius:50%;cursor:pointer;display:none; }
  .pe-thumb-add-top, .pe-thumb-add-bottom { position:absolute;left:50%;transform:translateX(-50%);background:rgba(0,180,0,0.8);color:#fff;font-size:16px;width:20px;height:20px;line-height:20px;text-align:center;border-radius:50%;cursor:pointer;display:none;z-index:10; }
  .pe-thumb-add-top { top:-10px; }
  .pe-thumb-add-bottom { bottom:-10px; }
  .pe-thumb-wrap:hover .pe-thumb-del, 
  .pe-thumb-wrap:hover .pe-thumb-add-top, 
  .pe-thumb-wrap:hover .pe-thumb-add-bottom { display:block; }
  
  .pe-canvas-area { flex:1;overflow:auto;position:relative;background:repeating-conic-gradient(#444 0% 25%,#555 0% 50%) 0 0/20px 20px;display:flex;justify-content:center;align-items:flex-start;padding:20px; }
  .pe-canvas-wrap { position:relative;box-shadow:0 4px 12px rgba(0,0,0,0.5); }
  .pe-canvas-bg { position:absolute;top:0;left:0;z-index:1; } /* pdf rendering */
  .pe-canvas-fg { position:absolute;top:0;left:0;z-index:2;cursor:crosshair; } /* user drawings/text */
  
  .pe-opts { display:flex;flex-wrap:wrap;gap:6px;align-items:center;padding:4px 10px;background:#eee;border-top:1px solid #ccc;font-size:12px;color:#333;flex-shrink:0;min-height:36px; }
  .pe-opts label { display:flex;align-items:center;gap:4px;color:#333; }
  .pe-opts input[type=color] { width:24px;height:24px;border:none;padding:0;cursor:pointer;background:none; }
  .pe-opts input[type=range] { width:80px;cursor:pointer; }
  .pe-opts button { display:inline-flex;align-items:center;justify-content:center;padding:2px 8px;border-radius:3px;border:1px solid #ccc;color:#333;cursor:pointer;font-size:12px;min-height:30px; }
  .pe-opts button:hover { background-color: var(--primary-accent-color, #0a74c9); color:#fff;}
  .pe-opts input[type=file] { display:none; }

  .pe-text-input { position:absolute;z-index:200;font-size:18px;border:2px dashed #0af;background:rgba(0,0,0,.7);color:#fff;padding:2px 8px;min-width:100px;border-radius:3px;outline:none; }
  .pe-handle { position:absolute;width:10px;height:10px;background:#fff;border:1px solid #333;border-radius:2px;z-index:10; }
  
  .pe-loading { position:absolute;inset:0;background:rgba(0,0,0,0.5);color:#fff;display:flex;align-items:center;justify-content:center;font-size:18px;z-index:999; }
`;
    }
  });

  // node_modules/lupine.components/src/component-pool/p-editor/p-editor.ts
  var PEditor;
  var init_p_editor = __esm({
    "node_modules/lupine.components/src/component-pool/p-editor/p-editor.ts"() {
      init_p_editor_types();
      init_p_editor_utils();
      init_p_editor_styles();
      init_i_editor_geometry();
      init_i_editor_drawing();
      init_svg_icons();
      PEditor = class {
        container;
        wrap;
        canvasBg;
        // For PDF.js rendering
        canvasFg;
        // For User interactions
        ctxBg;
        ctxFg;
        sidebar;
        optsWrap;
        loadingOverlay;
        // Options
        tool = "pan";
        color = "#ff0000";
        _fontFamily = "Arial, sans-serif";
        _fontSize = 24;
        zoom = 1;
        // PDF State
        pdfBytes;
        pdfDoc;
        // PDFLib.PDFDocument
        pdfJsDoc;
        // PDF.js Proxy
        numPages = 0;
        cp = 1;
        // current page (1-indexed)
        // Annotation State per page
        texts = [];
        stickers = [];
        shapes = [];
        activeId = null;
        dragState = null;
        // Draw state
        _penMode = "pencil";
        _penSize = 4;
        _arrowType = "standard";
        activeShape = null;
        textInput = null;
        textCommitFn = null;
        textCancelFn = null;
        constructor(container, options3) {
          this.container = container;
          this._injectStyles();
          this.container.innerHTML = `<div class="pe-container">
      <div class="pe-toolbar"></div>
      <div class="pe-opts"></div>
      <div class="pe-main">
        <div class="pe-sidebar"></div>
        <div class="pe-canvas-area" style="cursor: grab;">
          <div class="pe-canvas-wrap">
            <canvas class="pe-canvas-bg"></canvas>
            <canvas class="pe-canvas-fg"></canvas>
          </div>
        </div>
      </div>
      <div class="pe-loading" style="display:none;">Loading PDF Framework...</div>
    </div>`;
          this.wrap = this.container.querySelector(".pe-canvas-wrap");
          this.canvasBg = this.container.querySelector(".pe-canvas-bg");
          this.canvasFg = this.container.querySelector(".pe-canvas-fg");
          this.sidebar = this.container.querySelector(".pe-sidebar");
          this.optsWrap = this.container.querySelector(".pe-opts");
          this.loadingOverlay = this.container.querySelector(".pe-loading");
          this.ctxBg = this.canvasBg.getContext("2d");
          this.ctxFg = this.canvasFg.getContext("2d");
          this._buildToolbar();
          this._attachEvents();
          if ((options3 == null ? void 0 : options3.pdfUrl) || (options3 == null ? void 0 : options3.pdfArrayBuffer)) {
            this._init(options3);
          } else {
            this._init();
          }
        }
        _injectStyles() {
          if (!document.getElementById("p-editor-css")) {
            loadSvgIconStyles();
            const s = document.createElement("style");
            s.id = "p-editor-css";
            s.textContent = PEDITOR_STYLES;
            document.head.appendChild(s);
          }
        }
        async _init(options3) {
          this.loadingOverlay.style.display = "flex";
          try {
            await loadPdfScripts();
            const { PDFDocument, rgb, StandardFonts } = window.PDFLib;
            const pdfjsLib = window.pdfjsLib;
            if (options3 == null ? void 0 : options3.pdfArrayBuffer) {
              this.pdfBytes = new Uint8Array(options3.pdfArrayBuffer);
            } else if (options3 == null ? void 0 : options3.pdfUrl) {
              const res = await fetch(options3.pdfUrl);
              const arrayBuffer = await res.arrayBuffer();
              this.pdfBytes = new Uint8Array(arrayBuffer);
            } else {
              const doc = await PDFDocument.create();
              const page = doc.addPage([595.28, 841.89]);
              const font = await doc.embedFont(StandardFonts.HelveticaBold);
              const fontNorm = await doc.embedFont(StandardFonts.Helvetica);
              page.drawText("p-editor", {
                x: 230,
                y: 600,
                size: 40,
                font,
                color: rgb(0.2, 0.2, 0.2)
              });
              page.drawText("Powered by Lupine.js", {
                x: 250,
                y: 560,
                size: 14,
                font: fontNorm,
                color: rgb(0.5, 0.5, 0.5)
              });
              this.pdfBytes = await doc.save();
            }
            if (this.pdfBytes) {
              this.pdfDoc = await PDFDocument.load(this.pdfBytes);
              const loadingTask = pdfjsLib.getDocument({ data: this.pdfBytes });
              this.pdfJsDoc = await loadingTask.promise;
              this.numPages = this.pdfJsDoc.numPages;
              this.cp = 1;
              await this._renderSidebar();
              await this._renderPage();
            }
            this.loadingOverlay.style.display = "none";
            this._setTool("pan");
          } catch (e) {
            console.error(e);
            this.loadingOverlay.textContent = "Failed to load PDF.";
          }
        }
        //  Toolbar 
        _btn(id, title, iconStr, fn) {
          const btn = document.createElement("button");
          btn.className = `pe-btn ${LJ_SVG_ICON_CLASS} ${LJ_SVG_ICON_CLASS}_${SvgIconNames[iconStr]}`;
          btn.title = title;
          btn.dataset.id = id;
          btn.onclick = () => {
            this._setTool(id);
            if (["upload", "download", "zoomIn", "zoomOut"].includes(id)) {
              fn();
            }
          };
          return btn;
        }
        _grp(...btns) {
          const div = document.createElement("div");
          div.className = "pe-grp";
          btns.forEach((b) => div.appendChild(b));
          return div;
        }
        _buildToolbar() {
          const tb = this.container.querySelector(".pe-toolbar");
          tb.innerHTML = "";
          tb.appendChild(
            this._grp(
              this._btn("upload", "Upload PDF", "upload", () => this._handleUpload()),
              this._btn("download", "Download PDF", "download", () => this._handleDownload())
            )
          );
          tb.appendChild(
            this._grp(
              this._btn("pan", "Pan", "pan", () => {
              }),
              this._btn("select", "Select", "select", () => {
              }),
              this._btn("zoomIn", "Zoom In", "zoomIn", () => this._zoom(1.2)),
              this._btn("zoomOut", "Zoom Out", "zoomOut", () => this._zoom(1 / 1.2))
            )
          );
          tb.appendChild(
            this._grp(
              this._btn("pencil", "Draw", "draw", () => {
              }),
              this._btn("text", "Text / Bubble", "text", () => {
              }),
              this._btn("sticker", "Sticker", "sticker", () => {
              })
            )
          );
          this._setTool("pan");
        }
        _setTool(t) {
          if (!["upload", "download", "zoomIn", "zoomOut"].includes(t)) {
            this.tool = t;
            this.container.querySelectorAll(".pe-toolbar .pe-btn").forEach((b) => {
              if (b.dataset.id === t) b.classList.add("active");
              else b.classList.remove("active");
            });
            const area = this.container.querySelector(".pe-canvas-area");
            if (t === "pan") area.style.cursor = "grab";
            else if (t === "select") area.style.cursor = "default";
            else area.style.cursor = "crosshair";
            this.activeId = null;
            this._updateOpts();
            this._drawFg();
          }
        }
        _updateOpts() {
          const w = this.optsWrap;
          w.innerHTML = "";
          if (!this.pdfBytes && this.loadingOverlay.style.display === "none") {
            w.innerHTML = "<span>Please upload a PDF to start editing.</span>";
            return;
          }
          if (!this.pdfBytes) return;
          const t = this.tool;
          const txt = (s) => {
            const el = document.createElement("span");
            el.textContent = s;
            w.appendChild(el);
          };
          const btn = (l, fn) => {
            const b = document.createElement("button");
            b.textContent = l;
            b.onclick = fn;
            w.appendChild(b);
          };
          const clr = (l) => {
            const lbl = document.createElement("label");
            lbl.textContent = l;
            const inp = document.createElement("input");
            inp.type = "color";
            inp.value = this.color;
            inp.oninput = () => {
              this.color = inp.value;
              this._applyColorToActive();
              this._drawFg();
            };
            lbl.appendChild(inp);
            w.appendChild(lbl);
          };
          txt(`Page ${this.cp} / ${this.numPages}`);
          btn("Prev", () => this._gotoPage(this.cp - 1));
          btn("Next", () => this._gotoPage(this.cp + 1));
          btn("Del Current Page", () => this._deletePage(this.cp - 1));
          const activeTxt = this.activeId ? this.texts.find((tx) => tx.id === this.activeId) : null;
          const activeShp = this.activeId ? this.shapes.find((sx) => sx.id === this.activeId) : null;
          if (t === "text" || activeTxt) {
            clr("Color");
            const sz = document.createElement("input");
            sz.type = "range";
            sz.min = "10";
            sz.max = "100";
            if (activeTxt) this._fontSize = activeTxt.fontSize;
            sz.value = this._fontSize + "";
            sz.oninput = () => {
              this._fontSize = +sz.value;
              this._applyTextSizeToActive();
              this._drawFg();
            };
            w.appendChild(sz);
            btn("+Bubble", () => {
              if (this.activeId) this._toggleBubble(this.activeId);
            });
          } else if (t === "pencil" || activeShp) {
            clr("Color");
            const sz = document.createElement("input");
            sz.type = "range";
            sz.min = "1";
            sz.max = "50";
            let currentSize = this._penSize;
            let currentMode = this._penMode;
            let currentArrow = this._arrowType;
            if (activeShp) {
              currentSize = activeShp.strokeWidth;
              currentMode = activeShp.type;
              currentArrow = activeShp.arrowType || "standard";
              this.color = activeShp.color;
            }
            sz.value = currentSize + "";
            sz.oninput = () => {
              this._penSize = +sz.value;
              if (activeShp) activeShp.strokeWidth = this._penSize;
              this._drawFg();
            };
            w.appendChild(sz);
            const sel = document.createElement("select");
            ["pencil", "line", "circle", "rect", "triangle", "star", "arrow"].forEach((m) => {
              const o = document.createElement("option");
              o.value = m;
              o.textContent = m;
              if (m === currentMode) o.selected = true;
              sel.appendChild(o);
            });
            sel.onchange = () => {
              this._penMode = sel.value;
              if (activeShp) activeShp.type = this._penMode;
              this._updateOpts();
              this._drawFg();
            };
            w.appendChild(sel);
            if (currentMode === "arrow" || activeShp === null && this._penMode === "arrow") {
              const asel = document.createElement("select");
              ["standard", "double", "thick", "fishtail", "arc"].forEach((m) => {
                const o = document.createElement("option");
                o.value = m;
                o.textContent = m;
                if (m === currentArrow) o.selected = true;
                asel.appendChild(o);
              });
              asel.onchange = () => {
                this._arrowType = asel.value;
                if (activeShp) activeShp.arrowType = this._arrowType;
                this._drawFg();
              };
              w.appendChild(asel);
            }
          } else if (t === "sticker") {
            const inp = document.createElement("input");
            inp.type = "file";
            inp.accept = "image/*";
            inp.onchange = (e) => {
              if (e.target.files[0]) {
                const u = URL.createObjectURL(e.target.files[0]);
                const img = new Image();
                img.onload = () => {
                  let nw = img.width;
                  let nh = img.height;
                  const maxDim = 200;
                  if (nw > maxDim || nh > maxDim) {
                    const ratio = Math.min(maxDim / nw, maxDim / nh);
                    nw *= ratio;
                    nh *= ratio;
                  }
                  const newSticker = {
                    id: "s_" + Date.now(),
                    pageIndex: this.cp,
                    img,
                    x: 50 / this.zoom,
                    y: 50 / this.zoom,
                    w: nw / this.zoom,
                    h: nh / this.zoom,
                    rotation: 0
                  };
                  this.stickers.push(newSticker);
                  this.activeId = newSticker.id;
                  this._setTool("select");
                  this._drawFg();
                };
                img.src = u;
              }
            };
            const b = document.createElement("button");
            b.textContent = "Upload Sticker";
            b.onclick = () => inp.click();
            w.appendChild(b);
            w.appendChild(inp);
          }
        }
        _applyColorToActive() {
          if (!this.activeId) return;
          const txt = this.texts.find((x) => x.id === this.activeId && x.pageIndex === this.cp);
          if (txt) txt.color = this.color;
          const shp = this.shapes.find((x) => x.id === this.activeId && x.pageIndex === this.cp);
          if (shp) shp.color = this.color;
        }
        _applyTextSizeToActive() {
          if (!this.activeId) return;
          const txt = this.texts.find((x) => x.id === this.activeId && x.pageIndex === this.cp);
          if (txt) txt.fontSize = this._fontSize;
        }
        _toggleBubble(id) {
          const txt = this.texts.find((x) => x.id === id && x.pageIndex === this.cp);
          if (txt) {
            txt.tailActive = !txt.tailActive;
            this._drawFg();
          }
        }
        //  PDF Management 
        async _handleUpload() {
          const inp = document.createElement("input");
          inp.type = "file";
          inp.accept = "application/pdf";
          inp.onchange = async (e) => {
            if (e.target.files[0]) {
              const u = URL.createObjectURL(e.target.files[0]);
              const res = await fetch(u);
              const ab = await res.arrayBuffer();
              if (!this.pdfBytes) {
                await this._init({ pdfArrayBuffer: ab });
              } else {
                this.loadingOverlay.style.display = "flex";
                try {
                  const { PDFDocument } = window.PDFLib;
                  const newPdf = await PDFDocument.load(ab);
                  const copiedPages = await this.pdfDoc.copyPages(newPdf, newPdf.getPageIndices());
                  for (let i = 0; i < copiedPages.length; i++) {
                    this.pdfDoc.insertPage(this.cp + i, copiedPages[i]);
                  }
                  this.pdfBytes = await this.pdfDoc.save();
                  const pdfjsLib = window.pdfjsLib;
                  this.pdfJsDoc = await pdfjsLib.getDocument({ data: this.pdfBytes }).promise;
                  this.numPages = this.pdfJsDoc.numPages;
                  await this._renderSidebar();
                  await this._renderPage();
                } catch (err) {
                  console.error(err);
                }
                this.loadingOverlay.style.display = "none";
              }
            }
          };
          inp.click();
        }
        async _handleDownload() {
          if (!this.pdfBytes) return;
          this.loadingOverlay.style.display = "flex";
          this.loadingOverlay.textContent = "Baking and saving...";
          try {
            this._commitAnnotationsToPdfDoc();
            const finalBytes = await this.pdfDoc.save();
            const blob = new Blob([finalBytes], { type: "application/pdf" });
            const link2 = document.createElement("a");
            link2.href = URL.createObjectURL(blob);
            link2.download = "edited.pdf";
            link2.click();
            this.pdfBytes = finalBytes;
          } catch (err) {
            console.error(err);
          }
          this.loadingOverlay.textContent = "Loading PDF Framework...";
          this.loadingOverlay.style.display = "none";
        }
        async _commitAnnotationsToPdfDoc() {
          const { rgb, degrees } = window.PDFLib;
          for (let pIdx = 1; pIdx <= this.numPages; pIdx++) {
            const page = this.pdfDoc.getPage(pIdx - 1);
            const { width, height } = page.getSize();
            const pgTexts = this.texts.filter((t) => t.pageIndex === pIdx);
            for (const t of pgTexts) {
              const hex = t.color.replace("#", "");
              const r = parseInt(hex.substring(0, 2), 16) / 255;
              const g = parseInt(hex.substring(2, 4), 16) / 255;
              const b = parseInt(hex.substring(4, 6), 16) / 255;
              if (t.tailActive) {
                page.drawRectangle({
                  x: t.x - 10,
                  y: height - t.y - t.fontSize,
                  width: t.fontSize * t.text.length * 0.6 + 20,
                  height: t.fontSize + 10,
                  color: rgb(0.9, 0.9, 0.9),
                  opacity: 0.8
                });
              }
              page.drawText(t.text, {
                x: t.x,
                y: height - t.y,
                size: t.fontSize,
                color: rgb(r, g, b),
                rotate: degrees(t.rotation * 180 / Math.PI)
              });
            }
            const pgSticks = this.stickers.filter((s) => s.pageIndex === pIdx);
            for (const s of pgSticks) {
              const c = document.createElement("canvas");
              c.width = s.img.width;
              c.height = s.img.height;
              c.getContext("2d").drawImage(s.img, 0, 0);
              const dataUrl = c.toDataURL("image/png");
              const imgBytes = Uint8Array.from(atob(dataUrl.split(",")[1]), (c2) => c2.charCodeAt(0));
              const embedded = await this.pdfDoc.embedPng(imgBytes);
              page.drawImage(embedded, {
                x: s.x - s.w / 2,
                y: height - (s.y + s.h / 2),
                width: s.w,
                height: s.h,
                rotate: degrees(-s.rotation * 180 / Math.PI)
                // pdf-lib rotation inverse
              });
            }
            const pgShapes = this.shapes.filter((s) => s.pageIndex === pIdx);
            for (const s of pgShapes) {
              const hex = s.color.replace("#", "");
              const r = parseInt(hex.substring(0, 2), 16) / 255;
              const g = parseInt(hex.substring(2, 4), 16) / 255;
              const b = parseInt(hex.substring(4, 6), 16) / 255;
              const color = rgb(r, g, b);
              if (s.type === "pencil" && s.points && s.points.length > 0) {
                let path = `M ${s.points[0].x} ${height - s.points[0].y}`;
                for (let i = 1; i < s.points.length; i++) {
                  path += ` L ${s.points[i].x} ${height - s.points[i].y}`;
                }
                page.drawSvgPath(path, { borderColor: color, borderWidth: s.strokeWidth });
              } else if (s.type === "line") {
                page.drawLine({
                  start: { x: s.x, y: height - s.y },
                  end: { x: s.w, y: height - s.h },
                  color,
                  thickness: s.strokeWidth
                });
              } else if (s.type === "rect") {
                const rx = Math.min(s.x, s.w);
                const ry = Math.min(s.y, s.h);
                const rw = Math.abs(s.w - s.x);
                const rh = Math.abs(s.h - s.y);
                page.drawRectangle({
                  x: rx,
                  y: height - ry - rh,
                  width: rw,
                  height: rh,
                  borderColor: color,
                  borderWidth: s.strokeWidth
                });
              } else if (s.type === "circle") {
                const radius = Math.hypot(s.w - s.x, s.h - s.y);
                page.drawEllipse({
                  x: s.x,
                  y: height - s.y,
                  xScale: radius,
                  yScale: radius,
                  borderColor: color,
                  borderWidth: s.strokeWidth
                });
              } else if (s.type === "triangle") {
                const path = `M ${s.x + (s.w - s.x) / 2} ${height - s.y} L ${s.w} ${height - s.h} L ${s.x} ${height - s.h} Z`;
                page.drawSvgPath(path, { borderColor: color, borderWidth: s.strokeWidth });
              } else if (s.type === "star") {
                const spikes = 5;
                const outerRadius = Math.hypot(s.w - s.x, s.h - s.y);
                const innerRadius = outerRadius / 2.5;
                let rot = Math.PI / 2 * 3;
                const step = Math.PI / spikes;
                let path = "";
                for (let i = 0; i < spikes; i++) {
                  const xOuter = s.x + Math.cos(rot) * outerRadius;
                  const yOuter = height - (s.y + Math.sin(rot) * outerRadius);
                  path += (i === 0 ? "M " : " L ") + `${xOuter} ${yOuter}`;
                  rot += step;
                  const xInner = s.x + Math.cos(rot) * innerRadius;
                  const yInner = height - (s.y + Math.sin(rot) * innerRadius);
                  path += ` L ${xInner} ${yInner}`;
                  rot += step;
                }
                path += " Z";
                page.drawSvgPath(path, { borderColor: color, borderWidth: s.strokeWidth });
              } else if (s.type === "arrow") {
                const dist = Math.hypot(s.w - s.x, s.h - s.y);
                if (dist >= 2) {
                  const arrowAngle = Math.atan2(s.h - s.y, s.w - s.x);
                  const headlen = Math.max(10, dist * 0.2);
                  const span = Math.PI / 6;
                  const ex = s.w;
                  const ey = height - s.h;
                  page.drawLine({
                    start: { x: s.x, y: height - s.y },
                    end: { x: ex, y: ey },
                    color,
                    thickness: s.strokeWidth
                  });
                  const h1x = ex - headlen * Math.cos(arrowAngle - span);
                  const h1y = ey + headlen * Math.sin(arrowAngle - span);
                  page.drawLine({ start: { x: ex, y: ey }, end: { x: h1x, y: h1y }, color, thickness: s.strokeWidth });
                  const h2x = ex - headlen * Math.cos(arrowAngle + span);
                  const h2y = ey + headlen * Math.sin(arrowAngle + span);
                  page.drawLine({ start: { x: ex, y: ey }, end: { x: h2x, y: h2y }, color, thickness: s.strokeWidth });
                  if (s.arrowType === "double") {
                    const b1x = s.x + headlen * Math.cos(arrowAngle - span);
                    const b1y = height - s.y - headlen * Math.sin(arrowAngle - span);
                    page.drawLine({
                      start: { x: s.x, y: height - s.y },
                      end: { x: b1x, y: b1y },
                      color,
                      thickness: s.strokeWidth
                    });
                    const b2x = s.x + headlen * Math.cos(arrowAngle + span);
                    const b2y = height - s.y - headlen * Math.sin(arrowAngle + span);
                    page.drawLine({
                      start: { x: s.x, y: height - s.y },
                      end: { x: b2x, y: b2y },
                      color,
                      thickness: s.strokeWidth
                    });
                  }
                }
              }
            }
          }
        }
        async _deletePage(idx0) {
          if (this.numPages <= 1) return;
          this.pdfDoc.removePage(idx0);
          this.pdfBytes = await this.pdfDoc.save();
          const pdfjsLib = window.pdfjsLib;
          this.pdfJsDoc = await pdfjsLib.getDocument({ data: this.pdfBytes }).promise;
          this.numPages = this.pdfJsDoc.numPages;
          this.texts = this.texts.filter((t) => t.pageIndex !== idx0 + 1);
          this.stickers = this.stickers.filter((s) => s.pageIndex !== idx0 + 1);
          this.shapes = this.shapes.filter((s) => s.pageIndex !== idx0 + 1);
          this.texts.forEach((t) => {
            if (t.pageIndex > idx0 + 1) t.pageIndex--;
          });
          this.stickers.forEach((s) => {
            if (s.pageIndex > idx0 + 1) s.pageIndex--;
          });
          this.shapes.forEach((s) => {
            if (s.pageIndex && s.pageIndex > idx0 + 1) s.pageIndex--;
          });
          if (this.cp > this.numPages) this.cp = this.numPages;
          await this._renderSidebar();
          await this._renderPage();
        }
        async _movePage(from0, to0) {
          if (from0 === to0) return;
          const [page] = await this.pdfDoc.copyPages(this.pdfDoc, [from0]);
          this.pdfDoc.removePage(from0);
          let target = to0;
          if (from0 < to0) target = to0 - 1;
          this.pdfDoc.insertPage(target, page);
          this.pdfBytes = await this.pdfDoc.save();
          const pdfjsLib = window.pdfjsLib;
          this.pdfJsDoc = await pdfjsLib.getDocument({ data: this.pdfBytes }).promise;
          const shift = (arr) => {
            arr.forEach((a) => {
              const p = a.pageIndex - 1;
              if (p === from0) a.pageIndex = target + 1;
              else if (from0 < to0 && p > from0 && p <= to0) a.pageIndex = p;
              else if (from0 > to0 && p >= to0 && p < from0) a.pageIndex = p + 2;
            });
          };
          shift(this.texts);
          shift(this.stickers);
          shift(this.shapes);
          await this._renderSidebar();
          await this._renderPage();
        }
        async _insertBlankPage(index) {
          if (!this.pdfBytes) return;
          this.loadingOverlay.style.display = "flex";
          try {
            this.pdfDoc.insertPage(index, [595.28, 841.89]);
            this.pdfBytes = await this.pdfDoc.save();
            const pdfjsLib = window.pdfjsLib;
            this.pdfJsDoc = await pdfjsLib.getDocument({ data: this.pdfBytes }).promise;
            this.numPages = this.pdfJsDoc.numPages;
            const shift = (arr) => {
              arr.forEach((a) => {
                if (a.pageIndex > index) a.pageIndex++;
              });
            };
            shift(this.texts);
            shift(this.stickers);
            shift(this.shapes);
            if (this.cp > index) this.cp++;
            await this._renderSidebar();
            await this._renderPage();
          } catch (err) {
            console.error(err);
          }
          this.loadingOverlay.style.display = "none";
        }
        async _gotoPage(p) {
          if (p >= 1 && p <= this.numPages) {
            this.cp = p;
            await this._renderSidebar();
            await this._renderPage();
          }
        }
        async _zoom(f) {
          this.zoom *= f;
          await this._renderPage();
        }
        //  Rendering 
        async _renderSidebar() {
          this.sidebar.innerHTML = "";
          for (let i = 1; i <= this.numPages; i++) {
            const wrap2 = document.createElement("div");
            wrap2.className = "pe-thumb-wrap" + (this.cp === i ? " active" : "");
            wrap2.draggable = true;
            wrap2.ondragstart = (e) => {
              e.dataTransfer.setData("text/plain", (i - 1).toString());
            };
            wrap2.ondragover = (e) => {
              e.preventDefault();
              wrap2.classList.add("drag-over");
            };
            wrap2.ondragleave = (e) => {
              wrap2.classList.remove("drag-over");
            };
            wrap2.ondrop = (e) => {
              wrap2.classList.remove("drag-over");
              const from = parseInt(e.dataTransfer.getData("text/plain"));
              this._movePage(from, i - 1);
            };
            wrap2.onclick = () => this._gotoPage(i);
            const num = document.createElement("div");
            num.className = "pe-thumb-num";
            num.textContent = i + "";
            const del = document.createElement("div");
            del.className = "pe-thumb-del";
            del.innerHTML = "\xD7";
            del.onclick = (e) => {
              e.stopPropagation();
              this._deletePage(i - 1);
            };
            const addTop = document.createElement("div");
            addTop.className = "pe-thumb-add-top";
            addTop.textContent = "+";
            addTop.onclick = (e) => {
              e.stopPropagation();
              this._insertBlankPage(i - 1);
            };
            const addBottom = document.createElement("div");
            addBottom.className = "pe-thumb-add-bottom";
            addBottom.textContent = "+";
            addBottom.onclick = (e) => {
              e.stopPropagation();
              this._insertBlankPage(i);
            };
            const cv = document.createElement("canvas");
            cv.className = "pe-thumb-canvas";
            wrap2.appendChild(cv);
            wrap2.appendChild(num);
            wrap2.appendChild(del);
            wrap2.appendChild(addTop);
            wrap2.appendChild(addBottom);
            this.sidebar.appendChild(wrap2);
            const page = await this.pdfJsDoc.getPage(i);
            const viewport = page.getViewport({ scale: 180 / page.getViewport({ scale: 1 }).width });
            cv.width = viewport.width;
            cv.height = viewport.height;
            await page.render({ canvasContext: cv.getContext("2d"), viewport }).promise;
          }
        }
        async _renderPage() {
          if (!this.pdfJsDoc) return;
          this._updateOpts();
          const page = await this.pdfJsDoc.getPage(this.cp);
          const viewport = page.getViewport({ scale: this.zoom });
          this.canvasBg.width = viewport.width;
          this.canvasBg.height = viewport.height;
          this.canvasFg.width = viewport.width;
          this.canvasFg.height = viewport.height;
          this.wrap.style.width = viewport.width + "px";
          this.wrap.style.height = viewport.height + "px";
          await page.render({ canvasContext: this.ctxBg, viewport }).promise;
          this._drawFg();
        }
        _textFontFn = (t) => `${t.italic ? "italic " : ""}${t.bold ? "bold " : ""}${t.fontSize * this.zoom}px ${t.fontFamily}`;
        _drawFg() {
          this.ctxFg.clearRect(0, 0, this.canvasFg.width, this.canvasFg.height);
          const pgTexts = this.texts.filter((t) => t.pageIndex === this.cp);
          for (const t of pgTexts) {
            this.ctxFg.save();
            this.ctxFg.translate(t.x * this.zoom, t.y * this.zoom);
            this.ctxFg.rotate(t.rotation);
            if (t.tailActive) {
              this.ctxFg.fillStyle = "rgba(230,230,230,0.85)";
              this.ctxFg.strokeStyle = "#aaa";
              this.ctxFg.lineWidth = 2;
              this.ctxFg.beginPath();
              this.ctxFg.arc(0, -t.fontSize / 2, t.fontSize * t.text.length * 0.4, 0, Math.PI * 2);
              this.ctxFg.fill();
              this.ctxFg.stroke();
            }
            this.ctxFg.font = this._textFontFn(t);
            this.ctxFg.fillStyle = t.color;
            this.ctxFg.textAlign = "center";
            this.ctxFg.textBaseline = "middle";
            this.ctxFg.fillText(t.text, 0, 0);
            this.ctxFg.restore();
          }
          const pgStickers = this.stickers.filter((s) => s.pageIndex === this.cp);
          for (const s of pgStickers) {
            this.ctxFg.save();
            this.ctxFg.translate(s.x * this.zoom, s.y * this.zoom);
            this.ctxFg.rotate(s.rotation);
            this.ctxFg.drawImage(s.img, -s.w * this.zoom / 2, -s.h * this.zoom / 2, s.w * this.zoom, s.h * this.zoom);
            this.ctxFg.restore();
          }
          const drawShp = (sh) => {
            this.ctxFg.save();
            this.ctxFg.strokeStyle = sh.color;
            this.ctxFg.lineWidth = sh.strokeWidth * this.zoom;
            this.ctxFg.lineCap = "round";
            this.ctxFg.lineJoin = "round";
            if (sh.type === "pencil" && sh.points && sh.points.length > 0) {
              this.ctxFg.beginPath();
              this.ctxFg.moveTo(sh.points[0].x * this.zoom, sh.points[0].y * this.zoom);
              for (let i = 1; i < sh.points.length; i++) {
                this.ctxFg.lineTo(sh.points[i].x * this.zoom, sh.points[i].y * this.zoom);
              }
              this.ctxFg.stroke();
            } else if (sh.type !== "pencil") {
              drawShapePath(
                this.ctxFg,
                sh.type,
                sh.arrowType || "standard",
                sh.color,
                sh.x * this.zoom,
                sh.y * this.zoom,
                sh.w * this.zoom,
                sh.h * this.zoom
              );
            }
            this.ctxFg.restore();
          };
          const pgShapes = this.shapes.filter((s) => s.pageIndex === this.cp);
          pgShapes.forEach(drawShp);
          if (this.activeShape) drawShp(this.activeShape);
          if (this.activeId && this.tool === "select") {
            const txt = pgTexts.find((x) => x.id === this.activeId);
            if (txt) {
              const h = getTextHandles(txt, this.zoom, this.ctxFg, this._textFontFn);
              this._drawHandles(h);
            }
            const st = pgStickers.find((x) => x.id === this.activeId);
            if (st) {
              const h = getStickerHandles(st, this.zoom);
              this._drawHandles(h);
            }
            const sh = pgShapes.find((x) => x.id === this.activeId);
            if (sh) {
              const h = getShapeHandles(sh, this.zoom);
              this._drawHandles(h);
            }
          }
        }
        _drawHandles(h) {
          const s = HANDLE_SIZE2;
          if (h.rot) {
            this.ctxFg.beginPath();
            this.ctxFg.arc(h.rot.x * this.zoom, h.rot.y * this.zoom, 6, 0, Math.PI * 2);
            this.ctxFg.fillStyle = "#0af";
            this.ctxFg.fill();
            this.ctxFg.strokeStyle = "#fff";
            this.ctxFg.stroke();
          }
          if (h.resize) {
            this.ctxFg.fillStyle = "#fff";
            this.ctxFg.strokeStyle = "#333";
            this.ctxFg.lineWidth = 1;
            this.ctxFg.fillRect(h.resize.x * this.zoom - s / 2, h.resize.y * this.zoom - s / 2, s, s);
            this.ctxFg.strokeRect(h.resize.x * this.zoom - s / 2, h.resize.y * this.zoom - s / 2, s, s);
          }
          if (h.del) {
            drawDeleteHandle(this.ctxFg, h.del.x * this.zoom, h.del.y * this.zoom, 10);
          }
        }
        //  Events 
        _attachEvents() {
          const cw = this.canvasFg;
          let isDragging = false;
          let startPanX = 0, startPanY = 0;
          cw.onmousedown = (e) => {
            if (this.textInput && this.textCommitFn) {
              this.textCommitFn();
              return;
            }
            const rect = cw.getBoundingClientRect();
            const x = (e.clientX - rect.left) / this.zoom;
            const y = (e.clientY - rect.top) / this.zoom;
            if (this.tool === "pan") {
              const area = this.container.querySelector(".pe-canvas-area");
              isDragging = true;
              startPanX = e.clientX + area.scrollLeft;
              startPanY = e.clientY + area.scrollTop;
              area.style.cursor = "grabbing";
            } else if (this.tool === "select") {
              const pgTexts = this.texts.filter((t) => t.pageIndex === this.cp);
              const pgStickers = this.stickers.filter((s) => s.pageIndex === this.cp);
              const pgShapes = this.shapes.filter((s) => s.pageIndex === this.cp);
              let hit = null;
              if (this.activeId) {
                const t = pgTexts.find((x2) => x2.id === this.activeId);
                if (t) {
                  const h = getTextHandles(t, this.zoom, this.ctxFg, this._textFontFn);
                  if (Math.abs(x - h.del.x) * this.zoom < HANDLE_SIZE2 && Math.abs(y - h.del.y) * this.zoom < HANDLE_SIZE2) {
                    this.texts = this.texts.filter((tx) => tx.id !== this.activeId);
                    this.activeId = null;
                    this._drawFg();
                    return;
                  }
                  if (Math.abs(x - h.rot.x) * this.zoom < HANDLE_SIZE2 && Math.abs(y - h.rot.y) * this.zoom < HANDLE_SIZE2) {
                    this.dragState = { type: "rotT", obj: t, cx: t.x, cy: t.y };
                    return;
                  }
                  if (Math.abs(x - h.resize.x) * this.zoom < HANDLE_SIZE2 && Math.abs(y - h.resize.y) * this.zoom < HANDLE_SIZE2) {
                    this.dragState = { type: "resizeT", obj: t, startX: x, startY: y, origFontSize: t.fontSize };
                    return;
                  }
                }
                const s = pgStickers.find((x2) => x2.id === this.activeId);
                if (s) {
                  const h = getStickerHandles(s, this.zoom);
                  if (Math.abs(x - h.del.x) * this.zoom < HANDLE_SIZE2 && Math.abs(y - h.del.y) * this.zoom < HANDLE_SIZE2) {
                    this.stickers = this.stickers.filter((sx) => sx.id !== this.activeId);
                    this.activeId = null;
                    this._drawFg();
                    return;
                  }
                  if (Math.abs(x - h.rot.x) * this.zoom < HANDLE_SIZE2 && Math.abs(y - h.rot.y) * this.zoom < HANDLE_SIZE2) {
                    this.dragState = { type: "rotS", obj: s, cx: s.x, cy: s.y };
                    return;
                  }
                  if (Math.abs(x - h.resize.x) * this.zoom < HANDLE_SIZE2 && Math.abs(y - h.resize.y) * this.zoom < HANDLE_SIZE2) {
                    this.dragState = { type: "resizeS", obj: s, startX: x, startY: y, origW: s.w, origH: s.h };
                    return;
                  }
                }
                const shp = pgShapes.find((x2) => x2.id === this.activeId);
                if (shp) {
                  const h = getShapeHandles(shp, this.zoom);
                  if (Math.abs(x - h.del.x) * this.zoom < HANDLE_SIZE2 && Math.abs(y - h.del.y) * this.zoom < HANDLE_SIZE2) {
                    this.shapes = this.shapes.filter((sx) => sx.id !== this.activeId);
                    this.activeId = null;
                    this._drawFg();
                    return;
                  }
                  if (Math.abs(x - h.rot.x) * this.zoom < HANDLE_SIZE2 && Math.abs(y - h.rot.y) * this.zoom < HANDLE_SIZE2) {
                    const box = getShapeBoundingBox(shp);
                    this.dragState = { type: "rotShp", obj: shp, cx: box.cx, cy: box.cy };
                    return;
                  }
                  if (Math.abs(x - h.resize.x) * this.zoom < HANDLE_SIZE2 && Math.abs(y - h.resize.y) * this.zoom < HANDLE_SIZE2) {
                    const box = getShapeBoundingBox(shp);
                    this.dragState = {
                      type: "resizeShp",
                      obj: shp,
                      startX: x,
                      startY: y,
                      origX: shp.x,
                      origY: shp.y,
                      origW: shp.w,
                      origH: shp.h,
                      boxCX: box.cx,
                      boxCY: box.cy,
                      boxW: box.w,
                      boxH: box.h,
                      origPoints: shp.points ? shp.points.map((p) => ({ ...p })) : []
                    };
                    return;
                  }
                }
              }
              for (let i = pgTexts.length - 1; i >= 0; i--) {
                if (hitText({ x, y }, pgTexts[i], this.ctxFg, this._textFontFn)) {
                  hit = pgTexts[i];
                  break;
                }
              }
              if (!hit) {
                for (let i = pgStickers.length - 1; i >= 0; i--) {
                  if (hitSticker({ x, y }, pgStickers[i])) {
                    hit = pgStickers[i];
                    break;
                  }
                }
              }
              if (!hit) {
                for (let i = pgShapes.length - 1; i >= 0; i--) {
                  if (hitShape({ x, y }, pgShapes[i])) {
                    hit = pgShapes[i];
                    break;
                  }
                }
              }
              if (hit) {
                this.activeId = hit.id;
                this.dragState = { type: "move", obj: hit, ox: x - hit.x, oy: y - hit.y };
              } else {
                this.activeId = null;
              }
              this._updateOpts();
              this._drawFg();
            } else if (this.tool === "text") {
              const inp = document.createElement("textarea");
              inp.className = "pe-text-input";
              inp.style.position = "absolute";
              inp.style.left = x * this.zoom + "px";
              inp.style.top = y * this.zoom + "px";
              inp.style.color = this.color;
              inp.style.fontSize = this._fontSize * this.zoom + "px";
              inp.style.fontFamily = this._fontFamily;
              inp.style.fontWeight = "normal";
              inp.style.fontStyle = "normal";
              inp.style.background = "transparent";
              inp.style.border = "1px dashed #0af";
              inp.style.outline = "none";
              inp.style.resize = "none";
              inp.style.overflow = "hidden";
              inp.style.whiteSpace = "pre";
              inp.style.lineHeight = "1.2";
              inp.style.padding = "4px";
              inp.style.transform = "translate(-50%, -50%)";
              inp.style.pointerEvents = "auto";
              const adjustSize = () => {
                inp.style.width = "auto";
                inp.style.height = "auto";
                inp.style.width = Math.max(50, inp.scrollWidth + 10) + "px";
                inp.style.height = inp.scrollHeight + "px";
              };
              this.wrap.appendChild(inp);
              this.textInput = inp;
              this.textCommitFn = () => {
                if (!this.textInput) return;
                const val = inp.value.trim();
                if (val) {
                  this.texts.push({
                    id: inp.dataset.editid || "t_" + Date.now(),
                    pageIndex: this.cp,
                    text: val,
                    x,
                    y,
                    color: this.color,
                    fontSize: this._fontSize,
                    fontFamily: this._fontFamily,
                    bold: false,
                    italic: false,
                    rotation: 0,
                    tailActive: false
                  });
                  this.activeId = this.texts[this.texts.length - 1].id;
                  this._setTool("select");
                }
                if (this.textCancelFn) this.textCancelFn();
              };
              this.textCancelFn = () => {
                if (this.textInput) {
                  this.textInput.remove();
                  this.textInput = null;
                  this.textCommitFn = null;
                  this.textCancelFn = null;
                }
              };
              adjustSize();
              inp.oninput = () => adjustSize();
              inp.onmousedown = (ev) => ev.stopPropagation();
              inp.onkeydown = (e2) => {
                if (e2.key === "Enter" && !e2.shiftKey) {
                  e2.preventDefault();
                  this.textCommitFn();
                }
                if (e2.key === "Escape") {
                  this.textCancelFn();
                }
              };
              setTimeout(() => inp.focus(), 50);
            } else if (this.tool === "pencil") {
              this.activeShape = {
                id: "shp_" + Date.now(),
                pageIndex: this.cp,
                type: this._penMode,
                color: this.color,
                strokeWidth: this._penSize,
                points: [{ x, y }],
                rotation: 0,
                x,
                y,
                w: x,
                h: y,
                arrowType: this._arrowType
              };
            }
          };
          window.addEventListener("mousemove", (e) => {
            if (isDragging && this.tool === "pan") {
              const area = this.container.querySelector(".pe-canvas-area");
              area.scrollLeft = startPanX - e.clientX;
              area.scrollTop = startPanY - e.clientY;
            }
            if (this.dragState) {
              const rect = cw.getBoundingClientRect();
              const x = (e.clientX - rect.left) / this.zoom;
              const y = (e.clientY - rect.top) / this.zoom;
              const st = this.dragState;
              if (st.type === "move") {
                const newX = x - st.ox;
                const newY = y - st.oy;
                const dx = newX - st.obj.x;
                const dy = newY - st.obj.y;
                if (st.obj.type === "pencil" && st.obj.points) {
                  st.obj.points.forEach((p) => {
                    p.x += dx;
                    p.y += dy;
                  });
                } else if (st.obj.type && st.obj.type !== "pencil") {
                  st.obj.w += dx;
                  st.obj.h += dy;
                }
                st.obj.x = newX;
                st.obj.y = newY;
              } else if (st.type.startsWith("rot")) {
                st.obj.rotation = Math.atan2(y - st.cy, x - st.cx) + Math.PI / 2;
              } else if (st.type === "resizeT") {
                const dx = x - st.startX;
                st.obj.fontSize = Math.max(8, Math.round(st.origFontSize + dx));
              } else if (st.type === "resizeS") {
                const dx = x - st.startX;
                const dy = y - st.startY;
                let targetW = st.origW + dx;
                let targetH = st.origH + dy;
                if (e.shiftKey) {
                  const ratio = st.origW / st.origH;
                  if (Math.abs(targetW) / Math.abs(targetH) > ratio) {
                    targetW = targetH * ratio;
                  } else {
                    targetH = targetW / ratio;
                  }
                }
                st.obj.w = Math.max(20, targetW);
                st.obj.h = Math.max(20, targetH);
              } else if (st.type === "resizeShp") {
                const dx = x - st.startX;
                const dy = y - st.startY;
                const rot = st.obj.rotation || 0;
                const cos = Math.cos(-rot);
                const sin = Math.sin(-rot);
                const unDx = dx * cos - dy * sin;
                const unDy = dx * sin + dy * cos;
                const scaleX = Math.max(0.1, st.boxW + unDx * 2) / Math.max(0.1, st.boxW);
                const scaleY = Math.max(0.1, st.boxH + unDy * 2) / Math.max(0.1, st.boxH);
                if (st.obj.type === "pencil" && st.obj.points) {
                  st.obj.points.forEach((p, i) => {
                    p.x = st.boxCX + (st.origPoints[i].x - st.boxCX) * scaleX;
                    p.y = st.boxCY + (st.origPoints[i].y - st.boxCY) * scaleY;
                  });
                  st.startX = x;
                  st.startY = y;
                  st.boxW = Math.max(1, st.boxW + unDx * 2);
                  st.boxH = Math.max(1, st.boxH + unDy * 2);
                  st.origPoints = st.obj.points.map((p) => ({ ...p }));
                } else if (st.obj.type === "circle" || st.obj.type === "star") {
                  const radScale = Math.max(scaleX, scaleY);
                  st.obj.w = st.obj.x + (st.origW - st.obj.x) * radScale;
                  st.obj.h = st.obj.y + (st.origH - st.obj.y) * radScale;
                } else {
                  st.obj.x = st.boxCX + (st.origX - st.boxCX) * scaleX;
                  st.obj.y = st.boxCY + (st.origY - st.boxCY) * scaleY;
                  st.obj.w = st.boxCX + (st.origW - st.boxCX) * scaleX;
                  st.obj.h = st.boxCY + (st.origH - st.boxCY) * scaleY;
                }
              }
              this._drawFg();
            }
            if (this.activeShape) {
              const rect = cw.getBoundingClientRect();
              const x = (e.clientX - rect.left) / this.zoom;
              const y = (e.clientY - rect.top) / this.zoom;
              this.activeShape.w = x;
              this.activeShape.h = y;
              if (this.activeShape.type === "pencil" && this.activeShape.points) {
                this.activeShape.points.push({ x, y });
              }
              this._drawFg();
            }
          });
          window.addEventListener("mouseup", () => {
            if (isDragging) {
              isDragging = false;
              const area = this.container.querySelector(".pe-canvas-area");
              area.style.cursor = "grab";
            }
            this.dragState = null;
            if (this.activeShape) {
              this.shapes.push(this.activeShape);
              this.activeId = this.activeShape.id;
              this.activeShape = null;
              this._setTool("select");
            }
          });
          cw.addEventListener("dblclick", (e) => {
            if (this.tool !== "pan" && this.tool !== "select") return;
            const rect = cw.getBoundingClientRect();
            const x = (e.clientX - rect.left) / this.zoom;
            const y = (e.clientY - rect.top) / this.zoom;
            const pgTexts = this.texts.filter((t) => t.pageIndex === this.cp);
            for (let i = pgTexts.length - 1; i >= 0; i--) {
              const t = pgTexts[i];
              if (hitText({ x, y }, t, this.ctxFg, this._textFontFn)) {
                this.texts = this.texts.filter((tx) => tx.id !== t.id);
                this.activeId = null;
                this.color = t.color;
                this._fontSize = t.fontSize;
                this._setTool("text");
                const mdev = new MouseEvent("mousedown", {
                  clientX: e.clientX,
                  clientY: e.clientY,
                  bubbles: true
                });
                cw.dispatchEvent(mdev);
                setTimeout(() => {
                  if (this.textInput) {
                    this.textInput.value = t.text;
                    this.textInput.dataset.editid = t.id;
                    this.textInput.dispatchEvent(new Event("input"));
                  }
                }, 0);
                return;
              }
            }
          });
        }
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/p-editor/p-editor-demo.tsx
  var PEditorDemoPage, pEditorDemo;
  var init_p_editor_demo = __esm({
    "node_modules/lupine.components/src/component-pool/p-editor/p-editor-demo.tsx"() {
      init_p_editor();
      init_jsx_runtime();
      PEditorDemoPage = (props) => {
        let editor;
        const ref = {
          onLoad: async () => {
            const container = ref.$(".pe-demo-box");
            editor = new PEditor(container, props.args);
          }
        };
        const css2 = {
          display: "flex",
          flexDirection: "column",
          height: "calc(100vh - 100px)",
          padding: "0",
          boxSizing: "border-box",
          ".pe-demo-box": {
            width: "100%",
            height: "100%"
          }
        };
        return /* @__PURE__ */ jsx("div", { ref, css: css2, class: "p-editor-demo-container", children: /* @__PURE__ */ jsx("div", { class: "pe-demo-box" }) });
      };
      pEditorDemo = {
        id: "pEditorDemo",
        text: "PDF Editor",
        args: {},
        argTypes: {},
        render: (args) => {
          return /* @__PURE__ */ jsx(PEditorDemoPage, { args });
        },
        code: `import { PEditor } from 'lupine.components/component-pool';

const container = document.getElementById('my-container');
new PEditor(container, {
  // optionally pre-load a PDF:
  // pdfUrl: '/path/to/my.pdf'
});
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/p-editor/index.ts
  var init_p_editor2 = __esm({
    "node_modules/lupine.components/src/component-pool/p-editor/index.ts"() {
      init_p_editor_types();
      init_p_editor_utils();
      init_p_editor();
      init_p_editor_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/pdf-viewer/pdf-viewer.tsx
  var PdfViewer;
  var init_pdf_viewer = __esm({
    "node_modules/lupine.components/src/component-pool/pdf-viewer/pdf-viewer.tsx"() {
      init_jsx_runtime();
      PdfViewer = (props) => {
        const { src, width = "100%", height = "600px", style, class: className = "pdf-viewer" } = props;
        let resolvedSrc = "";
        if (typeof src === "string") {
          resolvedSrc = src;
        } else if (src instanceof File) {
          resolvedSrc = URL.createObjectURL(src);
        }
        if (!resolvedSrc) {
          return /* @__PURE__ */ jsx(
            "div",
            {
              class: className,
              style: {
                width,
                height,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                background: "#f5f5f5",
                color: "#666",
                border: "1px dashed #ccc",
                ...style
              },
              children: /* @__PURE__ */ jsx("span", { children: "No PDF Source Provided" })
            }
          );
        }
        return /* @__PURE__ */ jsx("div", { class: className, style: { width, height, ...style }, children: /* @__PURE__ */ jsx(
          "iframe",
          {
            src: resolvedSrc,
            width: "100%",
            height: "100%",
            style: { border: "none", display: "block" },
            title: "PDF Viewer"
          }
        ) });
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/pdf-viewer/pdf-viewer-demo.tsx
  var pdfViewerDemo;
  var init_pdf_viewer_demo = __esm({
    "node_modules/lupine.components/src/component-pool/pdf-viewer/pdf-viewer-demo.tsx"() {
      init_pdf_viewer();
      init_jsx_runtime();
      pdfViewerDemo = {
        id: "pdfViewerDemo",
        text: "PDF Viewer",
        args: {
          src: "https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf",
          // fallback dummy remote url for testing
          width: "100%",
          height: "600px"
        },
        argTypes: {
          src: { control: "text", description: "PDF URL or File object" },
          width: { control: "text" },
          height: { control: "text" }
        },
        render: (args) => {
          const handleFileUpload = (e) => {
            const file = e.target.files[0];
            if (file && file.type === "application/pdf") {
              const mount = document.getElementById("pdf-viewer-mount");
              if (mount) {
                mount.innerHTML = "";
                const ViewerNode = /* @__PURE__ */ jsx(PdfViewer, { src: file, width: "100%", height: "600px" });
                mount.style.display = "block";
                mount.innerHTML = `<iframe src="${URL.createObjectURL(
                  file
                )}" width="100%" height="100%" style="border: none; display: block;" title="PDF Viewer"></iframe>`;
              }
            } else {
              alert("Please upload a valid PDF file.");
            }
          };
          return /* @__PURE__ */ jsx(
            "div",
            {
              style: {
                padding: "20px",
                display: "flex",
                flexDirection: "column",
                gap: "30px",
                width: "100%",
                maxWidth: "1000px"
              },
              children: [
                /* @__PURE__ */ jsx("section", { children: [
                  /* @__PURE__ */ jsx("div", { class: "section-title", children: "Local File Viewer" }),
                  /* @__PURE__ */ jsx("p", { style: { fontSize: "14px", color: "#666", marginBottom: "16px" }, children: "Select a PDF file from your computer to view it using the browser's built-in PDF capabilities." }),
                  /* @__PURE__ */ jsx("div", { style: { marginBottom: "16px" }, children: [
                    /* @__PURE__ */ jsx(
                      "input",
                      {
                        type: "file",
                        accept: "application/pdf",
                        onChange: handleFileUpload,
                        style: { display: "none" },
                        id: "pdf-upload-input"
                      }
                    ),
                    /* @__PURE__ */ jsx(
                      "label",
                      {
                        for: "pdf-upload-input",
                        style: {
                          padding: "8px 16px",
                          background: "var(--primary-accent-color, #0a74c9)",
                          color: "#fff",
                          borderRadius: "4px",
                          cursor: "pointer",
                          display: "inline-block"
                        },
                        children: "Upload Local PDF"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsx(
                    "div",
                    {
                      id: "pdf-viewer-mount-container",
                      style: { border: "1px solid #ddd", borderRadius: "4px", overflow: "hidden" },
                      children: /* @__PURE__ */ jsx(
                        "div",
                        {
                          id: "pdf-viewer-mount",
                          style: {
                            width: "100%",
                            height: "600px",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            background: "#fafafa",
                            color: "#999"
                          },
                          children: "No local file selected. Click the button above to upload."
                        }
                      )
                    }
                  )
                ] }),
                /* @__PURE__ */ jsx("section", { children: [
                  /* @__PURE__ */ jsx("div", { class: "section-title", children: "Remote URL Viewer" }),
                  /* @__PURE__ */ jsx("p", { style: { fontSize: "14px", color: "#666", marginBottom: "16px" }, children: "This viewer loads a PDF remotely using the provided URL source." }),
                  /* @__PURE__ */ jsx("div", { style: { border: "1px solid #ddd", borderRadius: "4px", overflow: "hidden" }, children: /* @__PURE__ */ jsx(PdfViewer, { ...args }) })
                ] })
              ]
            }
          );
        },
        code: `import { PdfViewer } from "lupine.components/component-pool";

// Load from URL
const el1 = <PdfViewer src="https://example.com/sample.pdf" height="600px" />;

// Or load from a File object
const el2 = <PdfViewer src={myPdfFile} width="100%" height="600px" />;
`
      };
    }
  });

  // node_modules/lupine.components/src/component-pool/pdf-viewer/index.ts
  var init_pdf_viewer2 = __esm({
    "node_modules/lupine.components/src/component-pool/pdf-viewer/index.ts"() {
      init_pdf_viewer();
      init_pdf_viewer_demo();
    }
  });

  // node_modules/lupine.components/src/demo/demo-page.tsx
  var DemoPage;
  var init_demo_page = __esm({
    "node_modules/lupine.components/src/demo/demo-page.tsx"() {
      init_demo_container();
      init_jsx_runtime();
      DemoPage = (props) => {
        const { story } = props;
        let currentArgs = { ...story.args };
        let currentMode = "preview";
        let iframeWindow = null;
        const ref = {};
        const updatePreview = () => {
          if (iframeWindow && iframeWindow._lj_demo_hook) {
            iframeWindow._lj_demo_hook.updateArgs(currentArgs, currentMode === "code");
          }
        };
        const onIframeLoad = (win) => {
          iframeWindow = win;
          updatePreview();
        };
        const updateArg = (key, value) => {
          currentArgs[key] = value;
          updatePreview();
        };
        const renderControl = (key, argType) => {
          const val = currentArgs[key];
          const { control, options: options3, description } = argType;
          let inputNode = /* @__PURE__ */ jsx("span", { children: [
            "Unknown control: ",
            control
          ] });
          if (control === "text") {
            inputNode = /* @__PURE__ */ jsx(
              "input",
              {
                class: "&-ctl-input input-base",
                type: "text",
                value: val || "",
                onInput: (e) => updateArg(key, e.target.value)
              }
            );
          } else if (control === "boolean") {
            inputNode = /* @__PURE__ */ jsx("label", { class: "&-ctl-check", children: /* @__PURE__ */ jsx(
              "input",
              {
                type: "checkbox",
                checked: !!val,
                onChange: (e) => updateArg(key, e.target.checked)
              }
            ) });
          } else if (control === "select" && options3) {
            inputNode = /* @__PURE__ */ jsx(
              "select",
              {
                class: "&-ctl-input input-base",
                onChange: (e) => updateArg(key, e.target.value),
                children: options3.map((opt) => /* @__PURE__ */ jsx("option", { value: opt, selected: opt === val, children: opt }))
              }
            );
          } else if (control === "number") {
            inputNode = /* @__PURE__ */ jsx(
              "input",
              {
                class: "&-ctl-input input-base",
                type: "number",
                value: val || 0,
                onInput: (e) => updateArg(key, Number(e.target.value))
              }
            );
          } else if (control === "color") {
            inputNode = /* @__PURE__ */ jsx("label", { class: "&-ctl-color", style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
              /* @__PURE__ */ jsx(
                "input",
                {
                  type: "color",
                  value: val || "#000000",
                  onInput: (e) => updateArg(key, e.target.value),
                  style: { cursor: "pointer", padding: 0, width: "30px", height: "30px", border: "none", background: "none" }
                }
              ),
              /* @__PURE__ */ jsx("span", { style: { fontSize: "12px", color: "var(--secondary-color, #666)" }, children: val || "Default" })
            ] });
          } else if (control === "file") {
            inputNode = /* @__PURE__ */ jsx("label", { class: "&-ctl-file", style: { display: "flex", alignItems: "center", gap: "8px", cursor: "pointer" }, children: [
              /* @__PURE__ */ jsx(
                "input",
                {
                  type: "file",
                  accept: "image/*",
                  style: { display: "none" },
                  onChange: (e) => {
                    var _a;
                    const file = (_a = e.target.files) == null ? void 0 : _a[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                      var _a2;
                      const dataUrl = (_a2 = ev.target) == null ? void 0 : _a2.result;
                      updateArg(key, dataUrl);
                      const label = e.target.closest("label");
                      const img = label == null ? void 0 : label.querySelector("img");
                      if (img) {
                        img.src = dataUrl;
                        img.style.display = "block";
                      }
                      const placeholder = label == null ? void 0 : label.querySelector(".file-placeholder");
                      if (placeholder) placeholder.style.display = "none";
                    };
                    reader.readAsDataURL(file);
                  }
                }
              ),
              val ? /* @__PURE__ */ jsx(
                "img",
                {
                  src: val,
                  style: {
                    width: "30px",
                    height: "30px",
                    objectFit: "contain",
                    borderRadius: "4px",
                    border: "1px solid #ccc"
                  }
                }
              ) : /* @__PURE__ */ jsx(
                "span",
                {
                  class: "file-placeholder",
                  style: {
                    display: "inline-flex",
                    alignItems: "center",
                    justifyContent: "center",
                    width: "30px",
                    height: "30px",
                    borderRadius: "4px",
                    border: "1px dashed #aaa",
                    fontSize: "18px",
                    color: "#aaa"
                  },
                  children: "+"
                }
              ),
              /* @__PURE__ */ jsx("span", { style: { fontSize: "12px", color: "var(--secondary-color, #666)" }, children: val ? "Change image\u2026" : "Click to upload image\u2026" })
            ] });
          }
          return /* @__PURE__ */ jsx("div", { class: "&-ctl-item", children: [
            /* @__PURE__ */ jsx("div", { class: "&-ctl-label", children: key }),
            inputNode,
            description && /* @__PURE__ */ jsx("div", { class: "&-ctl-desc", children: description })
          ] });
        };
        const renderControlBox = () => {
          if (!story.argTypes) {
            return /* @__PURE__ */ jsx("div", { children: "No argTypes defined for this story." });
          }
          const controlCss = {
            padding: "8px",
            ".&-header": {
              display: "flex",
              alignItems: "center",
              // justifyContent: 'space-between',
              margin: "0 0 16px 0"
            },
            ".&-title": {
              margin: 0,
              fontSize: "16px"
            },
            ".&-modes": {
              display: "flex",
              gap: "4px",
              backgroundColor: "#f5f5f5",
              padding: "2px",
              borderRadius: "4px",
              marginLeft: "16px"
            },
            ".&-mode-btn": {
              border: "none",
              background: "transparent",
              padding: "4px 12px",
              fontSize: "12px",
              fontWeight: "bold",
              cursor: "pointer",
              borderRadius: "2px",
              color: "#666",
              "&.active": {
                background: "white",
                color: "#000",
                boxShadow: "0 1px 2px rgba(0,0,0,0.1)"
              }
            },
            ".&-ctl-check": {
              display: "flex",
              alignItems: "center"
            },
            ".&-ctl-item": {
              display: "flex",
              alignItems: "center",
              marginBottom: "8px"
            },
            ".&-ctl-label": {
              width: "120px",
              fontWeight: "bold",
              fontSize: "14px"
            },
            ".&-ctl-input": {
              flex: 1,
              maxWidth: "300px",
              padding: "4px 8px",
              border: "1px solid #ccc",
              borderRadius: "4px"
            },
            ".&-ctl-desc": {
              marginLeft: "8px",
              fontSize: "12px",
              color: "#666"
            }
          };
          return /* @__PURE__ */ jsx("div", { css: controlCss, ref, children: [
            /* @__PURE__ */ jsx("div", { class: "&-header", children: [
              /* @__PURE__ */ jsx("h3", { class: "&-title", children: "Controls" }),
              /* @__PURE__ */ jsx("div", { class: "&-modes", children: [
                /* @__PURE__ */ jsx(
                  "button",
                  {
                    class: `&-mode-btn ${currentMode === "preview" ? "active" : ""}`,
                    onClick: () => {
                      currentMode = "preview";
                      updatePreview();
                      ref.$all("&-mode-btn", true).forEach((btn) => btn.classList.remove("active"));
                      ref.$all("&-mode-btn")[0].classList.add("active");
                    },
                    children: "Preview"
                  }
                ),
                /* @__PURE__ */ jsx(
                  "button",
                  {
                    class: `&-mode-btn ${currentMode === "code" ? "active" : ""}`,
                    onClick: () => {
                      currentMode = "code";
                      updatePreview();
                      ref.$all("&-mode-btn", true).forEach((btn) => btn.classList.remove("active"));
                      ref.$all("&-mode-btn")[1].classList.add("active");
                    },
                    children: "Code"
                  }
                )
              ] })
            ] }),
            story.argTypes && Object.keys(story.argTypes).map((key) => {
              const argType = story.argTypes[key];
              return renderControl(key, argType);
            })
          ] });
        };
        const url = typeof location !== "undefined" ? location.pathname + `/render?id=${story.id}` : `/demo/render?id=${story.id}`;
        return /* @__PURE__ */ jsx(DemoContainer, { demoUrl: url, onIframeLoad, controlBox: renderControlBox() });
      };
    }
  });

  // node_modules/lupine.components/src/demo/mock/user-settings-mock.tsx
  var Nested2DemoMock, NestedDemoMockContent, NestedDemoMock, UserSettingsMockContent, UserSettingsMock;
  var init_user_settings_mock = __esm({
    "node_modules/lupine.components/src/demo/mock/user-settings-mock.tsx"() {
      init_src2();
      init_jsx_runtime();
      Nested2DemoMock = (props) => {
        const css2 = {
          display: "flex",
          flexDirection: "column",
          flex: "1",
          padding: "0 16px",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          textAlign: "center",
          color: "var(--secondary-text-color)",
          fontSize: "16px"
        };
        return /* @__PURE__ */ jsx(
          HeaderWithBackFrame,
          {
            title: `Nested Demo`,
            onBack: (event) => {
              props.sliderFrameHook.close(event);
            },
            children: /* @__PURE__ */ jsx("div", { css: css2, children: [
              "This is a generic sub-page demo.",
              /* @__PURE__ */ jsx("br", {}),
              /* @__PURE__ */ jsx("br", {}),
              "(Further nesting is disabled in this mockup)"
            ] })
          }
        );
      };
      NestedDemoMockContent = () => {
        const sliderFrameHook = {};
        const css2 = {
          display: "flex",
          flexDirection: "column",
          flex: "1",
          padding: "0 16px",
          ".fb-detail": {
            height: "100px"
          },
          ".input-field": {
            position: "relative",
            marginTop: "16px",
            marginBottom: "16px"
          },
          ".input-base": {
            width: "100%",
            padding: "12px",
            border: "1px solid var(--primary-border-color)",
            borderRadius: "8px",
            boxSizing: "border-box"
          },
          ".setting-section-row-btn": {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            padding: "12px 16px",
            backgroundColor: "var(--primary-color)",
            color: "white",
            borderRadius: "8px",
            marginTop: "16px",
            cursor: "pointer",
            fontSize: "16px",
            gap: "8px"
          },
          ".setting-section-row-btn i": {
            fontSize: "20px"
          }
        };
        const ref = {};
        const openAnotherLevel = () => {
          sliderFrameHook.load(/* @__PURE__ */ jsx(Nested2DemoMock, { sliderFrameHook }));
        };
        const submitFeedback = async (e) => {
          const titleDom = ref.$(".fb-title");
          const detailDom = ref.$(".fb-detail");
          if (!titleDom || !titleDom.value || !detailDom || !detailDom.value) {
            NotificationMessage.sendMessage("Please enter the required information.", "var(--error-bg-color)" /* Error */);
            return;
          }
          const index = await ActionSheetSelectPromise({
            title: "Are you sure you want to submit?",
            options: ["Confirm"],
            cancelButtonText: "Cancel"
          });
          if (index !== 0) {
            return;
          }
          NotificationMessage.sendMessage("Thank you for your feedback.", "var(--success-bg-color)" /* Success */);
          sliderFrameHook.close(e);
        };
        return /* @__PURE__ */ jsx("div", { css: css2, ref, children: [
          /* @__PURE__ */ jsx(SliderFrame2, { hook: sliderFrameHook }),
          /* @__PURE__ */ jsx("div", { class: "setting-section-group", children: [
            /* @__PURE__ */ jsx("div", { class: "setting-section-title", style: { marginTop: "20px", marginBottom: "8px", fontWeight: "bold" }, children: "Nested Demo" }),
            /* @__PURE__ */ jsx("div", { class: "setting-section-block", children: /* @__PURE__ */ jsx("div", { class: "setting-section-item", children: /* @__PURE__ */ jsx(
              "div",
              {
                class: "setting-section-item-text",
                style: { color: "var(--secondary-text-color)", marginBottom: "16px" },
                children: "This is a generic generic demo page. You can nest another level of itself by clicking the button below."
              }
            ) }) }),
            /* @__PURE__ */ jsx(
              "div",
              {
                class: "setting-section-row-btn",
                onClick: openAnotherLevel,
                style: { backgroundColor: "var(--secondary-color, #4caf50)" },
                children: [
                  /* @__PURE__ */ jsx("i", { class: "ifc-icon ma-chevron-right" }),
                  /* @__PURE__ */ jsx("div", { children: "Open Nested Demo" })
                ]
              }
            ),
            /* @__PURE__ */ jsx("div", { class: "row-box u-ph-code-top", style: { marginTop: "32px" }, children: /* @__PURE__ */ jsx("div", { class: "input-field flex-1", children: /* @__PURE__ */ jsx("input", { class: "input-base w-100p fb-title", type: "text", required: true, placeholder: "Summary" }) }) }),
            /* @__PURE__ */ jsx("div", { class: "row-box u-ph-code-top", children: /* @__PURE__ */ jsx("div", { class: "input-field flex-1", children: /* @__PURE__ */ jsx("textarea", { class: "input-base w-100p fb-detail", required: true, placeholder: "Details..." }) }) }),
            /* @__PURE__ */ jsx("div", { class: "setting-section-row-btn warning mt-m", onClick: submitFeedback, children: [
              /* @__PURE__ */ jsx("i", { class: "ifc-icon ma-email-outline" }),
              /* @__PURE__ */ jsx("div", { children: "Submit Form" })
            ] })
          ] })
        ] });
      };
      NestedDemoMock = (props) => {
        props.sliderFrameHook.addClass("desktop-slide-right");
        return /* @__PURE__ */ jsx(
          HeaderWithBackFrame,
          {
            title: `Nested Demo`,
            onBack: (event) => {
              if (props.sliderFrameHook.close) props.sliderFrameHook.close(event);
            },
            children: /* @__PURE__ */ jsx(NestedDemoMockContent, {})
          }
        );
      };
      UserSettingsMockContent = () => {
        const sliderFrameHook = {};
        const renderContent = () => {
          const css2 = {
            display: "flex",
            flexDirection: "column",
            flex: "1",
            padding: "0 16px",
            backgroundColor: "var(--secondary-bg-color, #f5f5f5)",
            // Minimal settings UI styles ported from what was expected in original UI
            ".setting-section-group": {
              marginTop: "16px"
            },
            ".setting-section-title": {
              padding: "0 16px 8px 16px",
              fontSize: "13px",
              color: "var(--secondary-text-color, #666)"
            },
            ".setting-section-block": {
              backgroundColor: "var(--primary-bg-color, white)",
              borderRadius: "12px",
              overflow: "hidden"
            },
            ".setting-section-item": {
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between",
              padding: "16px",
              borderBottom: "1px solid var(--primary-border-color, #eee)",
              cursor: "pointer"
            },
            ".setting-section-item:last-child": {
              borderBottom: "none"
            },
            ".setting-section-item-text": {
              fontSize: "15px",
              color: "var(--primary-text-color)"
            },
            ".setting-section-item-icon": {
              color: "var(--secondary-text-color, #ccc)",
              display: "flex"
            },
            ".setting-section-item-icon i": {
              fontSize: "20px"
            },
            ".setting-section-row-btn": {
              backgroundColor: "var(--primary-bg-color, white)",
              borderRadius: "12px",
              padding: "16px",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              gap: "8px",
              color: "#ff3b30",
              fontSize: "15px",
              cursor: "pointer",
              fontWeight: "bold"
            },
            ".setting-section-row-btn i": {
              fontSize: "20px"
            }
          };
          const openNestedDemo = () => {
            sliderFrameHook.load(/* @__PURE__ */ jsx(NestedDemoMock, { sliderFrameHook }));
          };
          return /* @__PURE__ */ jsx("div", { css: css2, class: "user-settings-top", children: [
            /* @__PURE__ */ jsx(SliderFrame2, { hook: sliderFrameHook }),
            /* @__PURE__ */ jsx("div", { class: "setting-section-group", children: [
              /* @__PURE__ */ jsx("div", { class: "setting-section-title", children: "Account Settings" }),
              /* @__PURE__ */ jsx("div", { class: "setting-section-block", children: [
                /* @__PURE__ */ jsx("div", { class: "setting-section-item", onClick: openNestedDemo, children: [
                  /* @__PURE__ */ jsx("div", { class: "setting-section-item-text", children: "Phone Number" }),
                  /* @__PURE__ */ jsx("div", { class: "setting-section-item-icon", children: /* @__PURE__ */ jsx("i", { class: "ifc-icon ma-chevron-right" }) })
                ] }),
                /* @__PURE__ */ jsx("div", { class: "setting-section-item", onClick: openNestedDemo, children: [
                  /* @__PURE__ */ jsx("div", { class: "setting-section-item-text", children: "Email Address" }),
                  /* @__PURE__ */ jsx("div", { class: "setting-section-item-icon", children: /* @__PURE__ */ jsx("i", { class: "ifc-icon ma-chevron-right" }) })
                ] }),
                /* @__PURE__ */ jsx("div", { class: "setting-section-item", onClick: openNestedDemo, children: [
                  /* @__PURE__ */ jsx("div", { class: "setting-section-item-text", children: "Delete Account" }),
                  /* @__PURE__ */ jsx("div", { class: "setting-section-item-icon", children: /* @__PURE__ */ jsx("i", { class: "ifc-icon ma-chevron-right" }) })
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsx("div", { class: "setting-section-group", children: [
              /* @__PURE__ */ jsx("div", { class: "setting-section-title", children: "Other Settings" }),
              /* @__PURE__ */ jsx("div", { class: "setting-section-block", children: [
                /* @__PURE__ */ jsx("div", { class: "setting-section-item", onClick: openNestedDemo, children: [
                  /* @__PURE__ */ jsx("div", { class: "setting-section-item-text", children: "Feedback Request" }),
                  /* @__PURE__ */ jsx("div", { class: "setting-section-item-icon", children: /* @__PURE__ */ jsx("i", { class: "ifc-icon ma-chevron-right" }) })
                ] }),
                /* @__PURE__ */ jsx("div", { class: "setting-section-item", onClick: openNestedDemo, children: [
                  /* @__PURE__ */ jsx("div", { class: "setting-section-item-text", children: "Clear Cache" }),
                  /* @__PURE__ */ jsx("div", { class: "setting-section-item-icon", children: /* @__PURE__ */ jsx("i", { class: "ifc-icon ma-chevron-right" }) })
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsx("div", { class: "setting-section-group", children: /* @__PURE__ */ jsx(
              "div",
              {
                class: "setting-section-row-btn",
                onClick: () => NotificationMessage.sendMessage("Logged out demo!", "var(--success-bg-color)" /* Success */),
                children: [
                  /* @__PURE__ */ jsx("i", { class: "ifc-icon ma-logout" }),
                  /* @__PURE__ */ jsx("div", { children: "Logout Session" })
                ]
              }
            ) })
          ] });
        };
        const dom = new HtmlVar(renderContent());
        return /* @__PURE__ */ jsx("div", { style: { height: "100%", overflow: "auto" }, children: dom.node });
      };
      UserSettingsMock = (props) => {
        props.sliderFrameHook.addClass("desktop-slide-left");
        return /* @__PURE__ */ jsx(
          HeaderWithBackFrame,
          {
            title: "Settings (Demo)",
            onBack: (event) => {
              props.sliderFrameHook.close(event);
            },
            children: /* @__PURE__ */ jsx(UserSettingsMockContent, {})
          }
        );
      };
    }
  });

  // node_modules/lupine.components/src/demo/mock/responsive-demo-mock-pages.tsx
  var HomePage, CustomerPage, MemberPage;
  var init_responsive_demo_mock_pages = __esm({
    "node_modules/lupine.components/src/demo/mock/responsive-demo-mock-pages.tsx"() {
      init_floating_icon_menu2();
      init_jsx_runtime();
      HomePage = () => {
        return /* @__PURE__ */ jsx("div", { style: { padding: "16px" }, children: [
          /* @__PURE__ */ jsx(
            "div",
            {
              style: {
                backgroundColor: "var(--primary-color, #1890ff)",
                color: "white",
                padding: "24px",
                borderRadius: "12px",
                marginBottom: "20px"
              },
              children: [
                /* @__PURE__ */ jsx("h2", { style: { margin: 0, fontSize: "24px" }, children: "Welcome Back!" }),
                /* @__PURE__ */ jsx("p", { style: { marginTop: "8px", opacity: 0.8 }, children: "Explore the latest features in Lupine.js" })
              ]
            }
          ),
          /* @__PURE__ */ jsx("h3", { style: { marginBottom: "12px" }, children: "Recent Activity" }),
          /* @__PURE__ */ jsx(
            "div",
            {
              style: {
                backgroundColor: "var(--primary-bg-color, white)",
                borderRadius: "12px",
                overflow: "hidden",
                border: "1px solid var(--primary-border, #eee)"
              },
              children: [1, 2, 3].map((i) => /* @__PURE__ */ jsx(
                "div",
                {
                  class: "row-box",
                  style: { padding: "16px", borderBottom: i < 3 ? "1px solid var(--primary-border, #eee)" : "none" },
                  children: [
                    /* @__PURE__ */ jsx(
                      "div",
                      {
                        style: {
                          width: "40px",
                          height: "40px",
                          borderRadius: "50%",
                          backgroundColor: "var(--primary-color, #1890ff)",
                          opacity: 0.1,
                          marginRight: "16px"
                        }
                      }
                    ),
                    /* @__PURE__ */ jsx("div", { class: "col", children: [
                      /* @__PURE__ */ jsx("div", { style: { fontWeight: "bold" }, children: [
                        "Activity Item ",
                        i
                      ] }),
                      /* @__PURE__ */ jsx("div", { style: { fontSize: "12px", color: "var(--secondary-text-color, #666)", marginTop: "4px" }, children: "Just now" })
                    ] })
                  ]
                }
              ))
            }
          ),
          /* @__PURE__ */ jsx(FloatingIconMenu, { mainIcon: floatingIconMenuMainBtnMock, items: floatingIconMenuOptionsMock, bottom: "75px" })
        ] });
      };
      CustomerPage = () => {
        return /* @__PURE__ */ jsx("div", { style: { padding: "16px", display: "flex", flexDirection: "column", height: "100%" }, children: [
          /* @__PURE__ */ jsx("h2", { style: { marginBottom: "20px" }, children: "Customer Service" }),
          /* @__PURE__ */ jsx(
            "div",
            {
              class: "col",
              style: {
                backgroundColor: "var(--primary-bg-color, #f9f9f9)",
                borderRadius: "12px",
                padding: "16px",
                marginBottom: "16px",
                overflowY: "auto",
                border: "1px solid var(--primary-border, #eee)"
              },
              children: [
                /* @__PURE__ */ jsx("div", { class: "row-box", style: { marginBottom: "16px" }, children: [
                  /* @__PURE__ */ jsx(
                    "div",
                    {
                      style: { width: "32px", height: "32px", borderRadius: "50%", backgroundColor: "#eee", marginRight: "12px" }
                    }
                  ),
                  /* @__PURE__ */ jsx(
                    "div",
                    {
                      style: {
                        backgroundColor: "white",
                        padding: "12px",
                        borderRadius: "0 12px 12px 12px",
                        border: "1px solid var(--primary-border, #eee)"
                      },
                      children: "Hello! How can I help you today?"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsx("div", { class: "row-box", style: { marginBottom: "16px", justifyContent: "flex-end" }, children: /* @__PURE__ */ jsx(
                  "div",
                  {
                    style: {
                      backgroundColor: "var(--primary-color, #1890ff)",
                      color: "white",
                      padding: "12px",
                      borderRadius: "12px 0 12px 12px"
                    },
                    children: "I have a question about my recent order."
                  }
                ) })
              ]
            }
          ),
          /* @__PURE__ */ jsx(
            "div",
            {
              class: "row-box",
              style: {
                backgroundColor: "white",
                borderRadius: "24px",
                padding: "4px 4px 4px 16px",
                border: "1px solid var(--primary-border, #eee)"
              },
              children: [
                /* @__PURE__ */ jsx(
                  "input",
                  {
                    type: "text",
                    placeholder: "Type a message...",
                    style: { border: "none", background: "transparent", outline: "none", flex: 1 }
                  }
                ),
                /* @__PURE__ */ jsx(
                  "div",
                  {
                    style: {
                      backgroundColor: "var(--primary-color, #1890ff)",
                      color: "white",
                      padding: "8px 16px",
                      borderRadius: "20px",
                      cursor: "pointer"
                    },
                    children: "Send"
                  }
                )
              ]
            }
          )
        ] });
      };
      MemberPage = () => {
        return /* @__PURE__ */ jsx("div", { style: { padding: "16px" }, children: [
          /* @__PURE__ */ jsx(
            "div",
            {
              class: "row-box",
              style: {
                backgroundColor: "var(--primary-bg-color, white)",
                padding: "20px",
                borderRadius: "12px",
                border: "1px solid var(--primary-border, #eee)",
                marginBottom: "20px"
              },
              children: [
                /* @__PURE__ */ jsx(
                  "div",
                  {
                    style: { width: "60px", height: "60px", borderRadius: "50%", backgroundColor: "#eee", marginRight: "16px" }
                  }
                ),
                /* @__PURE__ */ jsx("div", { class: "col", children: [
                  /* @__PURE__ */ jsx("h2", { style: { margin: 0 }, children: "John Doe" }),
                  /* @__PURE__ */ jsx("div", { style: { color: "var(--secondary-color, #faad14)", fontSize: "14px", marginTop: "4px" }, children: "VIP Member Status" })
                ] })
              ]
            }
          ),
          /* @__PURE__ */ jsx("h3", { style: { marginBottom: "12px" }, children: "Membership Privileges" }),
          /* @__PURE__ */ jsx(
            "div",
            {
              style: {
                backgroundColor: "var(--primary-bg-color, white)",
                borderRadius: "12px",
                overflow: "hidden",
                border: "1px solid var(--primary-border, #eee)"
              },
              children: ["Exclusive Content", "Priority Support", "Early Access", "Ad-Free Experience"].map((privilege, i) => /* @__PURE__ */ jsx(
                "div",
                {
                  class: "row-box",
                  style: { padding: "16px", borderBottom: i < 3 ? "1px solid var(--primary-border, #eee)" : "none" },
                  children: [
                    /* @__PURE__ */ jsx(
                      "i",
                      {
                        class: "ifc-icon ma-crown-outline",
                        style: { color: "var(--secondary-color, #faad14)", marginRight: "16px", fontSize: "20px" }
                      }
                    ),
                    /* @__PURE__ */ jsx("div", { class: "col", children: privilege })
                  ]
                }
              ))
            }
          )
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/frames/responsive-frame-demo.tsx
  var responsiveFrameDemo;
  var init_responsive_frame_demo = __esm({
    "node_modules/lupine.components/src/frames/responsive-frame-demo.tsx"() {
      init_components();
      init_responsive_frame();
      init_side_menu_mock();
      init_slider_frame();
      init_user_settings_mock();
      init_responsive_demo_mock_pages();
      init_paging_link_demo();
      init_jsx_runtime();
      responsiveFrameDemo = {
        id: "responsive-frame-demo",
        text: "Responsive Frame",
        args: {
          slideDirection: "right"
        },
        argTypes: {
          slideDirection: {
            control: "select",
            options: ["right", "bottom"]
          }
        },
        render: (args) => {
          const main = new HtmlVar(HomePage());
          const sliderFrameHook = {};
          const mobileBottomMenu = [
            { icon: "ma-home-outline", url: "#/", text: "Home", js: () => main.value = HomePage() },
            { icon: "bs-list", url: "#/list", text: "List", js: () => main.value = PagingLinkPage() },
            {
              icon: "co-cil-chat-bubble",
              url: "#/customer",
              text: "Service",
              topout: true,
              js: () => main.value = CustomerPage()
            },
            { icon: "ma-crown-outline", url: "#/member", text: "VIP", js: () => main.value = MemberPage() },
            {
              icon: "ma-account-cog-outline",
              url: "#/settings",
              text: "Settings",
              js: () => {
                if (sliderFrameHook.load) {
                  sliderFrameHook.load(/* @__PURE__ */ jsx(UserSettingsMock, { sliderFrameHook }));
                }
              }
            }
          ];
          const css2 = {
            width: "100%",
            // We limit height carefully so it looks like an App screen within the Demo Container
            height: "600px",
            maxHeight: "100%",
            overflow: "hidden",
            // to hide scrollbars bleeding out
            position: "relative"
            // Responsive reset to see the desktop mode more easily without jumping huge breakpoints
            // But typically ResponsiveFrame handles its own media queries.
          };
          const mainContent = /* @__PURE__ */ jsx("div", { style: { padding: "20px", textAlign: "center" }, children: [
            /* @__PURE__ */ jsx(MobileHeaderCenter, { children: /* @__PURE__ */ jsx(
              MobileHeaderTitleIcon,
              {
                title: "Responsive Frame Demo",
                left: /* @__PURE__ */ jsx(MobileHeaderEmptyIcon, {}),
                right: /* @__PURE__ */ jsx(MobileTopSysIcon, {})
              }
            ) }),
            main.node
          ] });
          const frame = ResponsiveFrame({
            placeholderClassname: "demo-responsive-content",
            mainContent,
            desktopHeaderTitle: "Desktop Header",
            desktopFooterTitle: "Desktop Footer (Hidden on Mobile)",
            desktopTopMenu: mobileBottomMenu,
            mobileBottomMenu,
            mobileSideMenuContent: /* @__PURE__ */ jsx(SideMenuMock, {}),
            sharedContents: /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsx(SliderFrame2, { hook: sliderFrameHook, direction: args.slideDirection }) })
          });
          return /* @__PURE__ */ jsx("div", { css: css2, children: frame });
        },
        code: `// Ensure MobileSideMenuHelper is accessible for touch events
MobileSideMenuHelper.addTouchEvent();

<ResponsiveFrame
  placeholderClassname="my-page-content"
  mainContent={<div>Content</div>}
  desktopHeaderTitle="My PC Site"
  desktopFooterTitle="Copyright 2025"
  desktopTopMenu={menuItems}
  mobileBottomMenu={menuItems}
  mobileSideMenuContent={<MySideMenu />}
  sharedContents={<div style={{ display: 'contents' }}></div>}
/>`
      };
    }
  });

  // node_modules/lupine.components/src/demo/demo-frame-helper.tsx
  var chineseMenuText, translateMenuToChinese, DemoFrameHelper, demoFrameHelper;
  var init_demo_frame_helper = __esm({
    "node_modules/lupine.components/src/demo/demo-frame-helper.tsx"() {
      init_demo_about();
      init_button_demo();
      init_button_push_animation_demo();
      init_toggle_switch_demo();
      init_input_number_demo();
      init_spinner_demo();
      init_stars_component_demo();
      init_editable_label_demo();
      init_progress_demo();
      init_radio_label_demo();
      init_select_angle_demo();
      init_switch_option_demo();
      init_action_sheet_demo();
      init_select_with_title_demo();
      init_input_with_title_demo();
      init_tabs_demo();
      init_modal_demo();
      init_popup_menu_demo();
      init_notice_message_demo();
      init_resizable_splitter_demo();
      init_redirect_demo();
      init_text_wave_demo();
      init_text_scale_demo();
      init_text_glow_demo();
      init_toggle_play_button_demo();
      init_toggle_button_demo();
      init_message_box_demo();
      init_mobile_side_menu_demo();
      init_slider_frame_demo();
      init_range2();
      init_badge2();
      init_timeline2();
      init_radial_progress2();
      init_breadcrumbs2();
      init_skeleton2();
      init_copy_button2();
      init_aspect_ratio2();
      init_map_wrapper2();
      init_avatar2();
      init_card2();
      init_carousel2();
      init_cascader2();
      init_tooltip2();
      init_time_picker2();
      init_date_picker2();
      init_pull_to_refresh_demo();
      init_tag_input_demo();
      init_floating_icon_menu2();
      init_tour2();
      init_search_input2();
      init_h_editor2();
      init_paging_link_demo();
      init_slide_tab_component_demo();
      init_qrcode2();
      init_i_editor2();
      init_youtube_player2();
      init_p_editor2();
      init_pdf_viewer2();
      init_demo_page();
      init_responsive_frame_demo();
      init_jsx_runtime();
      chineseMenuText = [
        { text: "Help", zh: "\u5E2E\u52A9" },
        { text: "About", zh: "\u5173\u4E8E" }
      ];
      translateMenuToChinese = (text) => {
        const menuItem = chineseMenuText.find((item) => item.text === text);
        return menuItem ? menuItem.zh : text;
      };
      DemoFrameHelper = class {
        consoleTitle = "Welcome to Demo Panel";
        getConsoleTitle() {
          return this.consoleTitle;
        }
        setConsoleTitle(title) {
          this.consoleTitle = title;
        }
        maxWidthMobileMenu = "700px";
        setMaxWidthMobileMenu(maxWidthMobileMenu) {
          this.maxWidthMobileMenu = maxWidthMobileMenu;
        }
        getMaxWidthMobileMenu() {
          return this.maxWidthMobileMenu;
        }
        maxTabsCount = 20;
        setMaxTabsCount(count) {
          this.maxTabsCount = count;
        }
        getMaxTabsCount() {
          return this.maxTabsCount;
        }
        tabsHook = {};
        setTabsHook(hook) {
          this.tabsHook = hook;
        }
        getTabsHook() {
          return this.tabsHook;
        }
        AppDemoHookCheckLogin;
        setAppDemoHookCheckLogin(hook) {
          this.AppDemoHookCheckLogin = hook;
        }
        getAppDemoHookCheckLogin() {
          return this.AppDemoHookCheckLogin;
        }
        AppDemoHookLogout;
        setAppDemoHookLogout(hook) {
          this.AppDemoHookLogout = hook;
        }
        getAppDemoHookLogout() {
          return this.AppDemoHookLogout;
        }
        demoTopMenu = [
          {
            id: "general-demo",
            text: "General",
            url: "",
            items: [
              {
                id: buttonDemo.id,
                text: buttonDemo.text,
                url: "",
                js: () => this.addPanel(buttonDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: buttonDemo }))
              },
              {
                id: buttonPushAnimationDemo.id,
                text: buttonPushAnimationDemo.text,
                url: "",
                js: () => this.addPanel(buttonPushAnimationDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: buttonPushAnimationDemo }))
              },
              {
                id: inputNumberDemo.id,
                text: inputNumberDemo.text,
                url: "",
                js: () => this.addPanel(inputNumberDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: inputNumberDemo }))
              },
              {
                id: toggleSwitchDemo.id,
                text: toggleSwitchDemo.text,
                url: "",
                js: () => this.addPanel(toggleSwitchDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: toggleSwitchDemo }))
              },
              {
                id: toggleButtonDemo.id,
                text: toggleButtonDemo.text,
                url: "",
                js: () => this.addPanel(toggleButtonDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: toggleButtonDemo }))
              },
              {
                id: togglePlayButtonDemo.id,
                text: togglePlayButtonDemo.text,
                url: "",
                js: () => this.addPanel(togglePlayButtonDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: togglePlayButtonDemo }))
              },
              {
                id: badgeDemo.id,
                text: badgeDemo.text,
                url: "",
                js: () => this.addPanel(badgeDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: badgeDemo }))
              },
              {
                id: copyButtonDemo.id,
                text: copyButtonDemo.text,
                url: "",
                js: () => this.addPanel(copyButtonDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: copyButtonDemo }))
              },
              {
                id: spinnerDemo.id,
                text: spinnerDemo.text,
                url: "",
                js: () => this.addPanel(spinnerDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: spinnerDemo }))
              },
              {
                id: starsDemo.id,
                text: starsDemo.text,
                url: "",
                js: () => this.addPanel(starsDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: starsDemo }))
              },
              {
                id: editableLabelDemo.id,
                text: editableLabelDemo.text,
                url: "",
                js: () => this.addPanel(editableLabelDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: editableLabelDemo }))
              },
              {
                id: tooltipDemo.id,
                text: tooltipDemo.text,
                url: "",
                js: () => this.addPanel(tooltipDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: tooltipDemo }))
              }
            ]
          },
          {
            id: "navigation-demo",
            text: "Navigation",
            url: "",
            items: [
              {
                id: mobileSideMenuDemo.id,
                text: mobileSideMenuDemo.text,
                url: "",
                js: () => this.addPanel(mobileSideMenuDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: mobileSideMenuDemo }))
              },
              {
                id: responsiveFrameDemo.id,
                text: responsiveFrameDemo.text,
                url: "",
                js: () => this.addPanel(responsiveFrameDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: responsiveFrameDemo }))
              },
              {
                id: floatingIconMenuDemo.id,
                text: floatingIconMenuDemo.text,
                url: "",
                js: () => this.addPanel(floatingIconMenuDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: floatingIconMenuDemo }))
              },
              {
                id: breadcrumbsDemo.id,
                text: breadcrumbsDemo.text,
                url: "",
                js: () => this.addPanel(breadcrumbsDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: breadcrumbsDemo }))
              }
            ]
          },
          {
            id: "data-entry-demo",
            text: "Data Entry",
            url: "",
            items: [
              {
                id: inputWithTitleDemo.id,
                text: inputWithTitleDemo.text,
                url: "",
                js: () => this.addPanel(inputWithTitleDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: inputWithTitleDemo }))
              },
              {
                id: searchInputDemo.id,
                text: searchInputDemo.text,
                url: "",
                js: () => this.addPanel(searchInputDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: searchInputDemo }))
              },
              {
                id: tagInputDemo.id,
                text: tagInputDemo.text,
                url: "",
                js: () => this.addPanel(tagInputDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: tagInputDemo }))
              },
              {
                id: hEditorDemo.id,
                text: hEditorDemo.text,
                url: "",
                js: () => this.addPanel(hEditorDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: hEditorDemo }))
              },
              {
                id: iEditorDemo.id,
                text: iEditorDemo.text,
                url: "",
                js: () => this.addPanel(iEditorDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: iEditorDemo }))
              },
              {
                id: pEditorDemo.id,
                text: pEditorDemo.text,
                url: "",
                js: () => this.addPanel(pEditorDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: pEditorDemo }))
              },
              {
                id: pdfViewerDemo.id,
                text: pdfViewerDemo.text,
                url: "",
                js: () => this.addPanel(pdfViewerDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: pdfViewerDemo }))
              },
              {
                id: selectWithTitleDemo.id,
                text: selectWithTitleDemo.text,
                url: "",
                js: () => this.addPanel(selectWithTitleDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: selectWithTitleDemo }))
              },
              {
                id: rangeDemo.id,
                text: rangeDemo.text,
                url: "",
                js: () => this.addPanel(rangeDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: rangeDemo }))
              },
              {
                id: gaugeDemo.id,
                text: gaugeDemo.text,
                url: "",
                js: () => this.addPanel(gaugeDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: gaugeDemo }))
              },
              {
                id: radioLabelDemo.id,
                text: radioLabelDemo.text,
                url: "",
                js: () => this.addPanel(radioLabelDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: radioLabelDemo }))
              },
              {
                id: selectAngleDemo.id,
                text: selectAngleDemo.text,
                url: "",
                js: () => this.addPanel(selectAngleDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: selectAngleDemo }))
              },
              {
                id: switchOptionDemo.id,
                text: switchOptionDemo.text,
                url: "",
                js: () => this.addPanel(switchOptionDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: switchOptionDemo }))
              },
              {
                id: timePickerDemo.id,
                text: timePickerDemo.text,
                url: "",
                js: () => this.addPanel(timePickerDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: timePickerDemo }))
              },
              {
                id: datePickerDemo.id,
                text: datePickerDemo.text,
                url: "",
                js: () => this.addPanel(datePickerDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: datePickerDemo }))
              }
            ]
          },
          {
            id: "data-display-demo",
            text: "Data Display",
            url: "",
            items: [
              {
                id: pagingLinkDemo.id,
                text: pagingLinkDemo.text,
                url: "",
                js: () => this.addPanel(pagingLinkDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: pagingLinkDemo }))
              },
              {
                id: progressDemo.id,
                text: progressDemo.text,
                url: "",
                js: () => this.addPanel(progressDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: progressDemo }))
              },
              {
                id: radialProgressDemo.id,
                text: radialProgressDemo.text,
                url: "",
                js: () => this.addPanel(radialProgressDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: radialProgressDemo }))
              },
              {
                id: timelineDemo.id,
                text: timelineDemo.text,
                url: "",
                js: () => this.addPanel(timelineDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: timelineDemo }))
              },
              {
                id: skeletonDemo.id,
                text: skeletonDemo.text,
                url: "",
                js: () => this.addPanel(skeletonDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: skeletonDemo }))
              },
              {
                id: avatarDemo.id,
                text: avatarDemo.text,
                url: "",
                js: () => this.addPanel(avatarDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: avatarDemo }))
              },
              {
                id: cardDemo.id,
                text: cardDemo.text,
                url: "",
                js: () => this.addPanel(cardDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: cardDemo }))
              },
              {
                id: carouselDemo.id,
                text: carouselDemo.text,
                url: "",
                js: () => this.addPanel(carouselDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: carouselDemo }))
              },
              {
                id: cascaderDemo.id,
                text: cascaderDemo.text,
                url: "",
                js: () => this.addPanel(cascaderDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: cascaderDemo }))
              },
              {
                id: slideTabDemo.id,
                text: slideTabDemo.text,
                url: "",
                js: () => this.addPanel(slideTabDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: slideTabDemo }))
              },
              {
                id: qrcodeDemo.id,
                text: qrcodeDemo.text,
                url: "",
                js: () => this.addPanel(qrcodeDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: qrcodeDemo }))
              },
              {
                id: youtubePlayerDemo.id,
                text: youtubePlayerDemo.text,
                url: "",
                js: () => this.addPanel(youtubePlayerDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: youtubePlayerDemo }))
              }
            ]
          },
          {
            id: "feedback-demo",
            text: "Feedback",
            url: "",
            items: [
              {
                id: modalDemo.id,
                text: modalDemo.text,
                url: "",
                js: () => this.addPanel(modalDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: modalDemo }))
              },
              {
                id: messageBoxDemo.id,
                text: messageBoxDemo.text,
                url: "",
                js: () => this.addPanel(messageBoxDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: messageBoxDemo }))
              },
              {
                id: actionSheetDemo.id,
                text: actionSheetDemo.text,
                url: "",
                js: () => this.addPanel(actionSheetDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: actionSheetDemo }))
              },
              {
                id: popupMenuDemo.id,
                text: popupMenuDemo.text,
                url: "",
                js: () => this.addPanel(popupMenuDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: popupMenuDemo }))
              },
              {
                id: noticeMessageDemo.id,
                text: noticeMessageDemo.text,
                url: "",
                js: () => this.addPanel(noticeMessageDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: noticeMessageDemo }))
              },
              {
                id: tourDemo.id,
                text: tourDemo.text,
                url: "",
                js: () => this.addPanel(tourDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: tourDemo }))
              },
              {
                id: pullToRefreshDemo.id,
                text: pullToRefreshDemo.text,
                url: "",
                js: () => this.addPanel(pullToRefreshDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: pullToRefreshDemo }))
              }
            ]
          },
          {
            id: "layout-demo",
            text: "Layout",
            url: "",
            items: [
              {
                id: tabsDemo.id,
                text: tabsDemo.text,
                url: "",
                js: () => this.addPanel(tabsDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: tabsDemo }))
              },
              {
                id: resizableSplitterDemo.id,
                text: resizableSplitterDemo.text,
                url: "",
                js: () => this.addPanel(resizableSplitterDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: resizableSplitterDemo }))
              },
              {
                id: aspectRatioDemo.id,
                text: aspectRatioDemo.text,
                url: "",
                js: () => this.addPanel(aspectRatioDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: aspectRatioDemo }))
              },
              {
                id: sliderFrameDemo.id,
                text: sliderFrameDemo.text,
                url: "",
                js: () => this.addPanel(sliderFrameDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: sliderFrameDemo }))
              }
            ]
          },
          {
            id: "advanced-demo",
            text: "Special FX",
            url: "",
            items: [
              {
                id: mapWrapperDemo.id,
                text: mapWrapperDemo.text,
                url: "",
                js: () => this.addPanel(mapWrapperDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: mapWrapperDemo }))
              },
              {
                id: textWaveDemo.id,
                text: textWaveDemo.text,
                url: "",
                js: () => this.addPanel(textWaveDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: textWaveDemo }))
              },
              {
                id: textScaleDemo.id,
                text: textScaleDemo.text,
                url: "",
                js: () => this.addPanel(textScaleDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: textScaleDemo }))
              },
              {
                id: textGlowDemo.id,
                text: textGlowDemo.text,
                url: "",
                js: () => this.addPanel(textGlowDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: textGlowDemo }))
              },
              {
                id: redirectDemo.id,
                text: redirectDemo.text,
                url: "",
                js: () => this.addPanel(redirectDemo.text, /* @__PURE__ */ jsx(DemoPage, { story: redirectDemo }))
              }
            ]
          },
          {
            id: "help",
            text: "Help",
            url: "",
            items: [
              {
                id: "about",
                text: "About",
                url: "",
                js: () => this.addPanel("About", DemoAboutPage())
              }
            ]
          }
        ];
        hookBeforeShowMenu;
        // Set a hook to modify the admin top menu dynamically before it is shown
        setHookBeforeShowMenu(hook) {
          this.hookBeforeShowMenu = hook;
        }
        getDemoTopMenu() {
          if (this.hookBeforeShowMenu) {
            return this.hookBeforeShowMenu(this.demoTopMenu);
          }
          return this.demoTopMenu;
        }
        setDemoTopMenu(demoTopMenu) {
          this.demoTopMenu = demoTopMenu;
        }
        setChineseDemoTopMenu() {
          this.demoTopMenu.forEach((item) => {
            var _a;
            item.text = translateMenuToChinese(item.text);
            (_a = item.items) == null ? void 0 : _a.forEach((subItem) => {
              subItem.text = translateMenuToChinese(subItem.text);
            });
          });
        }
        mobileMenuMaxWidth = "700px";
        setMobileMenuMaxWidth(maxWidth) {
          this.mobileMenuMaxWidth = maxWidth;
        }
        getMobileMenuMaxWidth() {
          return this.mobileMenuMaxWidth;
        }
        insertMenuItem(item, beforeMenuId) {
          let index = -1;
          if (beforeMenuId) {
            index = this.demoTopMenu.findIndex((m) => m.id === beforeMenuId);
          }
          if (index !== -1) {
            this.demoTopMenu.splice(index, 0, ...item);
          } else {
            this.demoTopMenu.push(...item);
          }
        }
        insertSubMenuItem(item, beforeMenuId, beforeSubMenuId) {
          const index = this.demoTopMenu.findIndex((m) => m.id === beforeMenuId);
          if (index !== -1) {
            const subMenu = this.demoTopMenu[index].items || [];
            const subIndex = subMenu.findIndex((s) => s.id === beforeSubMenuId);
            if (subIndex !== -1) {
              subMenu.splice(subIndex, 0, ...item);
            } else {
              subMenu.push(...item);
            }
          }
        }
        getMenuItem(menuId) {
          const index = this.demoTopMenu.findIndex((m) => m.id === menuId);
          if (index !== -1) {
            return this.demoTopMenu[index];
          }
          return null;
        }
        getSubMenuItem(menuId, subMenuId) {
          const index = this.demoTopMenu.findIndex((m) => m.id === menuId);
          if (index !== -1) {
            const subMenu = this.demoTopMenu[index].items || [];
            const subIndex = subMenu.findIndex((s) => s.id === subMenuId);
            if (subIndex !== -1) {
              return subMenu[subIndex];
            }
          }
          return null;
        }
        refUpdate = this.getTabsHook();
        async addPanel(title, page) {
          if (this.getTabsHook().getCount() > this.getMaxTabsCount()) {
            alert("You are opening too many pages");
            return;
          }
          if (this.getTabsHook().findAndActivate(title)) {
            return;
          }
          await this.getTabsHook().newPage(title, page);
        }
      };
      demoFrameHelper = /* @__PURE__ */ new DemoFrameHelper();
    }
  });

  // node_modules/lupine.components/src/demo/demo-frame.tsx
  var DemoFrame;
  var init_demo_frame = __esm({
    "node_modules/lupine.components/src/demo/demo-frame.tsx"() {
      init_src2();
      init_src2();
      init_demo_css();
      init_demo_frame_helper();
      init_jsx_runtime();
      DemoFrame = (props) => {
        const refUpdate = demoFrameHelper.getTabsHook();
        const maxWidthMobileMenu = demoFrameHelper.getMobileMenuMaxWidth();
        const css2 = {
          backgroundColor: "var(--primary-bg-color)",
          color: "var(--primary-color)",
          ...demoCss,
          display: "flex",
          flexDirection: "column",
          // padding: '10px',
          width: "100%",
          height: "100%",
          minHeight: "100%",
          overflowY: "auto",
          ".f-header": {
            display: "flex",
            alignItems: "center",
            padding: "4px 16px 4px 0px",
            fontSize: "80%"
          },
          ".top-logo": {
            marginLeft: "16px",
            marginRight: "16px"
          },
          ".top-title": {
            flex: "1",
            fontSize: "160%",
            margin: "auto"
          },
          ".top-menu": {
            display: "flex"
          },
          ".top-menu .item": {
            padding: "0px 2px"
          },
          ".f-body": {
            flex: "1",
            display: "flex",
            borderTop: "var(--primary-border)",
            minHeight: "0"
          },
          ".body-menu": {
            width: "165px",
            // padding: '8px 16px',
            borderRight: "var(--primary-border)",
            overflowX: "hidden",
            overflowY: "auto",
            color: "var(--sidebar-color)",
            backgroundColor: "var(--sidebar-bg-color)"
          },
          ".close-menu-icon": {
            position: "relative"
          },
          ".close-menu-icon.hide + .body-menu": {
            display: "none"
          },
          ".close-menu-icon::after": {
            content: '""',
            position: "absolute",
            top: "-13px",
            left: "-1px",
            transform: "rotate(90deg)",
            width: "0",
            height: "0",
            borderLeft: "7px solid transparent",
            borderRight: "7px solid transparent",
            borderTop: "7px solid var(--primary-color)",
            transition: "all 300ms ease-in-out",
            zIndex: "var(--layer-sidebar)"
          },
          ["@media only screen and (max-width: " + maxWidthMobileMenu + ")"]: {
            ".body-menu, .close-menu-icon": {
              display: "none"
            }
          },
          ".body-content": {
            flex: "1",
            overflowX: "auto"
            // padding: '8px 16px',
          },
          ".body-tabs": {
            height: "100%"
          },
          ...props.css
        };
        bindGlobalStyle("demo-frame-box", css2);
        const pages = [];
        const refCloseMenu = {};
        const demoTopMenu = demoFrameHelper.getDemoTopMenu();
        const onCloseMenuClick = () => {
          refCloseMenu.current.classList.toggle("hide");
        };
        return /* @__PURE__ */ jsx("div", { class: "demo-frame-box", children: [
          /* @__PURE__ */ jsx("div", { class: "f-header", children: [
            /* @__PURE__ */ jsx(
              MenuSidebar,
              {
                items: demoTopMenu,
                maxWidthMobileMenu,
                color: "var(--sidebar-color)",
                backgroundColor: "var(--sidebar-bg-color)",
                mobileMenu: true
              }
            ),
            /* @__PURE__ */ jsx("div", { class: "top-logo", children: "Lupine.js" }),
            /* @__PURE__ */ jsx("div", { class: "top-title", children: props.title }),
            /* @__PURE__ */ jsx("div", { class: "top-menu", children: /* @__PURE__ */ jsx(ThemeSelector, {}) })
          ] }),
          /* @__PURE__ */ jsx("div", { class: "f-body", children: [
            /* @__PURE__ */ jsx("div", { ref: refCloseMenu, class: "close-menu-icon", onClick: onCloseMenuClick, title: "Hide / Show Side Menu" }),
            /* @__PURE__ */ jsx("div", { class: "body-menu", children: /* @__PURE__ */ jsx(
              MenuSidebar,
              {
                items: demoTopMenu,
                maxWidthMobileMenu,
                color: "var(--sidebar-color)",
                backgroundColor: "var(--sidebar-bg-color)",
                desktopMenu: true
              }
            ) }),
            /* @__PURE__ */ jsx("div", { class: "body-content", children: /* @__PURE__ */ jsx("div", { class: "body-tabs", children: /* @__PURE__ */ jsx(Tabs, { pages, hook: refUpdate, pagePadding: "8px" }) }) })
          ] })
        ] });
      };
    }
  });

  // node_modules/lupine.components/src/demo/demo-registry.ts
  var demoRegistry;
  var init_demo_registry = __esm({
    "node_modules/lupine.components/src/demo/demo-registry.ts"() {
      init_button_demo();
      init_button_push_animation_demo();
      init_input_number_demo();
      init_toggle_switch_demo();
      init_spinner_demo();
      init_stars_component_demo();
      init_editable_label_demo();
      init_progress_demo();
      init_radio_label_demo();
      init_select_angle_demo();
      init_switch_option_demo();
      init_action_sheet_demo();
      init_select_with_title_demo();
      init_input_with_title_demo();
      init_tabs_demo();
      init_modal_demo();
      init_popup_menu_demo();
      init_notice_message_demo();
      init_resizable_splitter_demo();
      init_redirect_demo();
      init_text_wave_demo();
      init_text_scale_demo();
      init_text_glow_demo();
      init_toggle_play_button_demo();
      init_toggle_button_demo();
      init_message_box_demo();
      init_mobile_side_menu_demo();
      init_responsive_frame_demo();
      init_slider_frame_demo();
      init_carousel2();
      init_range2();
      init_cascader2();
      init_badge2();
      init_timeline2();
      init_tooltip2();
      init_radial_progress2();
      init_breadcrumbs2();
      init_skeleton2();
      init_copy_button2();
      init_aspect_ratio2();
      init_map_wrapper2();
      init_avatar2();
      init_card2();
      init_time_picker2();
      init_date_picker2();
      init_pull_to_refresh_demo();
      init_tag_input_demo();
      init_floating_icon_menu2();
      init_tour2();
      init_search_input2();
      init_paging_link_demo();
      init_h_editor2();
      init_slide_tab_component_demo();
      init_qrcode2();
      init_i_editor2();
      init_youtube_player2();
      init_p_editor2();
      init_pdf_viewer2();
      demoRegistry = {
        [buttonDemo.id]: buttonDemo,
        [buttonPushAnimationDemo.id]: buttonPushAnimationDemo,
        [inputNumberDemo.id]: inputNumberDemo,
        [toggleSwitchDemo.id]: toggleSwitchDemo,
        [spinnerDemo.id]: spinnerDemo,
        [starsDemo.id]: starsDemo,
        [editableLabelDemo.id]: editableLabelDemo,
        [progressDemo.id]: progressDemo,
        [radioLabelDemo.id]: radioLabelDemo,
        [selectAngleDemo.id]: selectAngleDemo,
        [switchOptionDemo.id]: switchOptionDemo,
        [actionSheetDemo.id]: actionSheetDemo,
        [mobileSideMenuDemo.id]: mobileSideMenuDemo,
        [responsiveFrameDemo.id]: responsiveFrameDemo,
        [tagInputDemo.id]: tagInputDemo,
        [selectWithTitleDemo.id]: selectWithTitleDemo,
        [inputWithTitleDemo.id]: inputWithTitleDemo,
        [tabsDemo.id]: tabsDemo,
        [modalDemo.id]: modalDemo,
        [popupMenuDemo.id]: popupMenuDemo,
        [noticeMessageDemo.id]: noticeMessageDemo,
        [resizableSplitterDemo.id]: resizableSplitterDemo,
        [redirectDemo.id]: redirectDemo,
        [textWaveDemo.id]: textWaveDemo,
        [textScaleDemo.id]: textScaleDemo,
        [textGlowDemo.id]: textGlowDemo,
        [togglePlayButtonDemo.id]: togglePlayButtonDemo,
        [toggleButtonDemo.id]: toggleButtonDemo,
        [messageBoxDemo.id]: messageBoxDemo,
        [sliderFrameDemo.id]: sliderFrameDemo,
        [rangeDemo.id]: rangeDemo,
        [gaugeDemo.id]: gaugeDemo,
        [badgeDemo.id]: badgeDemo,
        [timelineDemo.id]: timelineDemo,
        [radialProgressDemo.id]: radialProgressDemo,
        [breadcrumbsDemo.id]: breadcrumbsDemo,
        [skeletonDemo.id]: skeletonDemo,
        [copyButtonDemo.id]: copyButtonDemo,
        [aspectRatioDemo.id]: aspectRatioDemo,
        [mapWrapperDemo.id]: mapWrapperDemo,
        [avatarDemo.id]: avatarDemo,
        [cardDemo.id]: cardDemo,
        [cascaderDemo.id]: cascaderDemo,
        [carouselDemo.id]: carouselDemo,
        [tooltipDemo.id]: tooltipDemo,
        [timePickerDemo.id]: timePickerDemo,
        [datePickerDemo.id]: datePickerDemo,
        [pullToRefreshDemo.id]: pullToRefreshDemo,
        [floatingIconMenuDemo.id]: floatingIconMenuDemo,
        [tourDemo.id]: tourDemo,
        [searchInputDemo.id]: searchInputDemo,
        [pagingLinkDemo.id]: pagingLinkDemo,
        [hEditorDemo.id]: hEditorDemo,
        [slideTabDemo.id]: slideTabDemo,
        [qrcodeDemo.id]: qrcodeDemo,
        [iEditorDemo.id]: iEditorDemo,
        [youtubePlayerDemo.id]: youtubePlayerDemo,
        [pEditorDemo.id]: pEditorDemo,
        [pdfViewerDemo.id]: pdfViewerDemo
      };
    }
  });

  // node_modules/lupine.components/src/demo/mock/demo-icons.ts
  var demoIcons, demoIconsCss;
  var init_demo_icons = __esm({
    "node_modules/lupine.components/src/demo/mock/demo-icons.ts"() {
      demoIcons = {
        "bs-list": `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='none' stroke='black' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M4 6h16M4 12h16M4 18h16'/%3E%3C/svg%3E`,
        "ma-home-outline": `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='none' stroke='black' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z'/%3E%3Cpath fill='none' stroke='black' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M9 22V12h6v10'/%3E%3C/svg%3E`,
        "ma-tools": `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='none' stroke='black' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z'/%3E%3C/svg%3E`,
        "co-cil-chat-bubble": `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='none' stroke='black' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z'/%3E%3C/svg%3E`,
        "ma-crown-outline": `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='none' stroke='black' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M2 4l3 7 7-6 7 6 3-7v14H2V4z'/%3E%3C/svg%3E`,
        "ma-account-cog-outline": `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='none' stroke='black' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2'/%3E%3Ccircle cx='12' cy='7' r='4' fill='none' stroke='black' stroke-width='1.5'/%3E%3C/svg%3E`,
        "ma-chevron-right": `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='none' stroke='black' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M9 18l6-6-6-6'/%3E%3C/svg%3E`,
        "ma-email-outline": `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='none' stroke='black' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z'/%3E%3Cpath fill='none' stroke='black' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M22 6l-10 7L2 6'/%3E%3C/svg%3E`,
        "ma-logout": `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='none' stroke='black' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4M16 17l5-5-5-5M21 12H9'/%3E%3C/svg%3E`,
        "mg-arrow_back_ios_new_outlined": `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='none' stroke='black' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M15 18l-6-6 6-6'/%3E%3C/svg%3E`,
        "ma-close": `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='none' stroke='black' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M18 6L6 18M6 6l12 12'/%3E%3C/svg%3E`,
        "ma-add": `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='none' stroke='black' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M12 5v14M5 12h14'/%3E%3C/svg%3E`,
        "bs-search": `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='none' stroke='black' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z'/%3E%3C/svg%3E`,
        "ma-pencil-outline": `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='none' stroke='black' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z'/%3E%3C/svg%3E`
      };
      demoIconsCss = {
        ".ifc-icon": {
          display: "inline-block",
          width: "24px",
          height: "24px",
          maskRepeat: "no-repeat",
          maskPosition: "center",
          maskSize: "contain",
          WebkitMaskRepeat: "no-repeat",
          WebkitMaskPosition: "center",
          WebkitMaskSize: "contain",
          backgroundColor: "currentColor"
        },
        ".ifc-icon.bs-list": {
          // Make sure it takes the intended color (using CSS mask if we wanted variable colors,
          // but since stroke is currentColor in the SVG, if we want it to adapt color properly
          // without JS, mask-image is best. Let's use mask-image for better theming.)
          maskImage: `url("${demoIcons["bs-list"]}")`
        },
        ".ifc-icon.ma-home-outline": {
          maskImage: `url("${demoIcons["ma-home-outline"]}")`
        },
        ".ifc-icon.ma-tools": {
          maskImage: `url("${demoIcons["ma-tools"]}")`
        },
        ".ifc-icon.co-cil-chat-bubble": {
          maskImage: `url("${demoIcons["co-cil-chat-bubble"]}")`
        },
        ".ifc-icon.ma-crown-outline": {
          maskImage: `url("${demoIcons["ma-crown-outline"]}")`
        },
        ".ifc-icon.ma-account-cog-outline": {
          maskImage: `url("${demoIcons["ma-account-cog-outline"]}")`
        },
        ".ifc-icon.ma-chevron-right": {
          maskImage: `url("${demoIcons["ma-chevron-right"]}")`
        },
        ".ifc-icon.ma-email-outline": {
          maskImage: `url("${demoIcons["ma-email-outline"]}")`
        },
        ".ifc-icon.ma-logout": {
          maskImage: `url("${demoIcons["ma-logout"]}")`
        },
        ".ifc-icon.mg-arrow_back_ios_new_outlined": {
          maskImage: `url("${demoIcons["mg-arrow_back_ios_new_outlined"]}")`
        },
        ".ifc-icon.ma-close": {
          maskImage: `url("${demoIcons["ma-close"]}")`
        },
        ".ifc-icon.ma-add": {
          maskImage: `url("${demoIcons["ma-add"]}")`
        },
        ".ifc-icon.bs-search": {
          maskImage: `url("${demoIcons["bs-search"]}")`
        },
        ".ifc-icon.ma-pencil-outline": {
          maskImage: `url("${demoIcons["ma-pencil-outline"]}")`
        }
      };
    }
  });

  // node_modules/lupine.components/src/demo/demo-render-page.tsx
  var DemoRenderPage;
  var init_demo_render_page = __esm({
    "node_modules/lupine.components/src/demo/demo-render-page.tsx"() {
      init_src2();
      init_demo_registry();
      init_demo_icons();
      init_jsx_runtime();
      DemoRenderPage = async (props) => {
        const dom = new HtmlVar(
          /* @__PURE__ */ jsx(
            "div",
            {
              class: "demo-render-page-loading",
              css: {
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                width: "100%",
                height: "100vh",
                color: "var(--text-color, #333)"
              },
              children: "Loading component preview..."
            }
          )
        );
        if (isFrontEnd2()) {
          const urlParams = new URL(window.location.href).searchParams;
          const id = urlParams.get("id");
          const story = id ? demoRegistry[id] : null;
          if (story) {
            const renderContent = (args, showCode) => {
              if (showCode && story.code) {
                return /* @__PURE__ */ jsx(
                  "pre",
                  {
                    style: {
                      margin: 0,
                      padding: "20px",
                      backgroundColor: "#f5f5f5",
                      width: "100%",
                      height: "100%",
                      overflow: "auto"
                    },
                    class: "demo-render-page-code",
                    children: /* @__PURE__ */ jsx("code", { children: encodeHtml(story.code) })
                  }
                );
              } else if (showCode && !story.code) {
                return /* @__PURE__ */ jsx("div", { class: "demo-render-page-no-code", children: "Code snippet not available for this demo." });
              }
              return story.render(args);
            };
            window._lj_demo_hook = {
              updateArgs: (newArgs, showCode = false) => {
                dom.value = renderContent(newArgs, showCode);
              }
            };
          } else {
            dom.value = /* @__PURE__ */ jsx("div", { class: "demo-render-page-not-found", children: "Component not found" });
          }
        }
        const css2 = {
          width: "100%",
          height: "100%",
          // Reset any body margins if they exist, though typically handled by global css
          margin: 0,
          boxSizing: "border-box",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          // Center components by default
          overflow: "auto",
          ">fragment>div": {
            width: "100%",
            height: "100%"
          },
          ...demoIconsCss
        };
        return /* @__PURE__ */ jsx("div", { css: css2, class: "demo-render-page", children: dom.node });
      };
    }
  });

  // node_modules/lupine.components/src/demo/demo-index.tsx
  var DemoIndexPage, demoPageRouter;
  var init_demo_index = __esm({
    "node_modules/lupine.components/src/demo/demo-index.tsx"() {
      init_src2();
      init_demo_frame();
      init_demo_render_page();
      init_jsx_runtime();
      DemoIndexPage = async (props) => {
        if (props.query.id) {
          return /* @__PURE__ */ jsx(DemoRenderPage, { ...props });
        }
        return /* @__PURE__ */ jsx(DemoFrame, { title: "Components Demo" });
      };
      demoPageRouter = new PageRouter();
      demoPageRouter.use("/render", DemoRenderPage);
      demoPageRouter.use("/*", DemoIndexPage);
    }
  });

  // node_modules/lupine.components/src/demo/demo-types.ts
  var init_demo_types = __esm({
    "node_modules/lupine.components/src/demo/demo-types.ts"() {
    }
  });

  // node_modules/lupine.components/src/demo/index.ts
  var init_demo = __esm({
    "node_modules/lupine.components/src/demo/index.ts"() {
      init_demo_about();
      init_demo_container();
      init_demo_css();
      init_demo_frame();
      init_demo_frame_helper();
      init_demo_index();
      init_demo_page();
      init_demo_registry();
      init_demo_render_page();
      init_demo_types();
    }
  });

  // node_modules/lupine.components/src/component-pool/pull-to-refresh/index.ts
  var init_pull_to_refresh2 = __esm({
    "node_modules/lupine.components/src/component-pool/pull-to-refresh/index.ts"() {
      init_pull_to_refresh();
    }
  });

  // node_modules/lupine.components/src/component-pool/tag-input/index.ts
  var init_tag_input2 = __esm({
    "node_modules/lupine.components/src/component-pool/tag-input/index.ts"() {
      init_tag_input();
      init_tag_input_demo();
    }
  });

  // node_modules/lupine.components/src/component-pool/index.ts
  var init_component_pool = __esm({
    "node_modules/lupine.components/src/component-pool/index.ts"() {
      init_aspect_ratio2();
      init_avatar2();
      init_badge2();
      init_breadcrumbs2();
      init_card2();
      init_carousel2();
      init_cascader2();
      init_copy_button2();
      init_date_picker2();
      init_floating_icon_menu2();
      init_h_editor2();
      init_i_editor2();
      init_map_wrapper2();
      init_p_editor2();
      init_pdf_viewer2();
      init_pull_to_refresh2();
      init_qrcode2();
      init_radial_progress2();
      init_range2();
      init_search_input2();
      init_skeleton2();
      init_tag_input2();
      init_time_picker2();
      init_timeline2();
      init_tooltip2();
      init_tour2();
      init_youtube_player2();
    }
  });

  // node_modules/lupine.components/src/index.ts
  var src_exports = {};
  __export(src_exports, {
    ActionSheet: () => ActionSheet,
    ActionSheetInput: () => ActionSheetInput,
    ActionSheetInputPromise: () => ActionSheetInputPromise,
    ActionSheetMessage: () => ActionSheetMessage,
    ActionSheetMessagePromise: () => ActionSheetMessagePromise,
    ActionSheetMultiSelectPromise: () => ActionSheetMultiSelectPromise,
    ActionSheetSelect: () => ActionSheetSelect,
    ActionSheetSelectOptionsProps: () => ActionSheetSelectOptionsProps,
    ActionSheetSelectPromise: () => ActionSheetSelectPromise,
    AspectRatio: () => AspectRatio,
    Avatar: () => Avatar,
    AvatarGroup: () => AvatarGroup,
    Badge: () => Badge,
    Base62: () => Base62,
    Breadcrumbs: () => Breadcrumbs,
    Button: () => Button,
    ButtonPushAnimation: () => ButtonPushAnimation,
    ButtonPushAnimationSize: () => ButtonPushAnimationSize,
    ButtonSize: () => ButtonSize,
    Card: () => Card,
    Carousel: () => Carousel,
    Cascader: () => Cascader,
    ConsoleColors: () => ConsoleColors,
    CopyButton: () => CopyButton,
    DatePicker: () => DatePicker,
    DateUtils: () => DateUtils,
    DemoAboutPage: () => DemoAboutPage,
    DemoContainer: () => DemoContainer,
    DemoFrame: () => DemoFrame,
    DemoFrameHelper: () => DemoFrameHelper,
    DemoIndexPage: () => DemoIndexPage,
    DemoPage: () => DemoPage,
    DemoRenderPage: () => DemoRenderPage,
    DiffDate: () => DiffDate,
    DocumentReady: () => DocumentReady,
    DomUtils: () => DomUtils,
    DragFresh: () => DragFresh,
    DynamicalLoad: () => DynamicalLoad,
    EditableLabel: () => EditableLabel,
    FloatWindow: () => FloatWindow,
    FloatingIconMenu: () => FloatingIconMenu,
    Gauge: () => Gauge,
    Grid: () => Grid,
    HANDLE_SIZE: () => HANDLE_SIZE2,
    HEditor: () => HEditor,
    HEditorLangCn: () => HEditorLangCn,
    HEditorLangEn: () => HEditorLangEn,
    HeaderWithBackFrame: () => HeaderWithBackFrame,
    HeaderWithBackFrameEmpty: () => HeaderWithBackFrameEmpty,
    HeaderWithBackFrameHeight: () => HeaderWithBackFrameHeight,
    HeaderWithBackFrameLeft: () => HeaderWithBackFrameLeft,
    HeaderWithBackFrameRight: () => HeaderWithBackFrameRight,
    HtmlLoad: () => HtmlLoad,
    HtmlVar: () => HtmlVar,
    IEditor: () => IEditor,
    InputWithTitle: () => InputWithTitle,
    LinkItem: () => LinkItem,
    LinkList: () => LinkList,
    LiteDom: () => LiteDom,
    Logger: () => Logger,
    MapWrapper: () => MapWrapper,
    MediaQueryDirection: () => MediaQueryDirection,
    MediaQueryMaxWidth: () => MediaQueryMaxWidth,
    MediaQueryRange: () => MediaQueryRange,
    MenuBar: () => MenuBar,
    MenuSidebar: () => MenuSidebar,
    MessageBox: () => MessageBox,
    MessageBoxButtonProps: () => MessageBoxButtonProps,
    MessageHub: () => MessageHub,
    MessageHubData: () => MessageHubData,
    MetaData: () => MetaData,
    MetaDescription: () => MetaDescription,
    MobileFooterMenu: () => MobileFooterMenu,
    MobileHeadeBackIcon: () => MobileHeadeBackIcon,
    MobileHeadeCloseIcon: () => MobileHeadeCloseIcon,
    MobileHeadeIconHeight: () => MobileHeadeIconHeight,
    MobileHeaderCenter: () => MobileHeaderCenter,
    MobileHeaderComponent: () => MobileHeaderComponent,
    MobileHeaderEmptyIcon: () => MobileHeaderEmptyIcon,
    MobileHeaderHelper: () => MobileHeaderHelper,
    MobileHeaderHide: () => MobileHeaderHide,
    MobileHeaderLeft: () => MobileHeaderLeft,
    MobileHeaderRight: () => MobileHeaderRight,
    MobileHeaderTitleIcon: () => MobileHeaderTitleIcon,
    MobileSideMenu: () => MobileSideMenu,
    MobileSideMenuHelper: () => MobileSideMenuHelper,
    MobileTopSysIcon: () => MobileTopSysIcon,
    MobileTopSysMenu: () => MobileTopSysMenu,
    ModalWindow: () => ModalWindow,
    NotificationColor: () => NotificationColor,
    NotificationMessage: () => NotificationMessage,
    Observable: () => Observable,
    PEditor: () => PEditor,
    PageRouter: () => PageRouter,
    PageTitle: () => PageTitle,
    PagingLink: () => PagingLink,
    Panel: () => Panel,
    PdfViewer: () => PdfViewer,
    PopupMenu: () => PopupMenu,
    PopupMenuWithButton: () => PopupMenuWithButton,
    PopupMenuWithIcon: () => PopupMenuWithIcon,
    PopupMenuWithLabel: () => PopupMenuWithLabel,
    Progress: () => Progress,
    PullToRefresh: () => PullToRefresh,
    QRCode: () => QRCode,
    RadialProgress: () => RadialProgress,
    RadioLabelComponent: () => RadioLabelComponent,
    Range: () => Range,
    Redirect: () => Redirect,
    ResizableSplitter: () => ResizableSplitter,
    ResponsiveFrame: () => ResponsiveFrame,
    SearchInput: () => SearchInput,
    SelectAngleComponent: () => SelectAngleComponent,
    SelectWithTitle: () => SelectWithTitle,
    SimpleStorage: () => SimpleStorage,
    Skeleton: () => Skeleton,
    SkeletonCard: () => SkeletonCard,
    SlideTabComponent: () => SlideTabComponent,
    SliderFrame: () => SliderFrame2,
    Spinner01: () => Spinner01,
    Spinner02: () => Spinner02,
    Spinner03: () => Spinner03,
    SpinnerSize: () => SpinnerSize,
    StarsComponent: () => StarsComponent,
    Subject: () => Subject,
    Subscription: () => Subscription,
    Svg: () => Svg,
    SwitchOptionComponent: () => SwitchOptionComponent,
    Tabs: () => Tabs,
    TagInput: () => TagInput,
    TextGlow: () => TextGlow,
    TextScale: () => TextScale,
    TextWave: () => TextWave,
    ThemeSelector: () => ThemeSelector,
    TimePicker: () => TimePicker,
    Timeline: () => Timeline,
    ToggleBase: () => ToggleBase,
    ToggleBaseSize: () => ToggleBaseSize,
    ToggleButton: () => ToggleButton,
    TogglePlayButton: () => TogglePlayButton,
    TogglePlayButtonSize: () => TogglePlayButtonSize,
    ToggleSwitch: () => ToggleSwitch,
    ToggleSwitchSize: () => ToggleSwitchSize,
    ToggleWaveFrame: () => ToggleWaveFrame,
    Tooltip: () => Tooltip,
    TooltipHelper: () => TooltipHelper,
    TopFrame: () => TopFrame,
    Tour: () => Tour,
    WebConfig: () => WebConfig,
    YouTubePlayer: () => YouTubePlayer,
    _lupineJs: () => _lupineJs,
    addMetaDataTags: () => addMetaDataTags,
    adjustedMediaQueryRange: () => adjustedMediaQueryRange,
    appData: () => appData,
    aspectRatioDemo: () => aspectRatioDemo,
    avatarDemo: () => avatarDemo,
    backActionHelper: () => backActionHelper,
    backActionUniqueId: () => backActionUniqueId,
    badgeDemo: () => badgeDemo,
    base64ToUrl: () => base64ToUrl,
    baseThemes: () => baseThemes,
    bindAppGlobalStyle: () => bindAppGlobalStyle,
    bindAttributes: () => bindAttributes,
    bindAttributesChildren: () => bindAttributesChildren,
    bindGlobalStyle: () => bindGlobalStyle,
    bindLang: () => bindLang,
    bindLinks: () => bindLinks,
    bindPageLoadedEvent: () => bindPageLoadedEvent,
    bindRef: () => bindRef,
    bindRenderPageFunctions: () => bindRenderPageFunctions,
    bindRequestContext: () => bindRequestContext,
    bindRouter: () => bindRouter,
    bindTheme: () => bindTheme,
    bindWebConfigApi: () => bindWebConfigApi,
    blobFromBase64: () => blobFromBase64,
    blobToBase64: () => blobToBase64,
    breadcrumbsDemo: () => breadcrumbsDemo,
    calculateTextWidth: () => calculateTextWidth,
    callPageLoadedEvent: () => callPageLoadedEvent,
    callUnload: () => callUnload,
    camelToHyphens: () => camelToHyphens,
    cardDemo: () => cardDemo,
    carouselDemo: () => carouselDemo,
    cascaderDemo: () => cascaderDemo,
    checkUploadedFileSize: () => checkUploadedFileSize,
    clearCookie: () => clearCookie,
    cloneJson: () => cloneJson,
    cookie: () => cookie,
    copyButtonDemo: () => copyButtonDemo,
    createDragUtil: () => createDragUtil,
    darkThemes: () => darkThemes,
    datePickerDemo: () => datePickerDemo,
    debugWatch: () => debugWatch,
    decodeHtml: () => decodeHtml,
    deepMerge: () => deepMerge,
    defaultLang: () => defaultLang,
    defaultTheme: () => defaultTheme,
    demoCss: () => demoCss,
    demoFrameHelper: () => demoFrameHelper,
    demoPageRouter: () => demoPageRouter,
    demoRegistry: () => demoRegistry,
    disableConsole: () => disableConsole,
    disableDebug: () => disableDebug,
    domUniqueId: () => domUniqueId,
    downloadFile: () => downloadFile,
    downloadFileChunk: () => downloadFileChunk,
    downloadLink: () => downloadLink,
    downloadStream: () => downloadStream,
    encodeHtml: () => encodeHtml,
    findParentTag: () => findParentTag,
    floatingIconMenuDemo: () => floatingIconMenuDemo,
    floatingIconMenuMainBtnMock: () => floatingIconMenuMainBtnMock,
    floatingIconMenuOptionsMock: () => floatingIconMenuOptionsMock,
    formatBytes: () => formatBytes,
    gaugeDemo: () => gaugeDemo,
    generateAllGlobalStyles: () => generateAllGlobalStyles,
    getCookie: () => getCookie,
    getCurrentLang: () => getCurrentLang,
    getCurrentTheme: () => getCurrentTheme,
    getDefaultPageLimit: () => getDefaultPageLimit,
    getDownloadChunkSize: () => getDownloadChunkSize,
    getEitherCookie: () => getEitherCookie,
    getGlobalStylesId: () => getGlobalStylesId,
    getMetaDataObject: () => getMetaDataObject,
    getMetaDataTags: () => getMetaDataTags,
    getPageTitle: () => getPageTitle,
    getRenderPageProps: () => getRenderPageProps,
    getRequestContext: () => getRequestContext,
    getServerCookie: () => getServerCookie,
    getUploadChunkSize: () => getUploadChunkSize,
    globalStyleUniqueId: () => globalStyleUniqueId,
    hEditorDemo: () => hEditorDemo,
    hEditorUniqueId: () => hEditorUniqueId,
    iEditorDemo: () => iEditorDemo,
    initServerCookies: () => initServerCookies,
    initWebEnv: () => initWebEnv,
    initializeApp: () => initializeApp,
    initializePage: () => initializePage2,
    isFrontEnd: () => isFrontEnd2,
    langCookieName: () => langCookieName,
    lightThemes: () => lightThemes,
    loadPdfScripts: () => loadPdfScripts,
    mapWrapperDemo: () => mapWrapperDemo,
    mobileHeaderHelper: () => mobileHeaderHelper,
    mountInnerComponent: () => mountInnerComponent,
    mountOuterComponent: () => mountOuterComponent,
    mountSiblingComponent: () => mountSiblingComponent,
    notificationColorFromValue: () => notificationColorFromValue,
    pEditorDemo: () => pEditorDemo,
    pathUtils: () => pathUtils,
    pdfViewerDemo: () => pdfViewerDemo,
    processStyle: () => processStyle,
    promiseTimeout: () => promiseTimeout,
    qrcodeDemo: () => qrcodeDemo,
    radialProgressDemo: () => radialProgressDemo,
    rangeDemo: () => rangeDemo,
    renderComponentAsync: () => renderComponentAsync,
    replaceInnerhtml: () => replaceInnerhtml,
    searchInputDemo: () => searchInputDemo,
    setCookie: () => setCookie,
    setDefaultPageLimit: () => setDefaultPageLimit,
    setDefaultPageTitle: () => setDefaultPageTitle,
    setDownloadChunkSize: () => setDownloadChunkSize,
    setPageTitle: () => setPageTitle,
    setRenderPageProps: () => setRenderPageProps,
    setUploadChunkSize: () => setUploadChunkSize,
    sharedThemes: () => sharedThemes,
    skeletonDemo: () => skeletonDemo,
    stopPropagation: () => stopPropagation,
    tagInputDemo: () => tagInputDemo,
    themeAttributeName: () => themeAttributeName,
    themeCookieName: () => themeCookieName,
    timePickerDemo: () => timePickerDemo,
    timelineDemo: () => timelineDemo,
    tooltipDemo: () => tooltipDemo,
    tourDemo: () => tourDemo,
    uniqueIdGenerator: () => uniqueIdGenerator,
    updateLang: () => updateLang,
    updateLangEventName: () => updateLangEventName,
    updateStyles: () => updateStyles,
    updateTheme: () => updateTheme,
    updateThemeEventName: () => updateThemeEventName,
    uploadFile: () => uploadFile,
    uploadFileChunk: () => uploadFileChunk,
    webEnv: () => webEnv,
    youtubePlayerDemo: () => youtubePlayerDemo
  });
  var init_src2 = __esm({
    "node_modules/lupine.components/src/index.ts"() {
      init_src();
      init_lib2();
      init_styles2();
      init_components();
      init_frames();
      init_demo();
      init_component_pool();
    }
  });

  // (disabled):fs
  var require_fs = __commonJS({
    "(disabled):fs"() {
    }
  });

  // node_modules/kind-of/index.js
  var require_kind_of = __commonJS({
    "node_modules/kind-of/index.js"(exports2, module2) {
      var toString = Object.prototype.toString;
      module2.exports = function kindOf(val) {
        if (val === void 0) return "undefined";
        if (val === null) return "null";
        var type = typeof val;
        if (type === "boolean") return "boolean";
        if (type === "string") return "string";
        if (type === "number") return "number";
        if (type === "symbol") return "symbol";
        if (type === "function") {
          return isGeneratorFn(val) ? "generatorfunction" : "function";
        }
        if (isArray(val)) return "array";
        if (isBuffer(val)) return "buffer";
        if (isArguments(val)) return "arguments";
        if (isDate(val)) return "date";
        if (isError(val)) return "error";
        if (isRegexp(val)) return "regexp";
        switch (ctorName(val)) {
          case "Symbol":
            return "symbol";
          case "Promise":
            return "promise";
          // Set, Map, WeakSet, WeakMap
          case "WeakMap":
            return "weakmap";
          case "WeakSet":
            return "weakset";
          case "Map":
            return "map";
          case "Set":
            return "set";
          // 8-bit typed arrays
          case "Int8Array":
            return "int8array";
          case "Uint8Array":
            return "uint8array";
          case "Uint8ClampedArray":
            return "uint8clampedarray";
          // 16-bit typed arrays
          case "Int16Array":
            return "int16array";
          case "Uint16Array":
            return "uint16array";
          // 32-bit typed arrays
          case "Int32Array":
            return "int32array";
          case "Uint32Array":
            return "uint32array";
          case "Float32Array":
            return "float32array";
          case "Float64Array":
            return "float64array";
        }
        if (isGeneratorObj(val)) {
          return "generator";
        }
        type = toString.call(val);
        switch (type) {
          case "[object Object]":
            return "object";
          // iterators
          case "[object Map Iterator]":
            return "mapiterator";
          case "[object Set Iterator]":
            return "setiterator";
          case "[object String Iterator]":
            return "stringiterator";
          case "[object Array Iterator]":
            return "arrayiterator";
        }
        return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
      };
      function ctorName(val) {
        return typeof val.constructor === "function" ? val.constructor.name : null;
      }
      function isArray(val) {
        if (Array.isArray) return Array.isArray(val);
        return val instanceof Array;
      }
      function isError(val) {
        return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
      }
      function isDate(val) {
        if (val instanceof Date) return true;
        return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
      }
      function isRegexp(val) {
        if (val instanceof RegExp) return true;
        return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
      }
      function isGeneratorFn(name, val) {
        return ctorName(name) === "GeneratorFunction";
      }
      function isGeneratorObj(val) {
        return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
      }
      function isArguments(val) {
        try {
          if (typeof val.length === "number" && typeof val.callee === "function") {
            return true;
          }
        } catch (err) {
          if (err.message.indexOf("callee") !== -1) {
            return true;
          }
        }
        return false;
      }
      function isBuffer(val) {
        if (val.constructor && typeof val.constructor.isBuffer === "function") {
          return val.constructor.isBuffer(val);
        }
        return false;
      }
    }
  });

  // node_modules/is-extendable/index.js
  var require_is_extendable = __commonJS({
    "node_modules/is-extendable/index.js"(exports2, module2) {
      "use strict";
      module2.exports = function isExtendable(val) {
        return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
      };
    }
  });

  // node_modules/extend-shallow/index.js
  var require_extend_shallow = __commonJS({
    "node_modules/extend-shallow/index.js"(exports2, module2) {
      "use strict";
      var isObject = require_is_extendable();
      module2.exports = function extend(o) {
        if (!isObject(o)) {
          o = {};
        }
        var len = arguments.length;
        for (var i = 1; i < len; i++) {
          var obj = arguments[i];
          if (isObject(obj)) {
            assign(o, obj);
          }
        }
        return o;
      };
      function assign(a, b) {
        for (var key in b) {
          if (hasOwn(b, key)) {
            a[key] = b[key];
          }
        }
      }
      function hasOwn(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }
    }
  });

  // node_modules/section-matter/index.js
  var require_section_matter = __commonJS({
    "node_modules/section-matter/index.js"(exports2, module2) {
      "use strict";
      var typeOf = require_kind_of();
      var extend = require_extend_shallow();
      module2.exports = function(input, options3) {
        if (typeof options3 === "function") {
          options3 = { parse: options3 };
        }
        var file = toObject(input);
        var defaults = { section_delimiter: "---", parse: identity };
        var opts = extend({}, defaults, options3);
        var delim = opts.section_delimiter;
        var lines = file.content.split(/\r?\n/);
        var sections = null;
        var section = createSection();
        var content = [];
        var stack = [];
        function initSections(val) {
          file.content = val;
          sections = [];
          content = [];
        }
        function closeSection(val) {
          if (stack.length) {
            section.key = getKey(stack[0], delim);
            section.content = val;
            opts.parse(section, sections);
            sections.push(section);
            section = createSection();
            content = [];
            stack = [];
          }
        }
        for (var i = 0; i < lines.length; i++) {
          var line = lines[i];
          var len = stack.length;
          var ln = line.trim();
          if (isDelimiter(ln, delim)) {
            if (ln.length === 3 && i !== 0) {
              if (len === 0 || len === 2) {
                content.push(line);
                continue;
              }
              stack.push(ln);
              section.data = content.join("\n");
              content = [];
              continue;
            }
            if (sections === null) {
              initSections(content.join("\n"));
            }
            if (len === 2) {
              closeSection(content.join("\n"));
            }
            stack.push(ln);
            continue;
          }
          content.push(line);
        }
        if (sections === null) {
          initSections(content.join("\n"));
        } else {
          closeSection(content.join("\n"));
        }
        file.sections = sections;
        return file;
      };
      function isDelimiter(line, delim) {
        if (line.slice(0, delim.length) !== delim) {
          return false;
        }
        if (line.charAt(delim.length + 1) === delim.slice(-1)) {
          return false;
        }
        return true;
      }
      function toObject(input) {
        if (typeOf(input) !== "object") {
          input = { content: input };
        }
        if (typeof input.content !== "string" && !isBuffer(input.content)) {
          throw new TypeError("expected a buffer or string");
        }
        input.content = input.content.toString();
        input.sections = [];
        return input;
      }
      function getKey(val, delim) {
        return val ? val.slice(delim.length).trim() : "";
      }
      function createSection() {
        return { key: "", data: "", content: "" };
      }
      function identity(val) {
        return val;
      }
      function isBuffer(val) {
        if (val && val.constructor && typeof val.constructor.isBuffer === "function") {
          return val.constructor.isBuffer(val);
        }
        return false;
      }
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/common.js
  var require_common = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/common.js"(exports2, module2) {
      "use strict";
      function isNothing(subject) {
        return typeof subject === "undefined" || subject === null;
      }
      function isObject(subject) {
        return typeof subject === "object" && subject !== null;
      }
      function toArray(sequence) {
        if (Array.isArray(sequence)) return sequence;
        else if (isNothing(sequence)) return [];
        return [sequence];
      }
      function extend(target, source) {
        var index, length, key, sourceKeys;
        if (source) {
          sourceKeys = Object.keys(source);
          for (index = 0, length = sourceKeys.length; index < length; index += 1) {
            key = sourceKeys[index];
            target[key] = source[key];
          }
        }
        return target;
      }
      function repeat(string, count) {
        var result = "", cycle;
        for (cycle = 0; cycle < count; cycle += 1) {
          result += string;
        }
        return result;
      }
      function isNegativeZero(number) {
        return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
      }
      module2.exports.isNothing = isNothing;
      module2.exports.isObject = isObject;
      module2.exports.toArray = toArray;
      module2.exports.repeat = repeat;
      module2.exports.isNegativeZero = isNegativeZero;
      module2.exports.extend = extend;
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/exception.js
  var require_exception = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/exception.js"(exports2, module2) {
      "use strict";
      function YAMLException(reason, mark) {
        Error.call(this);
        this.name = "YAMLException";
        this.reason = reason;
        this.mark = mark;
        this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          this.stack = new Error().stack || "";
        }
      }
      YAMLException.prototype = Object.create(Error.prototype);
      YAMLException.prototype.constructor = YAMLException;
      YAMLException.prototype.toString = function toString(compact) {
        var result = this.name + ": ";
        result += this.reason || "(unknown reason)";
        if (!compact && this.mark) {
          result += " " + this.mark.toString();
        }
        return result;
      };
      module2.exports = YAMLException;
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/mark.js
  var require_mark = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/mark.js"(exports2, module2) {
      "use strict";
      var common = require_common();
      function Mark(name, buffer, position, line, column) {
        this.name = name;
        this.buffer = buffer;
        this.position = position;
        this.line = line;
        this.column = column;
      }
      Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
        var head, start, tail, end, snippet;
        if (!this.buffer) return null;
        indent = indent || 4;
        maxLength = maxLength || 75;
        head = "";
        start = this.position;
        while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
          start -= 1;
          if (this.position - start > maxLength / 2 - 1) {
            head = " ... ";
            start += 5;
            break;
          }
        }
        tail = "";
        end = this.position;
        while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
          end += 1;
          if (end - this.position > maxLength / 2 - 1) {
            tail = " ... ";
            end -= 5;
            break;
          }
        }
        snippet = this.buffer.slice(start, end);
        return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start + head.length) + "^";
      };
      Mark.prototype.toString = function toString(compact) {
        var snippet, where = "";
        if (this.name) {
          where += 'in "' + this.name + '" ';
        }
        where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
        if (!compact) {
          snippet = this.getSnippet();
          if (snippet) {
            where += ":\n" + snippet;
          }
        }
        return where;
      };
      module2.exports = Mark;
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type.js
  var require_type = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type.js"(exports2, module2) {
      "use strict";
      var YAMLException = require_exception();
      var TYPE_CONSTRUCTOR_OPTIONS = [
        "kind",
        "resolve",
        "construct",
        "instanceOf",
        "predicate",
        "represent",
        "defaultStyle",
        "styleAliases"
      ];
      var YAML_NODE_KINDS = [
        "scalar",
        "sequence",
        "mapping"
      ];
      function compileStyleAliases(map) {
        var result = {};
        if (map !== null) {
          Object.keys(map).forEach(function(style) {
            map[style].forEach(function(alias) {
              result[String(alias)] = style;
            });
          });
        }
        return result;
      }
      function Type(tag2, options3) {
        options3 = options3 || {};
        Object.keys(options3).forEach(function(name) {
          if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
            throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag2 + '" YAML type.');
          }
        });
        this.tag = tag2;
        this.kind = options3["kind"] || null;
        this.resolve = options3["resolve"] || function() {
          return true;
        };
        this.construct = options3["construct"] || function(data) {
          return data;
        };
        this.instanceOf = options3["instanceOf"] || null;
        this.predicate = options3["predicate"] || null;
        this.represent = options3["represent"] || null;
        this.defaultStyle = options3["defaultStyle"] || null;
        this.styleAliases = compileStyleAliases(options3["styleAliases"] || null);
        if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
          throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag2 + '" YAML type.');
        }
      }
      module2.exports = Type;
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema.js
  var require_schema = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema.js"(exports2, module2) {
      "use strict";
      var common = require_common();
      var YAMLException = require_exception();
      var Type = require_type();
      function compileList(schema, name, result) {
        var exclude = [];
        schema.include.forEach(function(includedSchema) {
          result = compileList(includedSchema, name, result);
        });
        schema[name].forEach(function(currentType) {
          result.forEach(function(previousType, previousIndex) {
            if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
              exclude.push(previousIndex);
            }
          });
          result.push(currentType);
        });
        return result.filter(function(type, index) {
          return exclude.indexOf(index) === -1;
        });
      }
      function compileMap() {
        var result = {
          scalar: {},
          sequence: {},
          mapping: {},
          fallback: {}
        }, index, length;
        function collectType(type) {
          result[type.kind][type.tag] = result["fallback"][type.tag] = type;
        }
        for (index = 0, length = arguments.length; index < length; index += 1) {
          arguments[index].forEach(collectType);
        }
        return result;
      }
      function Schema(definition) {
        this.include = definition.include || [];
        this.implicit = definition.implicit || [];
        this.explicit = definition.explicit || [];
        this.implicit.forEach(function(type) {
          if (type.loadKind && type.loadKind !== "scalar") {
            throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
          }
        });
        this.compiledImplicit = compileList(this, "implicit", []);
        this.compiledExplicit = compileList(this, "explicit", []);
        this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
      }
      Schema.DEFAULT = null;
      Schema.create = function createSchema() {
        var schemas, types;
        switch (arguments.length) {
          case 1:
            schemas = Schema.DEFAULT;
            types = arguments[0];
            break;
          case 2:
            schemas = arguments[0];
            types = arguments[1];
            break;
          default:
            throw new YAMLException("Wrong number of arguments for Schema.create function");
        }
        schemas = common.toArray(schemas);
        types = common.toArray(types);
        if (!schemas.every(function(schema) {
          return schema instanceof Schema;
        })) {
          throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
        }
        if (!types.every(function(type) {
          return type instanceof Type;
        })) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        return new Schema({
          include: schemas,
          explicit: types
        });
      };
      module2.exports = Schema;
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/str.js
  var require_str = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/str.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      module2.exports = new Type("tag:yaml.org,2002:str", {
        kind: "scalar",
        construct: function(data) {
          return data !== null ? data : "";
        }
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/seq.js
  var require_seq = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/seq.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      module2.exports = new Type("tag:yaml.org,2002:seq", {
        kind: "sequence",
        construct: function(data) {
          return data !== null ? data : [];
        }
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/map.js
  var require_map = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/map.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      module2.exports = new Type("tag:yaml.org,2002:map", {
        kind: "mapping",
        construct: function(data) {
          return data !== null ? data : {};
        }
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
  var require_failsafe = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js"(exports2, module2) {
      "use strict";
      var Schema = require_schema();
      module2.exports = new Schema({
        explicit: [
          require_str(),
          require_seq(),
          require_map()
        ]
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/null.js
  var require_null = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/null.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      function resolveYamlNull(data) {
        if (data === null) return true;
        var max = data.length;
        return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
      }
      function constructYamlNull() {
        return null;
      }
      function isNull(object) {
        return object === null;
      }
      module2.exports = new Type("tag:yaml.org,2002:null", {
        kind: "scalar",
        resolve: resolveYamlNull,
        construct: constructYamlNull,
        predicate: isNull,
        represent: {
          canonical: function() {
            return "~";
          },
          lowercase: function() {
            return "null";
          },
          uppercase: function() {
            return "NULL";
          },
          camelcase: function() {
            return "Null";
          }
        },
        defaultStyle: "lowercase"
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/bool.js
  var require_bool = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/bool.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      function resolveYamlBoolean(data) {
        if (data === null) return false;
        var max = data.length;
        return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
      }
      function constructYamlBoolean(data) {
        return data === "true" || data === "True" || data === "TRUE";
      }
      function isBoolean(object) {
        return Object.prototype.toString.call(object) === "[object Boolean]";
      }
      module2.exports = new Type("tag:yaml.org,2002:bool", {
        kind: "scalar",
        resolve: resolveYamlBoolean,
        construct: constructYamlBoolean,
        predicate: isBoolean,
        represent: {
          lowercase: function(object) {
            return object ? "true" : "false";
          },
          uppercase: function(object) {
            return object ? "TRUE" : "FALSE";
          },
          camelcase: function(object) {
            return object ? "True" : "False";
          }
        },
        defaultStyle: "lowercase"
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/int.js
  var require_int = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/int.js"(exports2, module2) {
      "use strict";
      var common = require_common();
      var Type = require_type();
      function isHexCode(c) {
        return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
      }
      function isOctCode(c) {
        return 48 <= c && c <= 55;
      }
      function isDecCode(c) {
        return 48 <= c && c <= 57;
      }
      function resolveYamlInteger(data) {
        if (data === null) return false;
        var max = data.length, index = 0, hasDigits = false, ch;
        if (!max) return false;
        ch = data[index];
        if (ch === "-" || ch === "+") {
          ch = data[++index];
        }
        if (ch === "0") {
          if (index + 1 === max) return true;
          ch = data[++index];
          if (ch === "b") {
            index++;
            for (; index < max; index++) {
              ch = data[index];
              if (ch === "_") continue;
              if (ch !== "0" && ch !== "1") return false;
              hasDigits = true;
            }
            return hasDigits && ch !== "_";
          }
          if (ch === "x") {
            index++;
            for (; index < max; index++) {
              ch = data[index];
              if (ch === "_") continue;
              if (!isHexCode(data.charCodeAt(index))) return false;
              hasDigits = true;
            }
            return hasDigits && ch !== "_";
          }
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_") continue;
            if (!isOctCode(data.charCodeAt(index))) return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "_") return false;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (ch === ":") break;
          if (!isDecCode(data.charCodeAt(index))) {
            return false;
          }
          hasDigits = true;
        }
        if (!hasDigits || ch === "_") return false;
        if (ch !== ":") return true;
        return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
      }
      function constructYamlInteger(data) {
        var value = data, sign = 1, ch, base, digits = [];
        if (value.indexOf("_") !== -1) {
          value = value.replace(/_/g, "");
        }
        ch = value[0];
        if (ch === "-" || ch === "+") {
          if (ch === "-") sign = -1;
          value = value.slice(1);
          ch = value[0];
        }
        if (value === "0") return 0;
        if (ch === "0") {
          if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
          if (value[1] === "x") return sign * parseInt(value, 16);
          return sign * parseInt(value, 8);
        }
        if (value.indexOf(":") !== -1) {
          value.split(":").forEach(function(v) {
            digits.unshift(parseInt(v, 10));
          });
          value = 0;
          base = 1;
          digits.forEach(function(d) {
            value += d * base;
            base *= 60;
          });
          return sign * value;
        }
        return sign * parseInt(value, 10);
      }
      function isInteger(object) {
        return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
      }
      module2.exports = new Type("tag:yaml.org,2002:int", {
        kind: "scalar",
        resolve: resolveYamlInteger,
        construct: constructYamlInteger,
        predicate: isInteger,
        represent: {
          binary: function(obj) {
            return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
          },
          octal: function(obj) {
            return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
          },
          decimal: function(obj) {
            return obj.toString(10);
          },
          /* eslint-disable max-len */
          hexadecimal: function(obj) {
            return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
          }
        },
        defaultStyle: "decimal",
        styleAliases: {
          binary: [2, "bin"],
          octal: [8, "oct"],
          decimal: [10, "dec"],
          hexadecimal: [16, "hex"]
        }
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/float.js
  var require_float = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/float.js"(exports2, module2) {
      "use strict";
      var common = require_common();
      var Type = require_type();
      var YAML_FLOAT_PATTERN = new RegExp(
        // 2.5e4, 2.5 and integers
        "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
      );
      function resolveYamlFloat(data) {
        if (data === null) return false;
        if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
        // Probably should update regexp & check speed
        data[data.length - 1] === "_") {
          return false;
        }
        return true;
      }
      function constructYamlFloat(data) {
        var value, sign, base, digits;
        value = data.replace(/_/g, "").toLowerCase();
        sign = value[0] === "-" ? -1 : 1;
        digits = [];
        if ("+-".indexOf(value[0]) >= 0) {
          value = value.slice(1);
        }
        if (value === ".inf") {
          return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
        } else if (value === ".nan") {
          return NaN;
        } else if (value.indexOf(":") >= 0) {
          value.split(":").forEach(function(v) {
            digits.unshift(parseFloat(v, 10));
          });
          value = 0;
          base = 1;
          digits.forEach(function(d) {
            value += d * base;
            base *= 60;
          });
          return sign * value;
        }
        return sign * parseFloat(value, 10);
      }
      var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
      function representYamlFloat(object, style) {
        var res;
        if (isNaN(object)) {
          switch (style) {
            case "lowercase":
              return ".nan";
            case "uppercase":
              return ".NAN";
            case "camelcase":
              return ".NaN";
          }
        } else if (Number.POSITIVE_INFINITY === object) {
          switch (style) {
            case "lowercase":
              return ".inf";
            case "uppercase":
              return ".INF";
            case "camelcase":
              return ".Inf";
          }
        } else if (Number.NEGATIVE_INFINITY === object) {
          switch (style) {
            case "lowercase":
              return "-.inf";
            case "uppercase":
              return "-.INF";
            case "camelcase":
              return "-.Inf";
          }
        } else if (common.isNegativeZero(object)) {
          return "-0.0";
        }
        res = object.toString(10);
        return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
      }
      function isFloat(object) {
        return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
      }
      module2.exports = new Type("tag:yaml.org,2002:float", {
        kind: "scalar",
        resolve: resolveYamlFloat,
        construct: constructYamlFloat,
        predicate: isFloat,
        represent: representYamlFloat,
        defaultStyle: "lowercase"
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema/json.js
  var require_json = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema/json.js"(exports2, module2) {
      "use strict";
      var Schema = require_schema();
      module2.exports = new Schema({
        include: [
          require_failsafe()
        ],
        implicit: [
          require_null(),
          require_bool(),
          require_int(),
          require_float()
        ]
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema/core.js
  var require_core = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema/core.js"(exports2, module2) {
      "use strict";
      var Schema = require_schema();
      module2.exports = new Schema({
        include: [
          require_json()
        ]
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/timestamp.js
  var require_timestamp = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/timestamp.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      var YAML_DATE_REGEXP = new RegExp(
        "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
      );
      var YAML_TIMESTAMP_REGEXP = new RegExp(
        "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
      );
      function resolveYamlTimestamp(data) {
        if (data === null) return false;
        if (YAML_DATE_REGEXP.exec(data) !== null) return true;
        if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
        return false;
      }
      function constructYamlTimestamp(data) {
        var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
        match = YAML_DATE_REGEXP.exec(data);
        if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
        if (match === null) throw new Error("Date resolve error");
        year = +match[1];
        month = +match[2] - 1;
        day = +match[3];
        if (!match[4]) {
          return new Date(Date.UTC(year, month, day));
        }
        hour = +match[4];
        minute = +match[5];
        second = +match[6];
        if (match[7]) {
          fraction = match[7].slice(0, 3);
          while (fraction.length < 3) {
            fraction += "0";
          }
          fraction = +fraction;
        }
        if (match[9]) {
          tz_hour = +match[10];
          tz_minute = +(match[11] || 0);
          delta = (tz_hour * 60 + tz_minute) * 6e4;
          if (match[9] === "-") delta = -delta;
        }
        date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
        if (delta) date.setTime(date.getTime() - delta);
        return date;
      }
      function representYamlTimestamp(object) {
        return object.toISOString();
      }
      module2.exports = new Type("tag:yaml.org,2002:timestamp", {
        kind: "scalar",
        resolve: resolveYamlTimestamp,
        construct: constructYamlTimestamp,
        instanceOf: Date,
        represent: representYamlTimestamp
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/merge.js
  var require_merge = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/merge.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      function resolveYamlMerge(data) {
        return data === "<<" || data === null;
      }
      module2.exports = new Type("tag:yaml.org,2002:merge", {
        kind: "scalar",
        resolve: resolveYamlMerge
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/binary.js
  var require_binary = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/binary.js"(exports2, module2) {
      "use strict";
      var NodeBuffer;
      try {
        _require = __require;
        NodeBuffer = _require("buffer").Buffer;
      } catch (__) {
      }
      var _require;
      var Type = require_type();
      var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
      function resolveYamlBinary(data) {
        if (data === null) return false;
        var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
        for (idx = 0; idx < max; idx++) {
          code = map.indexOf(data.charAt(idx));
          if (code > 64) continue;
          if (code < 0) return false;
          bitlen += 6;
        }
        return bitlen % 8 === 0;
      }
      function constructYamlBinary(data) {
        var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
        for (idx = 0; idx < max; idx++) {
          if (idx % 4 === 0 && idx) {
            result.push(bits >> 16 & 255);
            result.push(bits >> 8 & 255);
            result.push(bits & 255);
          }
          bits = bits << 6 | map.indexOf(input.charAt(idx));
        }
        tailbits = max % 4 * 6;
        if (tailbits === 0) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        } else if (tailbits === 18) {
          result.push(bits >> 10 & 255);
          result.push(bits >> 2 & 255);
        } else if (tailbits === 12) {
          result.push(bits >> 4 & 255);
        }
        if (NodeBuffer) {
          return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
        }
        return result;
      }
      function representYamlBinary(object) {
        var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
        for (idx = 0; idx < max; idx++) {
          if (idx % 3 === 0 && idx) {
            result += map[bits >> 18 & 63];
            result += map[bits >> 12 & 63];
            result += map[bits >> 6 & 63];
            result += map[bits & 63];
          }
          bits = (bits << 8) + object[idx];
        }
        tail = max % 3;
        if (tail === 0) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        } else if (tail === 2) {
          result += map[bits >> 10 & 63];
          result += map[bits >> 4 & 63];
          result += map[bits << 2 & 63];
          result += map[64];
        } else if (tail === 1) {
          result += map[bits >> 2 & 63];
          result += map[bits << 4 & 63];
          result += map[64];
          result += map[64];
        }
        return result;
      }
      function isBinary(object) {
        return NodeBuffer && NodeBuffer.isBuffer(object);
      }
      module2.exports = new Type("tag:yaml.org,2002:binary", {
        kind: "scalar",
        resolve: resolveYamlBinary,
        construct: constructYamlBinary,
        predicate: isBinary,
        represent: representYamlBinary
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/omap.js
  var require_omap = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/omap.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      var _hasOwnProperty = Object.prototype.hasOwnProperty;
      var _toString = Object.prototype.toString;
      function resolveYamlOmap(data) {
        if (data === null) return true;
        var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
        for (index = 0, length = object.length; index < length; index += 1) {
          pair = object[index];
          pairHasKey = false;
          if (_toString.call(pair) !== "[object Object]") return false;
          for (pairKey in pair) {
            if (_hasOwnProperty.call(pair, pairKey)) {
              if (!pairHasKey) pairHasKey = true;
              else return false;
            }
          }
          if (!pairHasKey) return false;
          if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
          else return false;
        }
        return true;
      }
      function constructYamlOmap(data) {
        return data !== null ? data : [];
      }
      module2.exports = new Type("tag:yaml.org,2002:omap", {
        kind: "sequence",
        resolve: resolveYamlOmap,
        construct: constructYamlOmap
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/pairs.js
  var require_pairs = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/pairs.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      var _toString = Object.prototype.toString;
      function resolveYamlPairs(data) {
        if (data === null) return true;
        var index, length, pair, keys, result, object = data;
        result = new Array(object.length);
        for (index = 0, length = object.length; index < length; index += 1) {
          pair = object[index];
          if (_toString.call(pair) !== "[object Object]") return false;
          keys = Object.keys(pair);
          if (keys.length !== 1) return false;
          result[index] = [keys[0], pair[keys[0]]];
        }
        return true;
      }
      function constructYamlPairs(data) {
        if (data === null) return [];
        var index, length, pair, keys, result, object = data;
        result = new Array(object.length);
        for (index = 0, length = object.length; index < length; index += 1) {
          pair = object[index];
          keys = Object.keys(pair);
          result[index] = [keys[0], pair[keys[0]]];
        }
        return result;
      }
      module2.exports = new Type("tag:yaml.org,2002:pairs", {
        kind: "sequence",
        resolve: resolveYamlPairs,
        construct: constructYamlPairs
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/set.js
  var require_set = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/set.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      var _hasOwnProperty = Object.prototype.hasOwnProperty;
      function resolveYamlSet(data) {
        if (data === null) return true;
        var key, object = data;
        for (key in object) {
          if (_hasOwnProperty.call(object, key)) {
            if (object[key] !== null) return false;
          }
        }
        return true;
      }
      function constructYamlSet(data) {
        return data !== null ? data : {};
      }
      module2.exports = new Type("tag:yaml.org,2002:set", {
        kind: "mapping",
        resolve: resolveYamlSet,
        construct: constructYamlSet
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
  var require_default_safe = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js"(exports2, module2) {
      "use strict";
      var Schema = require_schema();
      module2.exports = new Schema({
        include: [
          require_core()
        ],
        implicit: [
          require_timestamp(),
          require_merge()
        ],
        explicit: [
          require_binary(),
          require_omap(),
          require_pairs(),
          require_set()
        ]
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
  var require_undefined = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      function resolveJavascriptUndefined() {
        return true;
      }
      function constructJavascriptUndefined() {
        return void 0;
      }
      function representJavascriptUndefined() {
        return "";
      }
      function isUndefined(object) {
        return typeof object === "undefined";
      }
      module2.exports = new Type("tag:yaml.org,2002:js/undefined", {
        kind: "scalar",
        resolve: resolveJavascriptUndefined,
        construct: constructJavascriptUndefined,
        predicate: isUndefined,
        represent: representJavascriptUndefined
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
  var require_regexp = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js"(exports2, module2) {
      "use strict";
      var Type = require_type();
      function resolveJavascriptRegExp(data) {
        if (data === null) return false;
        if (data.length === 0) return false;
        var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
        if (regexp[0] === "/") {
          if (tail) modifiers = tail[1];
          if (modifiers.length > 3) return false;
          if (regexp[regexp.length - modifiers.length - 1] !== "/") return false;
        }
        return true;
      }
      function constructJavascriptRegExp(data) {
        var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
        if (regexp[0] === "/") {
          if (tail) modifiers = tail[1];
          regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
        }
        return new RegExp(regexp, modifiers);
      }
      function representJavascriptRegExp(object) {
        var result = "/" + object.source + "/";
        if (object.global) result += "g";
        if (object.multiline) result += "m";
        if (object.ignoreCase) result += "i";
        return result;
      }
      function isRegExp(object) {
        return Object.prototype.toString.call(object) === "[object RegExp]";
      }
      module2.exports = new Type("tag:yaml.org,2002:js/regexp", {
        kind: "scalar",
        resolve: resolveJavascriptRegExp,
        construct: constructJavascriptRegExp,
        predicate: isRegExp,
        represent: representJavascriptRegExp
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/js/function.js
  var require_function = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/js/function.js"(exports2, module2) {
      "use strict";
      var esprima;
      try {
        _require = __require;
        esprima = _require("esprima");
      } catch (_) {
        if (typeof window !== "undefined") esprima = window.esprima;
      }
      var _require;
      var Type = require_type();
      function resolveJavascriptFunction(data) {
        if (data === null) return false;
        try {
          var source = "(" + data + ")", ast = esprima.parse(source, { range: true });
          if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      function constructJavascriptFunction(data) {
        var source = "(" + data + ")", ast = esprima.parse(source, { range: true }), params = [], body;
        if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
          throw new Error("Failed to resolve function");
        }
        ast.body[0].expression.params.forEach(function(param) {
          params.push(param.name);
        });
        body = ast.body[0].expression.body.range;
        if (ast.body[0].expression.body.type === "BlockStatement") {
          return new Function(params, source.slice(body[0] + 1, body[1] - 1));
        }
        return new Function(params, "return " + source.slice(body[0], body[1]));
      }
      function representJavascriptFunction(object) {
        return object.toString();
      }
      function isFunction(object) {
        return Object.prototype.toString.call(object) === "[object Function]";
      }
      module2.exports = new Type("tag:yaml.org,2002:js/function", {
        kind: "scalar",
        resolve: resolveJavascriptFunction,
        construct: constructJavascriptFunction,
        predicate: isFunction,
        represent: representJavascriptFunction
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema/default_full.js
  var require_default_full = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema/default_full.js"(exports2, module2) {
      "use strict";
      var Schema = require_schema();
      module2.exports = Schema.DEFAULT = new Schema({
        include: [
          require_default_safe()
        ],
        explicit: [
          require_undefined(),
          require_regexp(),
          require_function()
        ]
      });
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/loader.js
  var require_loader = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/loader.js"(exports2, module2) {
      "use strict";
      var common = require_common();
      var YAMLException = require_exception();
      var Mark = require_mark();
      var DEFAULT_SAFE_SCHEMA = require_default_safe();
      var DEFAULT_FULL_SCHEMA = require_default_full();
      var _hasOwnProperty = Object.prototype.hasOwnProperty;
      var CONTEXT_FLOW_IN = 1;
      var CONTEXT_FLOW_OUT = 2;
      var CONTEXT_BLOCK_IN = 3;
      var CONTEXT_BLOCK_OUT = 4;
      var CHOMPING_CLIP = 1;
      var CHOMPING_STRIP = 2;
      var CHOMPING_KEEP = 3;
      var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
      var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
      var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
      var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
      function _class(obj) {
        return Object.prototype.toString.call(obj);
      }
      function is_EOL(c) {
        return c === 10 || c === 13;
      }
      function is_WHITE_SPACE(c) {
        return c === 9 || c === 32;
      }
      function is_WS_OR_EOL(c) {
        return c === 9 || c === 32 || c === 10 || c === 13;
      }
      function is_FLOW_INDICATOR(c) {
        return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
      }
      function fromHexCode(c) {
        var lc;
        if (48 <= c && c <= 57) {
          return c - 48;
        }
        lc = c | 32;
        if (97 <= lc && lc <= 102) {
          return lc - 97 + 10;
        }
        return -1;
      }
      function escapedHexLen(c) {
        if (c === 120) {
          return 2;
        }
        if (c === 117) {
          return 4;
        }
        if (c === 85) {
          return 8;
        }
        return 0;
      }
      function fromDecimalCode(c) {
        if (48 <= c && c <= 57) {
          return c - 48;
        }
        return -1;
      }
      function simpleEscapeSequence(c) {
        return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
      }
      function charFromCodepoint(c) {
        if (c <= 65535) {
          return String.fromCharCode(c);
        }
        return String.fromCharCode(
          (c - 65536 >> 10) + 55296,
          (c - 65536 & 1023) + 56320
        );
      }
      function setProperty(object, key, value) {
        if (key === "__proto__") {
          Object.defineProperty(object, key, {
            configurable: true,
            enumerable: true,
            writable: true,
            value
          });
        } else {
          object[key] = value;
        }
      }
      var simpleEscapeCheck = new Array(256);
      var simpleEscapeMap = new Array(256);
      for (i = 0; i < 256; i++) {
        simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
        simpleEscapeMap[i] = simpleEscapeSequence(i);
      }
      var i;
      function State(input, options3) {
        this.input = input;
        this.filename = options3["filename"] || null;
        this.schema = options3["schema"] || DEFAULT_FULL_SCHEMA;
        this.onWarning = options3["onWarning"] || null;
        this.legacy = options3["legacy"] || false;
        this.json = options3["json"] || false;
        this.listener = options3["listener"] || null;
        this.implicitTypes = this.schema.compiledImplicit;
        this.typeMap = this.schema.compiledTypeMap;
        this.length = input.length;
        this.position = 0;
        this.line = 0;
        this.lineStart = 0;
        this.lineIndent = 0;
        this.documents = [];
      }
      function generateError(state, message) {
        return new YAMLException(
          message,
          new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart)
        );
      }
      function throwError(state, message) {
        throw generateError(state, message);
      }
      function throwWarning(state, message) {
        if (state.onWarning) {
          state.onWarning.call(null, generateError(state, message));
        }
      }
      var directiveHandlers = {
        YAML: function handleYamlDirective(state, name, args) {
          var match, major, minor;
          if (state.version !== null) {
            throwError(state, "duplication of %YAML directive");
          }
          if (args.length !== 1) {
            throwError(state, "YAML directive accepts exactly one argument");
          }
          match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
          if (match === null) {
            throwError(state, "ill-formed argument of the YAML directive");
          }
          major = parseInt(match[1], 10);
          minor = parseInt(match[2], 10);
          if (major !== 1) {
            throwError(state, "unacceptable YAML version of the document");
          }
          state.version = args[0];
          state.checkLineBreaks = minor < 2;
          if (minor !== 1 && minor !== 2) {
            throwWarning(state, "unsupported YAML version of the document");
          }
        },
        TAG: function handleTagDirective(state, name, args) {
          var handle, prefix;
          if (args.length !== 2) {
            throwError(state, "TAG directive accepts exactly two arguments");
          }
          handle = args[0];
          prefix = args[1];
          if (!PATTERN_TAG_HANDLE.test(handle)) {
            throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
          }
          if (_hasOwnProperty.call(state.tagMap, handle)) {
            throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
          }
          if (!PATTERN_TAG_URI.test(prefix)) {
            throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
          }
          state.tagMap[handle] = prefix;
        }
      };
      function captureSegment(state, start, end, checkJson) {
        var _position, _length, _character, _result;
        if (start < end) {
          _result = state.input.slice(start, end);
          if (checkJson) {
            for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
              _character = _result.charCodeAt(_position);
              if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
                throwError(state, "expected valid JSON character");
              }
            }
          } else if (PATTERN_NON_PRINTABLE.test(_result)) {
            throwError(state, "the stream contains non-printable characters");
          }
          state.result += _result;
        }
      }
      function mergeMappings(state, destination, source, overridableKeys) {
        var sourceKeys, key, index, quantity;
        if (!common.isObject(source)) {
          throwError(state, "cannot merge mappings; the provided source object is unacceptable");
        }
        sourceKeys = Object.keys(source);
        for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
          key = sourceKeys[index];
          if (!_hasOwnProperty.call(destination, key)) {
            setProperty(destination, key, source[key]);
            overridableKeys[key] = true;
          }
        }
      }
      function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
        var index, quantity;
        if (Array.isArray(keyNode)) {
          keyNode = Array.prototype.slice.call(keyNode);
          for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
            if (Array.isArray(keyNode[index])) {
              throwError(state, "nested arrays are not supported inside keys");
            }
            if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
              keyNode[index] = "[object Object]";
            }
          }
        }
        if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
          keyNode = "[object Object]";
        }
        keyNode = String(keyNode);
        if (_result === null) {
          _result = {};
        }
        if (keyTag === "tag:yaml.org,2002:merge") {
          if (Array.isArray(valueNode)) {
            for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
              mergeMappings(state, _result, valueNode[index], overridableKeys);
            }
          } else {
            mergeMappings(state, _result, valueNode, overridableKeys);
          }
        } else {
          if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
            state.line = startLine || state.line;
            state.position = startPos || state.position;
            throwError(state, "duplicated mapping key");
          }
          setProperty(_result, keyNode, valueNode);
          delete overridableKeys[keyNode];
        }
        return _result;
      }
      function readLineBreak(state) {
        var ch;
        ch = state.input.charCodeAt(state.position);
        if (ch === 10) {
          state.position++;
        } else if (ch === 13) {
          state.position++;
          if (state.input.charCodeAt(state.position) === 10) {
            state.position++;
          }
        } else {
          throwError(state, "a line break is expected");
        }
        state.line += 1;
        state.lineStart = state.position;
      }
      function skipSeparationSpace(state, allowComments, checkIndent) {
        var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (allowComments && ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 10 && ch !== 13 && ch !== 0);
          }
          if (is_EOL(ch)) {
            readLineBreak(state);
            ch = state.input.charCodeAt(state.position);
            lineBreaks++;
            state.lineIndent = 0;
            while (ch === 32) {
              state.lineIndent++;
              ch = state.input.charCodeAt(++state.position);
            }
          } else {
            break;
          }
        }
        if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
          throwWarning(state, "deficient indentation");
        }
        return lineBreaks;
      }
      function testDocumentSeparator(state) {
        var _position = state.position, ch;
        ch = state.input.charCodeAt(_position);
        if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
          _position += 3;
          ch = state.input.charCodeAt(_position);
          if (ch === 0 || is_WS_OR_EOL(ch)) {
            return true;
          }
        }
        return false;
      }
      function writeFoldedLines(state, count) {
        if (count === 1) {
          state.result += " ";
        } else if (count > 1) {
          state.result += common.repeat("\n", count - 1);
        }
      }
      function readPlainScalar(state, nodeIndent, withinFlowCollection) {
        var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
        ch = state.input.charCodeAt(state.position);
        if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
          return false;
        }
        if (ch === 63 || ch === 45) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            return false;
          }
        }
        state.kind = "scalar";
        state.result = "";
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
        while (ch !== 0) {
          if (ch === 58) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
              break;
            }
          } else if (ch === 35) {
            preceding = state.input.charCodeAt(state.position - 1);
            if (is_WS_OR_EOL(preceding)) {
              break;
            }
          } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
            break;
          } else if (is_EOL(ch)) {
            _line = state.line;
            _lineStart = state.lineStart;
            _lineIndent = state.lineIndent;
            skipSeparationSpace(state, false, -1);
            if (state.lineIndent >= nodeIndent) {
              hasPendingContent = true;
              ch = state.input.charCodeAt(state.position);
              continue;
            } else {
              state.position = captureEnd;
              state.line = _line;
              state.lineStart = _lineStart;
              state.lineIndent = _lineIndent;
              break;
            }
          }
          if (hasPendingContent) {
            captureSegment(state, captureStart, captureEnd, false);
            writeFoldedLines(state, state.line - _line);
            captureStart = captureEnd = state.position;
            hasPendingContent = false;
          }
          if (!is_WHITE_SPACE(ch)) {
            captureEnd = state.position + 1;
          }
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, captureEnd, false);
        if (state.result) {
          return true;
        }
        state.kind = _kind;
        state.result = _result;
        return false;
      }
      function readSingleQuotedScalar(state, nodeIndent) {
        var ch, captureStart, captureEnd;
        ch = state.input.charCodeAt(state.position);
        if (ch !== 39) {
          return false;
        }
        state.kind = "scalar";
        state.result = "";
        state.position++;
        captureStart = captureEnd = state.position;
        while ((ch = state.input.charCodeAt(state.position)) !== 0) {
          if (ch === 39) {
            captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if (ch === 39) {
              captureStart = state.position;
              state.position++;
              captureEnd = state.position;
            } else {
              return true;
            }
          } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true);
            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
          } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
            throwError(state, "unexpected end of the document within a single quoted scalar");
          } else {
            state.position++;
            captureEnd = state.position;
          }
        }
        throwError(state, "unexpected end of the stream within a single quoted scalar");
      }
      function readDoubleQuotedScalar(state, nodeIndent) {
        var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch !== 34) {
          return false;
        }
        state.kind = "scalar";
        state.result = "";
        state.position++;
        captureStart = captureEnd = state.position;
        while ((ch = state.input.charCodeAt(state.position)) !== 0) {
          if (ch === 34) {
            captureSegment(state, captureStart, state.position, true);
            state.position++;
            return true;
          } else if (ch === 92) {
            captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if (is_EOL(ch)) {
              skipSeparationSpace(state, false, nodeIndent);
            } else if (ch < 256 && simpleEscapeCheck[ch]) {
              state.result += simpleEscapeMap[ch];
              state.position++;
            } else if ((tmp = escapedHexLen(ch)) > 0) {
              hexLength = tmp;
              hexResult = 0;
              for (; hexLength > 0; hexLength--) {
                ch = state.input.charCodeAt(++state.position);
                if ((tmp = fromHexCode(ch)) >= 0) {
                  hexResult = (hexResult << 4) + tmp;
                } else {
                  throwError(state, "expected hexadecimal character");
                }
              }
              state.result += charFromCodepoint(hexResult);
              state.position++;
            } else {
              throwError(state, "unknown escape sequence");
            }
            captureStart = captureEnd = state.position;
          } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true);
            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
          } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
            throwError(state, "unexpected end of the document within a double quoted scalar");
          } else {
            state.position++;
            captureEnd = state.position;
          }
        }
        throwError(state, "unexpected end of the stream within a double quoted scalar");
      }
      function readFlowCollection(state, nodeIndent) {
        var readNext = true, _line, _tag2 = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch === 91) {
          terminator = 93;
          isMapping = false;
          _result = [];
        } else if (ch === 123) {
          terminator = 125;
          isMapping = true;
          _result = {};
        } else {
          return false;
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = _result;
        }
        ch = state.input.charCodeAt(++state.position);
        while (ch !== 0) {
          skipSeparationSpace(state, true, nodeIndent);
          ch = state.input.charCodeAt(state.position);
          if (ch === terminator) {
            state.position++;
            state.tag = _tag2;
            state.anchor = _anchor;
            state.kind = isMapping ? "mapping" : "sequence";
            state.result = _result;
            return true;
          } else if (!readNext) {
            throwError(state, "missed comma between flow collection entries");
          }
          keyTag = keyNode = valueNode = null;
          isPair = isExplicitPair = false;
          if (ch === 63) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following)) {
              isPair = isExplicitPair = true;
              state.position++;
              skipSeparationSpace(state, true, nodeIndent);
            }
          }
          _line = state.line;
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          keyTag = state.tag;
          keyNode = state.result;
          skipSeparationSpace(state, true, nodeIndent);
          ch = state.input.charCodeAt(state.position);
          if ((isExplicitPair || state.line === _line) && ch === 58) {
            isPair = true;
            ch = state.input.charCodeAt(++state.position);
            skipSeparationSpace(state, true, nodeIndent);
            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
            valueNode = state.result;
          }
          if (isMapping) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
          } else if (isPair) {
            _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
          } else {
            _result.push(keyNode);
          }
          skipSeparationSpace(state, true, nodeIndent);
          ch = state.input.charCodeAt(state.position);
          if (ch === 44) {
            readNext = true;
            ch = state.input.charCodeAt(++state.position);
          } else {
            readNext = false;
          }
        }
        throwError(state, "unexpected end of the stream within a flow collection");
      }
      function readBlockScalar(state, nodeIndent) {
        var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch === 124) {
          folding = false;
        } else if (ch === 62) {
          folding = true;
        } else {
          return false;
        }
        state.kind = "scalar";
        state.result = "";
        while (ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
          if (ch === 43 || ch === 45) {
            if (CHOMPING_CLIP === chomping) {
              chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
            } else {
              throwError(state, "repeat of a chomping mode identifier");
            }
          } else if ((tmp = fromDecimalCode(ch)) >= 0) {
            if (tmp === 0) {
              throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
            } else if (!detectedIndent) {
              textIndent = nodeIndent + tmp - 1;
              detectedIndent = true;
            } else {
              throwError(state, "repeat of an indentation width identifier");
            }
          } else {
            break;
          }
        }
        if (is_WHITE_SPACE(ch)) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (is_WHITE_SPACE(ch));
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (!is_EOL(ch) && ch !== 0);
          }
        }
        while (ch !== 0) {
          readLineBreak(state);
          state.lineIndent = 0;
          ch = state.input.charCodeAt(state.position);
          while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
          if (!detectedIndent && state.lineIndent > textIndent) {
            textIndent = state.lineIndent;
          }
          if (is_EOL(ch)) {
            emptyLines++;
            continue;
          }
          if (state.lineIndent < textIndent) {
            if (chomping === CHOMPING_KEEP) {
              state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            } else if (chomping === CHOMPING_CLIP) {
              if (didReadContent) {
                state.result += "\n";
              }
            }
            break;
          }
          if (folding) {
            if (is_WHITE_SPACE(ch)) {
              atMoreIndented = true;
              state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            } else if (atMoreIndented) {
              atMoreIndented = false;
              state.result += common.repeat("\n", emptyLines + 1);
            } else if (emptyLines === 0) {
              if (didReadContent) {
                state.result += " ";
              }
            } else {
              state.result += common.repeat("\n", emptyLines);
            }
          } else {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          }
          didReadContent = true;
          detectedIndent = true;
          emptyLines = 0;
          captureStart = state.position;
          while (!is_EOL(ch) && ch !== 0) {
            ch = state.input.charCodeAt(++state.position);
          }
          captureSegment(state, captureStart, state.position, false);
        }
        return true;
      }
      function readBlockSequence(state, nodeIndent) {
        var _line, _tag2 = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = _result;
        }
        ch = state.input.charCodeAt(state.position);
        while (ch !== 0) {
          if (ch !== 45) {
            break;
          }
          following = state.input.charCodeAt(state.position + 1);
          if (!is_WS_OR_EOL(following)) {
            break;
          }
          detected = true;
          state.position++;
          if (skipSeparationSpace(state, true, -1)) {
            if (state.lineIndent <= nodeIndent) {
              _result.push(null);
              ch = state.input.charCodeAt(state.position);
              continue;
            }
          }
          _line = state.line;
          composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
          _result.push(state.result);
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
          if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
            throwError(state, "bad indentation of a sequence entry");
          } else if (state.lineIndent < nodeIndent) {
            break;
          }
        }
        if (detected) {
          state.tag = _tag2;
          state.anchor = _anchor;
          state.kind = "sequence";
          state.result = _result;
          return true;
        }
        return false;
      }
      function readBlockMapping(state, nodeIndent, flowIndent) {
        var following, allowCompact, _line, _pos, _tag2 = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = _result;
        }
        ch = state.input.charCodeAt(state.position);
        while (ch !== 0) {
          following = state.input.charCodeAt(state.position + 1);
          _line = state.line;
          _pos = state.position;
          if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
            if (ch === 63) {
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = true;
              allowCompact = true;
            } else if (atExplicitKey) {
              atExplicitKey = false;
              allowCompact = true;
            } else {
              throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
            }
            state.position += 1;
            ch = following;
          } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
            if (state.line === _line) {
              ch = state.input.charCodeAt(state.position);
              while (is_WHITE_SPACE(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              if (ch === 58) {
                ch = state.input.charCodeAt(++state.position);
                if (!is_WS_OR_EOL(ch)) {
                  throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
                }
                if (atExplicitKey) {
                  storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                  keyTag = keyNode = valueNode = null;
                }
                detected = true;
                atExplicitKey = false;
                allowCompact = false;
                keyTag = state.tag;
                keyNode = state.result;
              } else if (detected) {
                throwError(state, "can not read an implicit mapping pair; a colon is missed");
              } else {
                state.tag = _tag2;
                state.anchor = _anchor;
                return true;
              }
            } else if (detected) {
              throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
            } else {
              state.tag = _tag2;
              state.anchor = _anchor;
              return true;
            }
          } else {
            break;
          }
          if (state.line === _line || state.lineIndent > nodeIndent) {
            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
              if (atExplicitKey) {
                keyNode = state.result;
              } else {
                valueNode = state.result;
              }
            }
            if (!atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
              keyTag = keyNode = valueNode = null;
            }
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
          }
          if (state.lineIndent > nodeIndent && ch !== 0) {
            throwError(state, "bad indentation of a mapping entry");
          } else if (state.lineIndent < nodeIndent) {
            break;
          }
        }
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
        }
        if (detected) {
          state.tag = _tag2;
          state.anchor = _anchor;
          state.kind = "mapping";
          state.result = _result;
        }
        return detected;
      }
      function readTagProperty(state) {
        var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch !== 33) return false;
        if (state.tag !== null) {
          throwError(state, "duplication of a tag property");
        }
        ch = state.input.charCodeAt(++state.position);
        if (ch === 60) {
          isVerbatim = true;
          ch = state.input.charCodeAt(++state.position);
        } else if (ch === 33) {
          isNamed = true;
          tagHandle = "!!";
          ch = state.input.charCodeAt(++state.position);
        } else {
          tagHandle = "!";
        }
        _position = state.position;
        if (isVerbatim) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && ch !== 62);
          if (state.position < state.length) {
            tagName = state.input.slice(_position, state.position);
            ch = state.input.charCodeAt(++state.position);
          } else {
            throwError(state, "unexpected end of the stream within a verbatim tag");
          }
        } else {
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            if (ch === 33) {
              if (!isNamed) {
                tagHandle = state.input.slice(_position - 1, state.position + 1);
                if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                  throwError(state, "named tag handle cannot contain such characters");
                }
                isNamed = true;
                _position = state.position + 1;
              } else {
                throwError(state, "tag suffix cannot contain exclamation marks");
              }
            }
            ch = state.input.charCodeAt(++state.position);
          }
          tagName = state.input.slice(_position, state.position);
          if (PATTERN_FLOW_INDICATORS.test(tagName)) {
            throwError(state, "tag suffix cannot contain flow indicator characters");
          }
        }
        if (tagName && !PATTERN_TAG_URI.test(tagName)) {
          throwError(state, "tag name cannot contain such characters: " + tagName);
        }
        if (isVerbatim) {
          state.tag = tagName;
        } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
          state.tag = state.tagMap[tagHandle] + tagName;
        } else if (tagHandle === "!") {
          state.tag = "!" + tagName;
        } else if (tagHandle === "!!") {
          state.tag = "tag:yaml.org,2002:" + tagName;
        } else {
          throwError(state, 'undeclared tag handle "' + tagHandle + '"');
        }
        return true;
      }
      function readAnchorProperty(state) {
        var _position, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch !== 38) return false;
        if (state.anchor !== null) {
          throwError(state, "duplication of an anchor property");
        }
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (state.position === _position) {
          throwError(state, "name of an anchor node must contain at least one character");
        }
        state.anchor = state.input.slice(_position, state.position);
        return true;
      }
      function readAlias(state) {
        var _position, alias, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch !== 42) return false;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (state.position === _position) {
          throwError(state, "name of an alias node must contain at least one character");
        }
        alias = state.input.slice(_position, state.position);
        if (!_hasOwnProperty.call(state.anchorMap, alias)) {
          throwError(state, 'unidentified alias "' + alias + '"');
        }
        state.result = state.anchorMap[alias];
        skipSeparationSpace(state, true, -1);
        return true;
      }
      function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
        var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
        if (state.listener !== null) {
          state.listener("open", state);
        }
        state.tag = null;
        state.anchor = null;
        state.kind = null;
        state.result = null;
        allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
        if (allowToSeek) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          }
        }
        if (indentStatus === 1) {
          while (readTagProperty(state) || readAnchorProperty(state)) {
            if (skipSeparationSpace(state, true, -1)) {
              atNewLine = true;
              allowBlockCollections = allowBlockStyles;
              if (state.lineIndent > parentIndent) {
                indentStatus = 1;
              } else if (state.lineIndent === parentIndent) {
                indentStatus = 0;
              } else if (state.lineIndent < parentIndent) {
                indentStatus = -1;
              }
            } else {
              allowBlockCollections = false;
            }
          }
        }
        if (allowBlockCollections) {
          allowBlockCollections = atNewLine || allowCompact;
        }
        if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
          if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
            flowIndent = parentIndent;
          } else {
            flowIndent = parentIndent + 1;
          }
          blockIndent = state.position - state.lineStart;
          if (indentStatus === 1) {
            if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
              hasContent = true;
            } else {
              if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
                hasContent = true;
              } else if (readAlias(state)) {
                hasContent = true;
                if (state.tag !== null || state.anchor !== null) {
                  throwError(state, "alias node should not have any properties");
                }
              } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                hasContent = true;
                if (state.tag === null) {
                  state.tag = "?";
                }
              }
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
            }
          } else if (indentStatus === 0) {
            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
          }
        }
        if (state.tag !== null && state.tag !== "!") {
          if (state.tag === "?") {
            if (state.result !== null && state.kind !== "scalar") {
              throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
            }
            for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
              type = state.implicitTypes[typeIndex];
              if (type.resolve(state.result)) {
                state.result = type.construct(state.result);
                state.tag = type.tag;
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
                break;
              }
            }
          } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
            type = state.typeMap[state.kind || "fallback"][state.tag];
            if (state.result !== null && type.kind !== state.kind) {
              throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
            }
            if (!type.resolve(state.result)) {
              throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
            } else {
              state.result = type.construct(state.result);
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
            }
          } else {
            throwError(state, "unknown tag !<" + state.tag + ">");
          }
        }
        if (state.listener !== null) {
          state.listener("close", state);
        }
        return state.tag !== null || state.anchor !== null || hasContent;
      }
      function readDocument(state) {
        var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
        state.version = null;
        state.checkLineBreaks = state.legacy;
        state.tagMap = {};
        state.anchorMap = {};
        while ((ch = state.input.charCodeAt(state.position)) !== 0) {
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
          if (state.lineIndent > 0 || ch !== 37) {
            break;
          }
          hasDirectives = true;
          ch = state.input.charCodeAt(++state.position);
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveName = state.input.slice(_position, state.position);
          directiveArgs = [];
          if (directiveName.length < 1) {
            throwError(state, "directive name must not be less than one character in length");
          }
          while (ch !== 0) {
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 35) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (ch !== 0 && !is_EOL(ch));
              break;
            }
            if (is_EOL(ch)) break;
            _position = state.position;
            while (ch !== 0 && !is_WS_OR_EOL(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            directiveArgs.push(state.input.slice(_position, state.position));
          }
          if (ch !== 0) readLineBreak(state);
          if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
            directiveHandlers[directiveName](state, directiveName, directiveArgs);
          } else {
            throwWarning(state, 'unknown document directive "' + directiveName + '"');
          }
        }
        skipSeparationSpace(state, true, -1);
        if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        } else if (hasDirectives) {
          throwError(state, "directives end mark is expected");
        }
        composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
        skipSeparationSpace(state, true, -1);
        if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
          throwWarning(state, "non-ASCII line breaks are interpreted as content");
        }
        state.documents.push(state.result);
        if (state.position === state.lineStart && testDocumentSeparator(state)) {
          if (state.input.charCodeAt(state.position) === 46) {
            state.position += 3;
            skipSeparationSpace(state, true, -1);
          }
          return;
        }
        if (state.position < state.length - 1) {
          throwError(state, "end of the stream or a document separator is expected");
        } else {
          return;
        }
      }
      function loadDocuments(input, options3) {
        input = String(input);
        options3 = options3 || {};
        if (input.length !== 0) {
          if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
            input += "\n";
          }
          if (input.charCodeAt(0) === 65279) {
            input = input.slice(1);
          }
        }
        var state = new State(input, options3);
        var nullpos = input.indexOf("\0");
        if (nullpos !== -1) {
          state.position = nullpos;
          throwError(state, "null byte is not allowed in input");
        }
        state.input += "\0";
        while (state.input.charCodeAt(state.position) === 32) {
          state.lineIndent += 1;
          state.position += 1;
        }
        while (state.position < state.length - 1) {
          readDocument(state);
        }
        return state.documents;
      }
      function loadAll(input, iterator, options3) {
        if (iterator !== null && typeof iterator === "object" && typeof options3 === "undefined") {
          options3 = iterator;
          iterator = null;
        }
        var documents = loadDocuments(input, options3);
        if (typeof iterator !== "function") {
          return documents;
        }
        for (var index = 0, length = documents.length; index < length; index += 1) {
          iterator(documents[index]);
        }
      }
      function load(input, options3) {
        var documents = loadDocuments(input, options3);
        if (documents.length === 0) {
          return void 0;
        } else if (documents.length === 1) {
          return documents[0];
        }
        throw new YAMLException("expected a single document in the stream, but found more");
      }
      function safeLoadAll(input, iterator, options3) {
        if (typeof iterator === "object" && iterator !== null && typeof options3 === "undefined") {
          options3 = iterator;
          iterator = null;
        }
        return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options3));
      }
      function safeLoad(input, options3) {
        return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options3));
      }
      module2.exports.loadAll = loadAll;
      module2.exports.load = load;
      module2.exports.safeLoadAll = safeLoadAll;
      module2.exports.safeLoad = safeLoad;
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/dumper.js
  var require_dumper = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/dumper.js"(exports2, module2) {
      "use strict";
      var common = require_common();
      var YAMLException = require_exception();
      var DEFAULT_FULL_SCHEMA = require_default_full();
      var DEFAULT_SAFE_SCHEMA = require_default_safe();
      var _toString = Object.prototype.toString;
      var _hasOwnProperty = Object.prototype.hasOwnProperty;
      var CHAR_TAB = 9;
      var CHAR_LINE_FEED = 10;
      var CHAR_CARRIAGE_RETURN = 13;
      var CHAR_SPACE = 32;
      var CHAR_EXCLAMATION = 33;
      var CHAR_DOUBLE_QUOTE = 34;
      var CHAR_SHARP = 35;
      var CHAR_PERCENT = 37;
      var CHAR_AMPERSAND = 38;
      var CHAR_SINGLE_QUOTE = 39;
      var CHAR_ASTERISK = 42;
      var CHAR_COMMA = 44;
      var CHAR_MINUS = 45;
      var CHAR_COLON = 58;
      var CHAR_EQUALS = 61;
      var CHAR_GREATER_THAN = 62;
      var CHAR_QUESTION = 63;
      var CHAR_COMMERCIAL_AT = 64;
      var CHAR_LEFT_SQUARE_BRACKET = 91;
      var CHAR_RIGHT_SQUARE_BRACKET = 93;
      var CHAR_GRAVE_ACCENT = 96;
      var CHAR_LEFT_CURLY_BRACKET = 123;
      var CHAR_VERTICAL_LINE = 124;
      var CHAR_RIGHT_CURLY_BRACKET = 125;
      var ESCAPE_SEQUENCES = {};
      ESCAPE_SEQUENCES[0] = "\\0";
      ESCAPE_SEQUENCES[7] = "\\a";
      ESCAPE_SEQUENCES[8] = "\\b";
      ESCAPE_SEQUENCES[9] = "\\t";
      ESCAPE_SEQUENCES[10] = "\\n";
      ESCAPE_SEQUENCES[11] = "\\v";
      ESCAPE_SEQUENCES[12] = "\\f";
      ESCAPE_SEQUENCES[13] = "\\r";
      ESCAPE_SEQUENCES[27] = "\\e";
      ESCAPE_SEQUENCES[34] = '\\"';
      ESCAPE_SEQUENCES[92] = "\\\\";
      ESCAPE_SEQUENCES[133] = "\\N";
      ESCAPE_SEQUENCES[160] = "\\_";
      ESCAPE_SEQUENCES[8232] = "\\L";
      ESCAPE_SEQUENCES[8233] = "\\P";
      var DEPRECATED_BOOLEANS_SYNTAX = [
        "y",
        "Y",
        "yes",
        "Yes",
        "YES",
        "on",
        "On",
        "ON",
        "n",
        "N",
        "no",
        "No",
        "NO",
        "off",
        "Off",
        "OFF"
      ];
      function compileStyleMap(schema, map) {
        var result, keys, index, length, tag2, style, type;
        if (map === null) return {};
        result = {};
        keys = Object.keys(map);
        for (index = 0, length = keys.length; index < length; index += 1) {
          tag2 = keys[index];
          style = String(map[tag2]);
          if (tag2.slice(0, 2) === "!!") {
            tag2 = "tag:yaml.org,2002:" + tag2.slice(2);
          }
          type = schema.compiledTypeMap["fallback"][tag2];
          if (type && _hasOwnProperty.call(type.styleAliases, style)) {
            style = type.styleAliases[style];
          }
          result[tag2] = style;
        }
        return result;
      }
      function encodeHex(character) {
        var string, handle, length;
        string = character.toString(16).toUpperCase();
        if (character <= 255) {
          handle = "x";
          length = 2;
        } else if (character <= 65535) {
          handle = "u";
          length = 4;
        } else if (character <= 4294967295) {
          handle = "U";
          length = 8;
        } else {
          throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
        }
        return "\\" + handle + common.repeat("0", length - string.length) + string;
      }
      function State(options3) {
        this.schema = options3["schema"] || DEFAULT_FULL_SCHEMA;
        this.indent = Math.max(1, options3["indent"] || 2);
        this.noArrayIndent = options3["noArrayIndent"] || false;
        this.skipInvalid = options3["skipInvalid"] || false;
        this.flowLevel = common.isNothing(options3["flowLevel"]) ? -1 : options3["flowLevel"];
        this.styleMap = compileStyleMap(this.schema, options3["styles"] || null);
        this.sortKeys = options3["sortKeys"] || false;
        this.lineWidth = options3["lineWidth"] || 80;
        this.noRefs = options3["noRefs"] || false;
        this.noCompatMode = options3["noCompatMode"] || false;
        this.condenseFlow = options3["condenseFlow"] || false;
        this.implicitTypes = this.schema.compiledImplicit;
        this.explicitTypes = this.schema.compiledExplicit;
        this.tag = null;
        this.result = "";
        this.duplicates = [];
        this.usedDuplicates = null;
      }
      function indentString(string, spaces) {
        var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
        while (position < length) {
          next = string.indexOf("\n", position);
          if (next === -1) {
            line = string.slice(position);
            position = length;
          } else {
            line = string.slice(position, next + 1);
            position = next + 1;
          }
          if (line.length && line !== "\n") result += ind;
          result += line;
        }
        return result;
      }
      function generateNextLine(state, level) {
        return "\n" + common.repeat(" ", state.indent * level);
      }
      function testImplicitResolving(state, str2) {
        var index, length, type;
        for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
          type = state.implicitTypes[index];
          if (type.resolve(str2)) {
            return true;
          }
        }
        return false;
      }
      function isWhitespace(c) {
        return c === CHAR_SPACE || c === CHAR_TAB;
      }
      function isPrintable(c) {
        return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
      }
      function isNsChar(c) {
        return isPrintable(c) && !isWhitespace(c) && c !== 65279 && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
      }
      function isPlainSafe(c, prev) {
        return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
      }
      function isPlainSafeFirst(c) {
        return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
      }
      function needIndentIndicator(string) {
        var leadingSpaceRe = /^\n* /;
        return leadingSpaceRe.test(string);
      }
      var STYLE_PLAIN = 1;
      var STYLE_SINGLE = 2;
      var STYLE_LITERAL = 3;
      var STYLE_FOLDED = 4;
      var STYLE_DOUBLE = 5;
      function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
        var i;
        var char, prev_char;
        var hasLineBreak = false;
        var hasFoldableLine = false;
        var shouldTrackWidth = lineWidth !== -1;
        var previousLineBreak = -1;
        var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
        if (singleLineOnly) {
          for (i = 0; i < string.length; i++) {
            char = string.charCodeAt(i);
            if (!isPrintable(char)) {
              return STYLE_DOUBLE;
            }
            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
            plain = plain && isPlainSafe(char, prev_char);
          }
        } else {
          for (i = 0; i < string.length; i++) {
            char = string.charCodeAt(i);
            if (char === CHAR_LINE_FEED) {
              hasLineBreak = true;
              if (shouldTrackWidth) {
                hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
                i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
                previousLineBreak = i;
              }
            } else if (!isPrintable(char)) {
              return STYLE_DOUBLE;
            }
            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
            plain = plain && isPlainSafe(char, prev_char);
          }
          hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
        }
        if (!hasLineBreak && !hasFoldableLine) {
          return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
        }
        if (indentPerLevel > 9 && needIndentIndicator(string)) {
          return STYLE_DOUBLE;
        }
        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
      }
      function writeScalar(state, string, level, iskey) {
        state.dump = function() {
          if (string.length === 0) {
            return "''";
          }
          if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
            return "'" + string + "'";
          }
          var indent = state.indent * Math.max(1, level);
          var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
          var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
          function testAmbiguity(string2) {
            return testImplicitResolving(state, string2);
          }
          switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
            case STYLE_PLAIN:
              return string;
            case STYLE_SINGLE:
              return "'" + string.replace(/'/g, "''") + "'";
            case STYLE_LITERAL:
              return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
            case STYLE_FOLDED:
              return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
            case STYLE_DOUBLE:
              return '"' + escapeString(string, lineWidth) + '"';
            default:
              throw new YAMLException("impossible error: invalid scalar style");
          }
        }();
      }
      function blockHeader(string, indentPerLevel) {
        var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
        var clip = string[string.length - 1] === "\n";
        var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
        var chomp = keep ? "+" : clip ? "" : "-";
        return indentIndicator + chomp + "\n";
      }
      function dropEndingNewline(string) {
        return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
      }
      function foldString(string, width) {
        var lineRe = /(\n+)([^\n]*)/g;
        var result = function() {
          var nextLF = string.indexOf("\n");
          nextLF = nextLF !== -1 ? nextLF : string.length;
          lineRe.lastIndex = nextLF;
          return foldLine(string.slice(0, nextLF), width);
        }();
        var prevMoreIndented = string[0] === "\n" || string[0] === " ";
        var moreIndented;
        var match;
        while (match = lineRe.exec(string)) {
          var prefix = match[1], line = match[2];
          moreIndented = line[0] === " ";
          result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
          prevMoreIndented = moreIndented;
        }
        return result;
      }
      function foldLine(line, width) {
        if (line === "" || line[0] === " ") return line;
        var breakRe = / [^ ]/g;
        var match;
        var start = 0, end, curr = 0, next = 0;
        var result = "";
        while (match = breakRe.exec(line)) {
          next = match.index;
          if (next - start > width) {
            end = curr > start ? curr : next;
            result += "\n" + line.slice(start, end);
            start = end + 1;
          }
          curr = next;
        }
        result += "\n";
        if (line.length - start > width && curr > start) {
          result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
        } else {
          result += line.slice(start);
        }
        return result.slice(1);
      }
      function escapeString(string) {
        var result = "";
        var char, nextChar;
        var escapeSeq;
        for (var i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (char >= 55296 && char <= 56319) {
            nextChar = string.charCodeAt(i + 1);
            if (nextChar >= 56320 && nextChar <= 57343) {
              result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
              i++;
              continue;
            }
          }
          escapeSeq = ESCAPE_SEQUENCES[char];
          result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
        }
        return result;
      }
      function writeFlowSequence(state, level, object) {
        var _result = "", _tag2 = state.tag, index, length;
        for (index = 0, length = object.length; index < length; index += 1) {
          if (writeNode(state, level, object[index], false, false)) {
            if (index !== 0) _result += "," + (!state.condenseFlow ? " " : "");
            _result += state.dump;
          }
        }
        state.tag = _tag2;
        state.dump = "[" + _result + "]";
      }
      function writeBlockSequence(state, level, object, compact) {
        var _result = "", _tag2 = state.tag, index, length;
        for (index = 0, length = object.length; index < length; index += 1) {
          if (writeNode(state, level + 1, object[index], true, true)) {
            if (!compact || index !== 0) {
              _result += generateNextLine(state, level);
            }
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
              _result += "-";
            } else {
              _result += "- ";
            }
            _result += state.dump;
          }
        }
        state.tag = _tag2;
        state.dump = _result || "[]";
      }
      function writeFlowMapping(state, level, object) {
        var _result = "", _tag2 = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          pairBuffer = "";
          if (index !== 0) pairBuffer += ", ";
          if (state.condenseFlow) pairBuffer += '"';
          objectKey = objectKeyList[index];
          objectValue = object[objectKey];
          if (!writeNode(state, level, objectKey, false, false)) {
            continue;
          }
          if (state.dump.length > 1024) pairBuffer += "? ";
          pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
          if (!writeNode(state, level, objectValue, false, false)) {
            continue;
          }
          pairBuffer += state.dump;
          _result += pairBuffer;
        }
        state.tag = _tag2;
        state.dump = "{" + _result + "}";
      }
      function writeBlockMapping(state, level, object, compact) {
        var _result = "", _tag2 = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
        if (state.sortKeys === true) {
          objectKeyList.sort();
        } else if (typeof state.sortKeys === "function") {
          objectKeyList.sort(state.sortKeys);
        } else if (state.sortKeys) {
          throw new YAMLException("sortKeys must be a boolean or a function");
        }
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          pairBuffer = "";
          if (!compact || index !== 0) {
            pairBuffer += generateNextLine(state, level);
          }
          objectKey = objectKeyList[index];
          objectValue = object[objectKey];
          if (!writeNode(state, level + 1, objectKey, true, true, true)) {
            continue;
          }
          explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
          if (explicitPair) {
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
              pairBuffer += "?";
            } else {
              pairBuffer += "? ";
            }
          }
          pairBuffer += state.dump;
          if (explicitPair) {
            pairBuffer += generateNextLine(state, level);
          }
          if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
            continue;
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += ":";
          } else {
            pairBuffer += ": ";
          }
          pairBuffer += state.dump;
          _result += pairBuffer;
        }
        state.tag = _tag2;
        state.dump = _result || "{}";
      }
      function detectType(state, object, explicit) {
        var _result, typeList, index, length, type, style;
        typeList = explicit ? state.explicitTypes : state.implicitTypes;
        for (index = 0, length = typeList.length; index < length; index += 1) {
          type = typeList[index];
          if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
            state.tag = explicit ? type.tag : "?";
            if (type.represent) {
              style = state.styleMap[type.tag] || type.defaultStyle;
              if (_toString.call(type.represent) === "[object Function]") {
                _result = type.represent(object, style);
              } else if (_hasOwnProperty.call(type.represent, style)) {
                _result = type.represent[style](object, style);
              } else {
                throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
              }
              state.dump = _result;
            }
            return true;
          }
        }
        return false;
      }
      function writeNode(state, level, object, block2, compact, iskey) {
        state.tag = null;
        state.dump = object;
        if (!detectType(state, object, false)) {
          detectType(state, object, true);
        }
        var type = _toString.call(state.dump);
        if (block2) {
          block2 = state.flowLevel < 0 || state.flowLevel > level;
        }
        var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
        if (objectOrArray) {
          duplicateIndex = state.duplicates.indexOf(object);
          duplicate = duplicateIndex !== -1;
        }
        if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
          compact = false;
        }
        if (duplicate && state.usedDuplicates[duplicateIndex]) {
          state.dump = "*ref_" + duplicateIndex;
        } else {
          if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
            state.usedDuplicates[duplicateIndex] = true;
          }
          if (type === "[object Object]") {
            if (block2 && Object.keys(state.dump).length !== 0) {
              writeBlockMapping(state, level, state.dump, compact);
              if (duplicate) {
                state.dump = "&ref_" + duplicateIndex + state.dump;
              }
            } else {
              writeFlowMapping(state, level, state.dump);
              if (duplicate) {
                state.dump = "&ref_" + duplicateIndex + " " + state.dump;
              }
            }
          } else if (type === "[object Array]") {
            var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
            if (block2 && state.dump.length !== 0) {
              writeBlockSequence(state, arrayLevel, state.dump, compact);
              if (duplicate) {
                state.dump = "&ref_" + duplicateIndex + state.dump;
              }
            } else {
              writeFlowSequence(state, arrayLevel, state.dump);
              if (duplicate) {
                state.dump = "&ref_" + duplicateIndex + " " + state.dump;
              }
            }
          } else if (type === "[object String]") {
            if (state.tag !== "?") {
              writeScalar(state, state.dump, level, iskey);
            }
          } else {
            if (state.skipInvalid) return false;
            throw new YAMLException("unacceptable kind of an object to dump " + type);
          }
          if (state.tag !== null && state.tag !== "?") {
            state.dump = "!<" + state.tag + "> " + state.dump;
          }
        }
        return true;
      }
      function getDuplicateReferences(object, state) {
        var objects = [], duplicatesIndexes = [], index, length;
        inspectNode(object, objects, duplicatesIndexes);
        for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
          state.duplicates.push(objects[duplicatesIndexes[index]]);
        }
        state.usedDuplicates = new Array(length);
      }
      function inspectNode(object, objects, duplicatesIndexes) {
        var objectKeyList, index, length;
        if (object !== null && typeof object === "object") {
          index = objects.indexOf(object);
          if (index !== -1) {
            if (duplicatesIndexes.indexOf(index) === -1) {
              duplicatesIndexes.push(index);
            }
          } else {
            objects.push(object);
            if (Array.isArray(object)) {
              for (index = 0, length = object.length; index < length; index += 1) {
                inspectNode(object[index], objects, duplicatesIndexes);
              }
            } else {
              objectKeyList = Object.keys(object);
              for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
              }
            }
          }
        }
      }
      function dump(input, options3) {
        options3 = options3 || {};
        var state = new State(options3);
        if (!state.noRefs) getDuplicateReferences(input, state);
        if (writeNode(state, 0, input, true, true)) return state.dump + "\n";
        return "";
      }
      function safeDump(input, options3) {
        return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options3));
      }
      module2.exports.dump = dump;
      module2.exports.safeDump = safeDump;
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml.js
  var require_js_yaml = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml.js"(exports2, module2) {
      "use strict";
      var loader = require_loader();
      var dumper = require_dumper();
      function deprecated(name) {
        return function() {
          throw new Error("Function " + name + " is deprecated and cannot be used.");
        };
      }
      module2.exports.Type = require_type();
      module2.exports.Schema = require_schema();
      module2.exports.FAILSAFE_SCHEMA = require_failsafe();
      module2.exports.JSON_SCHEMA = require_json();
      module2.exports.CORE_SCHEMA = require_core();
      module2.exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
      module2.exports.DEFAULT_FULL_SCHEMA = require_default_full();
      module2.exports.load = loader.load;
      module2.exports.loadAll = loader.loadAll;
      module2.exports.safeLoad = loader.safeLoad;
      module2.exports.safeLoadAll = loader.safeLoadAll;
      module2.exports.dump = dumper.dump;
      module2.exports.safeDump = dumper.safeDump;
      module2.exports.YAMLException = require_exception();
      module2.exports.MINIMAL_SCHEMA = require_failsafe();
      module2.exports.SAFE_SCHEMA = require_default_safe();
      module2.exports.DEFAULT_SCHEMA = require_default_full();
      module2.exports.scan = deprecated("scan");
      module2.exports.parse = deprecated("parse");
      module2.exports.compose = deprecated("compose");
      module2.exports.addConstructor = deprecated("addConstructor");
    }
  });

  // node_modules/gray-matter/node_modules/js-yaml/index.js
  var require_js_yaml2 = __commonJS({
    "node_modules/gray-matter/node_modules/js-yaml/index.js"(exports2, module2) {
      "use strict";
      var yaml2 = require_js_yaml();
      module2.exports = yaml2;
    }
  });

  // node_modules/gray-matter/lib/engines.js
  var require_engines = __commonJS({
    "node_modules/gray-matter/lib/engines.js"(exports, module) {
      "use strict";
      var yaml = require_js_yaml2();
      var engines = exports = module.exports;
      engines.yaml = {
        parse: yaml.safeLoad.bind(yaml),
        stringify: yaml.safeDump.bind(yaml)
      };
      engines.json = {
        parse: JSON.parse.bind(JSON),
        stringify: function(obj, options3) {
          const opts = Object.assign({ replacer: null, space: 2 }, options3);
          return JSON.stringify(obj, opts.replacer, opts.space);
        }
      };
      engines.javascript = {
        parse: function parse(str, options, wrap) {
          try {
            if (wrap !== false) {
              str = "(function() {\nreturn " + str.trim() + ";\n}());";
            }
            return eval(str) || {};
          } catch (err) {
            if (wrap !== false && /(unexpected|identifier)/i.test(err.message)) {
              return parse(str, options, false);
            }
            throw new SyntaxError(err);
          }
        },
        stringify: function() {
          throw new Error("stringifying JavaScript is not supported");
        }
      };
    }
  });

  // node_modules/strip-bom-string/index.js
  var require_strip_bom_string = __commonJS({
    "node_modules/strip-bom-string/index.js"(exports2, module2) {
      "use strict";
      module2.exports = function(str2) {
        if (typeof str2 === "string" && str2.charAt(0) === "\uFEFF") {
          return str2.slice(1);
        }
        return str2;
      };
    }
  });

  // node_modules/gray-matter/lib/utils.js
  var require_utils = __commonJS({
    "node_modules/gray-matter/lib/utils.js"(exports2) {
      "use strict";
      var stripBom = require_strip_bom_string();
      var typeOf = require_kind_of();
      exports2.define = function(obj, key, val) {
        Reflect.defineProperty(obj, key, {
          enumerable: false,
          configurable: true,
          writable: true,
          value: val
        });
      };
      exports2.isBuffer = function(val) {
        return typeOf(val) === "buffer";
      };
      exports2.isObject = function(val) {
        return typeOf(val) === "object";
      };
      exports2.toBuffer = function(input) {
        return typeof input === "string" ? Buffer.from(input) : input;
      };
      exports2.toString = function(input) {
        if (exports2.isBuffer(input)) return stripBom(String(input));
        if (typeof input !== "string") {
          throw new TypeError("expected input to be a string or buffer");
        }
        return stripBom(input);
      };
      exports2.arrayify = function(val) {
        return val ? Array.isArray(val) ? val : [val] : [];
      };
      exports2.startsWith = function(str2, substr, len) {
        if (typeof len !== "number") len = substr.length;
        return str2.slice(0, len) === substr;
      };
    }
  });

  // node_modules/gray-matter/lib/defaults.js
  var require_defaults = __commonJS({
    "node_modules/gray-matter/lib/defaults.js"(exports2, module2) {
      "use strict";
      var engines2 = require_engines();
      var utils = require_utils();
      module2.exports = function(options3) {
        const opts = Object.assign({}, options3);
        opts.delimiters = utils.arrayify(opts.delims || opts.delimiters || "---");
        if (opts.delimiters.length === 1) {
          opts.delimiters.push(opts.delimiters[0]);
        }
        opts.language = (opts.language || opts.lang || "yaml").toLowerCase();
        opts.engines = Object.assign({}, engines2, opts.parsers, opts.engines);
        return opts;
      };
    }
  });

  // node_modules/gray-matter/lib/engine.js
  var require_engine = __commonJS({
    "node_modules/gray-matter/lib/engine.js"(exports2, module2) {
      "use strict";
      module2.exports = function(name, options3) {
        let engine = options3.engines[name] || options3.engines[aliase(name)];
        if (typeof engine === "undefined") {
          throw new Error('gray-matter engine "' + name + '" is not registered');
        }
        if (typeof engine === "function") {
          engine = { parse: engine };
        }
        return engine;
      };
      function aliase(name) {
        switch (name.toLowerCase()) {
          case "js":
          case "javascript":
            return "javascript";
          case "coffee":
          case "coffeescript":
          case "cson":
            return "coffee";
          case "yaml":
          case "yml":
            return "yaml";
          default: {
            return name;
          }
        }
      }
    }
  });

  // node_modules/gray-matter/lib/stringify.js
  var require_stringify = __commonJS({
    "node_modules/gray-matter/lib/stringify.js"(exports2, module2) {
      "use strict";
      var typeOf = require_kind_of();
      var getEngine = require_engine();
      var defaults = require_defaults();
      module2.exports = function(file, data, options3) {
        if (data == null && options3 == null) {
          switch (typeOf(file)) {
            case "object":
              data = file.data;
              options3 = {};
              break;
            case "string":
              return file;
            default: {
              throw new TypeError("expected file to be a string or object");
            }
          }
        }
        const str2 = file.content;
        const opts = defaults(options3);
        if (data == null) {
          if (!opts.data) return file;
          data = opts.data;
        }
        const language = file.language || opts.language;
        const engine = getEngine(language, opts);
        if (typeof engine.stringify !== "function") {
          throw new TypeError('expected "' + language + '.stringify" to be a function');
        }
        data = Object.assign({}, file.data, data);
        const open = opts.delimiters[0];
        const close = opts.delimiters[1];
        const matter2 = engine.stringify(data, options3).trim();
        let buf = "";
        if (matter2 !== "{}") {
          buf = newline2(open) + newline2(matter2) + newline2(close);
        }
        if (typeof file.excerpt === "string" && file.excerpt !== "") {
          if (str2.indexOf(file.excerpt.trim()) === -1) {
            buf += newline2(file.excerpt) + newline2(close);
          }
        }
        return buf + newline2(str2);
      };
      function newline2(str2) {
        return str2.slice(-1) !== "\n" ? str2 + "\n" : str2;
      }
    }
  });

  // node_modules/gray-matter/lib/excerpt.js
  var require_excerpt = __commonJS({
    "node_modules/gray-matter/lib/excerpt.js"(exports2, module2) {
      "use strict";
      var defaults = require_defaults();
      module2.exports = function(file, options3) {
        const opts = defaults(options3);
        if (file.data == null) {
          file.data = {};
        }
        if (typeof opts.excerpt === "function") {
          return opts.excerpt(file, opts);
        }
        const sep = file.data.excerpt_separator || opts.excerpt_separator;
        if (sep == null && (opts.excerpt === false || opts.excerpt == null)) {
          return file;
        }
        const delimiter = typeof opts.excerpt === "string" ? opts.excerpt : sep || opts.delimiters[0];
        const idx = file.content.indexOf(delimiter);
        if (idx !== -1) {
          file.excerpt = file.content.slice(0, idx);
        }
        return file;
      };
    }
  });

  // node_modules/gray-matter/lib/to-file.js
  var require_to_file = __commonJS({
    "node_modules/gray-matter/lib/to-file.js"(exports2, module2) {
      "use strict";
      var typeOf = require_kind_of();
      var stringify = require_stringify();
      var utils = require_utils();
      module2.exports = function(file) {
        if (typeOf(file) !== "object") {
          file = { content: file };
        }
        if (typeOf(file.data) !== "object") {
          file.data = {};
        }
        if (file.contents && file.content == null) {
          file.content = file.contents;
        }
        utils.define(file, "orig", utils.toBuffer(file.content));
        utils.define(file, "language", file.language || "");
        utils.define(file, "matter", file.matter || "");
        utils.define(file, "stringify", function(data, options3) {
          if (options3 && options3.language) {
            file.language = options3.language;
          }
          return stringify(file, data, options3);
        });
        file.content = utils.toString(file.content);
        file.isEmpty = false;
        file.excerpt = "";
        return file;
      };
    }
  });

  // node_modules/gray-matter/lib/parse.js
  var require_parse = __commonJS({
    "node_modules/gray-matter/lib/parse.js"(exports2, module2) {
      "use strict";
      var getEngine = require_engine();
      var defaults = require_defaults();
      module2.exports = function(language, str2, options3) {
        const opts = defaults(options3);
        const engine = getEngine(language, opts);
        if (typeof engine.parse !== "function") {
          throw new TypeError('expected "' + language + '.parse" to be a function');
        }
        return engine.parse(str2, opts);
      };
    }
  });

  // node_modules/gray-matter/index.js
  var require_gray_matter = __commonJS({
    "node_modules/gray-matter/index.js"(exports2, module2) {
      "use strict";
      var fs = require_fs();
      var sections = require_section_matter();
      var defaults = require_defaults();
      var stringify = require_stringify();
      var excerpt = require_excerpt();
      var engines2 = require_engines();
      var toFile = require_to_file();
      var parse2 = require_parse();
      var utils = require_utils();
      function matter2(input, options3) {
        if (input === "") {
          return { data: {}, content: input, excerpt: "", orig: input };
        }
        let file = toFile(input);
        const cached = matter2.cache[file.content];
        if (!options3) {
          if (cached) {
            file = Object.assign({}, cached);
            file.orig = cached.orig;
            return file;
          }
          matter2.cache[file.content] = file;
        }
        return parseMatter(file, options3);
      }
      function parseMatter(file, options3) {
        const opts = defaults(options3);
        const open = opts.delimiters[0];
        const close = "\n" + opts.delimiters[1];
        let str2 = file.content;
        if (opts.language) {
          file.language = opts.language;
        }
        const openLen = open.length;
        if (!utils.startsWith(str2, open, openLen)) {
          excerpt(file, opts);
          return file;
        }
        if (str2.charAt(openLen) === open.slice(-1)) {
          return file;
        }
        str2 = str2.slice(openLen);
        const len = str2.length;
        const language = matter2.language(str2, opts);
        if (language.name) {
          file.language = language.name;
          str2 = str2.slice(language.raw.length);
        }
        let closeIndex = str2.indexOf(close);
        if (closeIndex === -1) {
          closeIndex = len;
        }
        file.matter = str2.slice(0, closeIndex);
        const block2 = file.matter.replace(/^\s*#[^\n]+/gm, "").trim();
        if (block2 === "") {
          file.isEmpty = true;
          file.empty = file.content;
          file.data = {};
        } else {
          file.data = parse2(file.language, file.matter, opts);
        }
        if (closeIndex === len) {
          file.content = "";
        } else {
          file.content = str2.slice(closeIndex + close.length);
          if (file.content[0] === "\r") {
            file.content = file.content.slice(1);
          }
          if (file.content[0] === "\n") {
            file.content = file.content.slice(1);
          }
        }
        excerpt(file, opts);
        if (opts.sections === true || typeof opts.section === "function") {
          sections(file, opts.section);
        }
        return file;
      }
      matter2.engines = engines2;
      matter2.stringify = function(file, data, options3) {
        if (typeof file === "string") file = matter2(file, options3);
        return stringify(file, data, options3);
      };
      matter2.read = function(filepath, options3) {
        const str2 = fs.readFileSync(filepath, "utf8");
        const file = matter2(str2, options3);
        file.path = filepath;
        return file;
      };
      matter2.test = function(str2, options3) {
        return utils.startsWith(str2, defaults(options3).delimiters[0]);
      };
      matter2.language = function(str2, options3) {
        const opts = defaults(options3);
        const open = opts.delimiters[0];
        if (matter2.test(str2)) {
          str2 = str2.slice(open.length);
        }
        const language = str2.slice(0, str2.search(/\r?\n/));
        return {
          raw: language,
          name: language ? language.trim() : ""
        };
      };
      matter2.cache = {};
      matter2.clearCache = function() {
        matter2.cache = {};
      };
      module2.exports = matter2;
    }
  });

  // apps/my-cv/web/resume/index.tsx
  init_src2();

  // node_modules/lupine.press/src/components/lang-switcher.tsx
  init_src();
  init_src2();

  // node_modules/lupine.press/src/styles/lang.svg
  var lang_default = "<svg viewBox='0 0 24 24' width='20' height='20' fill='currentColor'>\r\n    <path d='M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z' />\r\n</svg>\r\n";

  // node_modules/lupine.press/src/components/lang-switcher.tsx
  init_src2();

  // node_modules/lupine.press/src/services/cache.ts
  var _cache = {};
  var bindPressData = (pressData) => {
    _cache.data = pressData;
  };
  var getPressData = () => {
    return _cache.data;
  };
  var getSidebarScroll = () => {
    return _cache.sidebarScroll || 0;
  };
  var setSidebarScroll = (val) => {
    _cache.sidebarScroll = val;
  };
  var setPressSubDir = (val) => {
    _cache.subDir = val;
  };
  var getPressSubDir = () => {
    return _cache.subDir || "";
  };
  var setPressLangs = (val) => {
    _cache.langs = val;
  };
  var getPressLangs = () => {
    return _cache.langs || [
      { title: "English", id: "en" },
      { title: "Chinese", id: "zh" }
    ];
  };

  // node_modules/lupine.press/node_modules/marked/lib/marked.esm.js
  function _getDefaults() {
    return {
      async: false,
      breaks: false,
      extensions: null,
      gfm: true,
      hooks: null,
      pedantic: false,
      renderer: null,
      silent: false,
      tokenizer: null,
      walkTokens: null
    };
  }
  var _defaults = _getDefaults();
  function changeDefaults(newDefaults) {
    _defaults = newDefaults;
  }
  var noopTest = { exec: () => null };
  function edit(regex, opt = "") {
    let source = typeof regex === "string" ? regex : regex.source;
    const obj = {
      replace: (name, val) => {
        let valSource = typeof val === "string" ? val : val.source;
        valSource = valSource.replace(other.caret, "$1");
        source = source.replace(name, valSource);
        return obj;
      },
      getRegex: () => {
        return new RegExp(source, opt);
      }
    };
    return obj;
  }
  var other = {
    codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
    outputLinkReplace: /\\([\[\]])/g,
    indentCodeCompensation: /^(\s+)(?:```)/,
    beginningSpace: /^\s+/,
    endingHash: /#$/,
    startingSpaceChar: /^ /,
    endingSpaceChar: / $/,
    nonSpaceChar: /[^ ]/,
    newLineCharGlobal: /\n/g,
    tabCharGlobal: /\t/g,
    multipleSpaceGlobal: /\s+/g,
    blankLine: /^[ \t]*$/,
    doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
    blockquoteStart: /^ {0,3}>/,
    blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
    blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
    listReplaceTabs: /^\t+/,
    listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
    listIsTask: /^\[[ xX]\] /,
    listReplaceTask: /^\[[ xX]\] +/,
    anyLine: /\n.*\n/,
    hrefBrackets: /^<(.*)>$/,
    tableDelimiter: /[:|]/,
    tableAlignChars: /^\||\| *$/g,
    tableRowBlankLine: /\n[ \t]*$/,
    tableAlignRight: /^ *-+: *$/,
    tableAlignCenter: /^ *:-+: *$/,
    tableAlignLeft: /^ *:-+ *$/,
    startATag: /^<a /i,
    endATag: /^<\/a>/i,
    startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
    endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
    startAngleBracket: /^</,
    endAngleBracket: />$/,
    pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
    unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
    escapeTest: /[&<>"']/,
    escapeReplace: /[&<>"']/g,
    escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
    escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
    unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
    caret: /(^|[^\[])\^/g,
    percentDecode: /%25/g,
    findPipe: /\|/g,
    splitPipe: / \|/,
    slashPipe: /\\\|/g,
    carriageReturn: /\r\n|\r/g,
    spaceLine: /^ +$/gm,
    notSpaceStart: /^\S*/,
    endingNewline: /\n$/,
    listItemRegex: (bull) => new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`),
    nextBulletRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
    hrRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
    fencesBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`),
    headingBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),
    htmlBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, "i")
  };
  var newline = /^(?:[ \t]*(?:\n|$))+/;
  var blockCode = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
  var fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
  var hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
  var heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
  var bullet = /(?:[*+-]|\d{1,9}[.)])/;
  var lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
  var lheading = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex();
  var lheadingGfm = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex();
  var _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
  var blockText = /^[^\n]+/;
  var _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
  var def = edit(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
  var list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
  var _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
  var _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
  var html = edit(
    "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))",
    "i"
  ).replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  var paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
  var blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex();
  var blockNormal = {
    blockquote,
    code: blockCode,
    def,
    fences,
    heading,
    hr,
    html,
    lheading,
    list,
    newline,
    paragraph,
    table: noopTest,
    text: blockText
  };
  var gfmTable = edit(
    "^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  ).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
  var blockGfm = {
    ...blockNormal,
    lheading: lheadingGfm,
    table: gfmTable,
    paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
  };
  var blockPedantic = {
    ...blockNormal,
    html: edit(
      `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
    ).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest,
    // fences not supported
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
  };
  var escape2 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
  var inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
  var br = /^( {2,}|\\)\n(?!\s*$)/;
  var inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
  var _punctuation = /[\p{P}\p{S}]/u;
  var _punctuationOrSpace = /[\s\p{P}\p{S}]/u;
  var _notPunctuationOrSpace = /[^\s\p{P}\p{S}]/u;
  var punctuation = edit(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, _punctuationOrSpace).getRegex();
  var _punctuationGfmStrongEm = /(?!~)[\p{P}\p{S}]/u;
  var _punctuationOrSpaceGfmStrongEm = /(?!~)[\s\p{P}\p{S}]/u;
  var _notPunctuationOrSpaceGfmStrongEm = /(?:[^\s\p{P}\p{S}]|~)/u;
  var blockSkip = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g;
  var emStrongLDelimCore = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
  var emStrongLDelim = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuation).getRegex();
  var emStrongLDelimGfm = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuationGfmStrongEm).getRegex();
  var emStrongRDelimAstCore = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)";
  var emStrongRDelimAst = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
  var emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm).replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm).replace(/punct/g, _punctuationGfmStrongEm).getRegex();
  var emStrongRDelimUnd = edit(
    "^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)",
    "gu"
  ).replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
  var anyPunctuation = edit(/\\(punct)/, "gu").replace(/punct/g, _punctuation).getRegex();
  var autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
  var _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex();
  var tag = edit(
    "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>"
  ).replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
  var _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  var link = edit(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
  var reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex();
  var nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex();
  var reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex();
  var inlineNormal = {
    _backpedal: noopTest,
    // only used for GFM url
    anyPunctuation,
    autolink,
    blockSkip,
    br,
    code: inlineCode,
    del: noopTest,
    emStrongLDelim,
    emStrongRDelimAst,
    emStrongRDelimUnd,
    escape: escape2,
    link,
    nolink,
    punctuation,
    reflink,
    reflinkSearch,
    tag,
    text: inlineText,
    url: noopTest
  };
  var inlinePedantic = {
    ...inlineNormal,
    link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
  };
  var inlineGfm = {
    ...inlineNormal,
    emStrongRDelimAst: emStrongRDelimAstGfm,
    emStrongLDelim: emStrongLDelimGfm,
    url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
  };
  var inlineBreaks = {
    ...inlineGfm,
    br: edit(br).replace("{2,}", "*").getRegex(),
    text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
  };
  var block = {
    normal: blockNormal,
    gfm: blockGfm,
    pedantic: blockPedantic
  };
  var inline = {
    normal: inlineNormal,
    gfm: inlineGfm,
    breaks: inlineBreaks,
    pedantic: inlinePedantic
  };
  var escapeReplacements = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  var getEscapeReplacement = (ch) => escapeReplacements[ch];
  function escape22(html2, encode) {
    if (encode) {
      if (other.escapeTest.test(html2)) {
        return html2.replace(other.escapeReplace, getEscapeReplacement);
      }
    } else {
      if (other.escapeTestNoEncode.test(html2)) {
        return html2.replace(other.escapeReplaceNoEncode, getEscapeReplacement);
      }
    }
    return html2;
  }
  function cleanUrl(href) {
    try {
      href = encodeURI(href).replace(other.percentDecode, "%");
    } catch {
      return null;
    }
    return href;
  }
  function splitCells(tableRow, count) {
    var _a;
    const row = tableRow.replace(other.findPipe, (match, offset, str2) => {
      let escaped = false;
      let curr = offset;
      while (--curr >= 0 && str2[curr] === "\\") escaped = !escaped;
      if (escaped) {
        return "|";
      } else {
        return " |";
      }
    }), cells = row.split(other.splitPipe);
    let i = 0;
    if (!cells[0].trim()) {
      cells.shift();
    }
    if (cells.length > 0 && !((_a = cells.at(-1)) == null ? void 0 : _a.trim())) {
      cells.pop();
    }
    if (count) {
      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count) cells.push("");
      }
    }
    for (; i < cells.length; i++) {
      cells[i] = cells[i].trim().replace(other.slashPipe, "|");
    }
    return cells;
  }
  function rtrim(str2, c, invert) {
    const l = str2.length;
    if (l === 0) {
      return "";
    }
    let suffLen = 0;
    while (suffLen < l) {
      const currChar = str2.charAt(l - suffLen - 1);
      if (currChar === c && !invert) {
        suffLen++;
      } else if (currChar !== c && invert) {
        suffLen++;
      } else {
        break;
      }
    }
    return str2.slice(0, l - suffLen);
  }
  function findClosingBracket(str2, b) {
    if (str2.indexOf(b[1]) === -1) {
      return -1;
    }
    let level = 0;
    for (let i = 0; i < str2.length; i++) {
      if (str2[i] === "\\") {
        i++;
      } else if (str2[i] === b[0]) {
        level++;
      } else if (str2[i] === b[1]) {
        level--;
        if (level < 0) {
          return i;
        }
      }
    }
    if (level > 0) {
      return -2;
    }
    return -1;
  }
  function outputLink(cap, link2, raw, lexer2, rules) {
    const href = link2.href;
    const title = link2.title || null;
    const text = cap[1].replace(rules.other.outputLinkReplace, "$1");
    lexer2.state.inLink = true;
    const token = {
      type: cap[0].charAt(0) === "!" ? "image" : "link",
      raw,
      href,
      title,
      text,
      tokens: lexer2.inlineTokens(text)
    };
    lexer2.state.inLink = false;
    return token;
  }
  function indentCodeCompensation(raw, text, rules) {
    const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);
    if (matchIndentToCode === null) {
      return text;
    }
    const indentToCode = matchIndentToCode[1];
    return text.split("\n").map((node) => {
      const matchIndentInNode = node.match(rules.other.beginningSpace);
      if (matchIndentInNode === null) {
        return node;
      }
      const [indentInNode] = matchIndentInNode;
      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }
      return node;
    }).join("\n");
  }
  var _Tokenizer = class {
    options;
    rules;
    // set by the lexer
    lexer;
    // set by the lexer
    constructor(options22) {
      this.options = options22 || _defaults;
    }
    space(src) {
      const cap = this.rules.block.newline.exec(src);
      if (cap && cap[0].length > 0) {
        return {
          type: "space",
          raw: cap[0]
        };
      }
    }
    code(src) {
      const cap = this.rules.block.code.exec(src);
      if (cap) {
        const text = cap[0].replace(this.rules.other.codeRemoveIndent, "");
        return {
          type: "code",
          raw: cap[0],
          codeBlockStyle: "indented",
          text: !this.options.pedantic ? rtrim(text, "\n") : text
        };
      }
    }
    fences(src) {
      const cap = this.rules.block.fences.exec(src);
      if (cap) {
        const raw = cap[0];
        const text = indentCodeCompensation(raw, cap[3] || "", this.rules);
        return {
          type: "code",
          raw,
          lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cap[2],
          text
        };
      }
    }
    heading(src) {
      const cap = this.rules.block.heading.exec(src);
      if (cap) {
        let text = cap[2].trim();
        if (this.rules.other.endingHash.test(text)) {
          const trimmed = rtrim(text, "#");
          if (this.options.pedantic) {
            text = trimmed.trim();
          } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {
            text = trimmed.trim();
          }
        }
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[1].length,
          text,
          tokens: this.lexer.inline(text)
        };
      }
    }
    hr(src) {
      const cap = this.rules.block.hr.exec(src);
      if (cap) {
        return {
          type: "hr",
          raw: rtrim(cap[0], "\n")
        };
      }
    }
    blockquote(src) {
      const cap = this.rules.block.blockquote.exec(src);
      if (cap) {
        let lines = rtrim(cap[0], "\n").split("\n");
        let raw = "";
        let text = "";
        const tokens = [];
        while (lines.length > 0) {
          let inBlockquote = false;
          const currentLines = [];
          let i;
          for (i = 0; i < lines.length; i++) {
            if (this.rules.other.blockquoteStart.test(lines[i])) {
              currentLines.push(lines[i]);
              inBlockquote = true;
            } else if (!inBlockquote) {
              currentLines.push(lines[i]);
            } else {
              break;
            }
          }
          lines = lines.slice(i);
          const currentRaw = currentLines.join("\n");
          const currentText = currentRaw.replace(this.rules.other.blockquoteSetextReplace, "\n    $1").replace(this.rules.other.blockquoteSetextReplace2, "");
          raw = raw ? `${raw}
${currentRaw}` : currentRaw;
          text = text ? `${text}
${currentText}` : currentText;
          const top = this.lexer.state.top;
          this.lexer.state.top = true;
          this.lexer.blockTokens(currentText, tokens, true);
          this.lexer.state.top = top;
          if (lines.length === 0) {
            break;
          }
          const lastToken = tokens.at(-1);
          if ((lastToken == null ? void 0 : lastToken.type) === "code") {
            break;
          } else if ((lastToken == null ? void 0 : lastToken.type) === "blockquote") {
            const oldToken = lastToken;
            const newText = oldToken.raw + "\n" + lines.join("\n");
            const newToken = this.blockquote(newText);
            tokens[tokens.length - 1] = newToken;
            raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;
            text = text.substring(0, text.length - oldToken.text.length) + newToken.text;
            break;
          } else if ((lastToken == null ? void 0 : lastToken.type) === "list") {
            const oldToken = lastToken;
            const newText = oldToken.raw + "\n" + lines.join("\n");
            const newToken = this.list(newText);
            tokens[tokens.length - 1] = newToken;
            raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;
            text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;
            lines = newText.substring(tokens.at(-1).raw.length).split("\n");
            continue;
          }
        }
        return {
          type: "blockquote",
          raw,
          tokens,
          text
        };
      }
    }
    list(src) {
      let cap = this.rules.block.list.exec(src);
      if (cap) {
        let bull = cap[1].trim();
        const isordered = bull.length > 1;
        const list2 = {
          type: "list",
          raw: "",
          ordered: isordered,
          start: isordered ? +bull.slice(0, -1) : "",
          loose: false,
          items: []
        };
        bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
        if (this.options.pedantic) {
          bull = isordered ? bull : "[*+-]";
        }
        const itemRegex = this.rules.other.listItemRegex(bull);
        let endsWithBlankLine = false;
        while (src) {
          let endEarly = false;
          let raw = "";
          let itemContents = "";
          if (!(cap = itemRegex.exec(src))) {
            break;
          }
          if (this.rules.block.hr.test(src)) {
            break;
          }
          raw = cap[0];
          src = src.substring(raw.length);
          let line = cap[2].split("\n", 1)[0].replace(this.rules.other.listReplaceTabs, (t) => " ".repeat(3 * t.length));
          let nextLine = src.split("\n", 1)[0];
          let blankLine = !line.trim();
          let indent = 0;
          if (this.options.pedantic) {
            indent = 2;
            itemContents = line.trimStart();
          } else if (blankLine) {
            indent = cap[1].length + 1;
          } else {
            indent = cap[2].search(this.rules.other.nonSpaceChar);
            indent = indent > 4 ? 1 : indent;
            itemContents = line.slice(indent);
            indent += cap[1].length;
          }
          if (blankLine && this.rules.other.blankLine.test(nextLine)) {
            raw += nextLine + "\n";
            src = src.substring(nextLine.length + 1);
            endEarly = true;
          }
          if (!endEarly) {
            const nextBulletRegex = this.rules.other.nextBulletRegex(indent);
            const hrRegex = this.rules.other.hrRegex(indent);
            const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);
            const headingBeginRegex = this.rules.other.headingBeginRegex(indent);
            const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);
            while (src) {
              const rawLine = src.split("\n", 1)[0];
              let nextLineWithoutTabs;
              nextLine = rawLine;
              if (this.options.pedantic) {
                nextLine = nextLine.replace(this.rules.other.listReplaceNesting, "  ");
                nextLineWithoutTabs = nextLine;
              } else {
                nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, "    ");
              }
              if (fencesBeginRegex.test(nextLine)) {
                break;
              }
              if (headingBeginRegex.test(nextLine)) {
                break;
              }
              if (htmlBeginRegex.test(nextLine)) {
                break;
              }
              if (nextBulletRegex.test(nextLine)) {
                break;
              }
              if (hrRegex.test(nextLine)) {
                break;
              }
              if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) {
                itemContents += "\n" + nextLineWithoutTabs.slice(indent);
              } else {
                if (blankLine) {
                  break;
                }
                if (line.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4) {
                  break;
                }
                if (fencesBeginRegex.test(line)) {
                  break;
                }
                if (headingBeginRegex.test(line)) {
                  break;
                }
                if (hrRegex.test(line)) {
                  break;
                }
                itemContents += "\n" + nextLine;
              }
              if (!blankLine && !nextLine.trim()) {
                blankLine = true;
              }
              raw += rawLine + "\n";
              src = src.substring(rawLine.length + 1);
              line = nextLineWithoutTabs.slice(indent);
            }
          }
          if (!list2.loose) {
            if (endsWithBlankLine) {
              list2.loose = true;
            } else if (this.rules.other.doubleBlankLine.test(raw)) {
              endsWithBlankLine = true;
            }
          }
          let istask = null;
          let ischecked;
          if (this.options.gfm) {
            istask = this.rules.other.listIsTask.exec(itemContents);
            if (istask) {
              ischecked = istask[0] !== "[ ] ";
              itemContents = itemContents.replace(this.rules.other.listReplaceTask, "");
            }
          }
          list2.items.push({
            type: "list_item",
            raw,
            task: !!istask,
            checked: ischecked,
            loose: false,
            text: itemContents,
            tokens: []
          });
          list2.raw += raw;
        }
        const lastItem = list2.items.at(-1);
        if (lastItem) {
          lastItem.raw = lastItem.raw.trimEnd();
          lastItem.text = lastItem.text.trimEnd();
        } else {
          return;
        }
        list2.raw = list2.raw.trimEnd();
        for (let i = 0; i < list2.items.length; i++) {
          this.lexer.state.top = false;
          list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
          if (!list2.loose) {
            const spacers = list2.items[i].tokens.filter((t) => t.type === "space");
            const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => this.rules.other.anyLine.test(t.raw));
            list2.loose = hasMultipleLineBreaks;
          }
        }
        if (list2.loose) {
          for (let i = 0; i < list2.items.length; i++) {
            list2.items[i].loose = true;
          }
        }
        return list2;
      }
    }
    html(src) {
      const cap = this.rules.block.html.exec(src);
      if (cap) {
        const token = {
          type: "html",
          block: true,
          raw: cap[0],
          pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
          text: cap[0]
        };
        return token;
      }
    }
    def(src) {
      const cap = this.rules.block.def.exec(src);
      if (cap) {
        const tag2 = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " ");
        const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "";
        const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cap[3];
        return {
          type: "def",
          tag: tag2,
          raw: cap[0],
          href,
          title
        };
      }
    }
    table(src) {
      var _a;
      const cap = this.rules.block.table.exec(src);
      if (!cap) {
        return;
      }
      if (!this.rules.other.tableDelimiter.test(cap[2])) {
        return;
      }
      const headers = splitCells(cap[1]);
      const aligns = cap[2].replace(this.rules.other.tableAlignChars, "").split("|");
      const rows = ((_a = cap[3]) == null ? void 0 : _a.trim()) ? cap[3].replace(this.rules.other.tableRowBlankLine, "").split("\n") : [];
      const item = {
        type: "table",
        raw: cap[0],
        header: [],
        align: [],
        rows: []
      };
      if (headers.length !== aligns.length) {
        return;
      }
      for (const align of aligns) {
        if (this.rules.other.tableAlignRight.test(align)) {
          item.align.push("right");
        } else if (this.rules.other.tableAlignCenter.test(align)) {
          item.align.push("center");
        } else if (this.rules.other.tableAlignLeft.test(align)) {
          item.align.push("left");
        } else {
          item.align.push(null);
        }
      }
      for (let i = 0; i < headers.length; i++) {
        item.header.push({
          text: headers[i],
          tokens: this.lexer.inline(headers[i]),
          header: true,
          align: item.align[i]
        });
      }
      for (const row of rows) {
        item.rows.push(splitCells(row, item.header.length).map((cell, i) => {
          return {
            text: cell,
            tokens: this.lexer.inline(cell),
            header: false,
            align: item.align[i]
          };
        }));
      }
      return item;
    }
    lheading(src) {
      const cap = this.rules.block.lheading.exec(src);
      if (cap) {
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[2].charAt(0) === "=" ? 1 : 2,
          text: cap[1],
          tokens: this.lexer.inline(cap[1])
        };
      }
    }
    paragraph(src) {
      const cap = this.rules.block.paragraph.exec(src);
      if (cap) {
        const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
        return {
          type: "paragraph",
          raw: cap[0],
          text,
          tokens: this.lexer.inline(text)
        };
      }
    }
    text(src) {
      const cap = this.rules.block.text.exec(src);
      if (cap) {
        return {
          type: "text",
          raw: cap[0],
          text: cap[0],
          tokens: this.lexer.inline(cap[0])
        };
      }
    }
    escape(src) {
      const cap = this.rules.inline.escape.exec(src);
      if (cap) {
        return {
          type: "escape",
          raw: cap[0],
          text: cap[1]
        };
      }
    }
    tag(src) {
      const cap = this.rules.inline.tag.exec(src);
      if (cap) {
        if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {
          this.lexer.state.inLink = true;
        } else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {
          this.lexer.state.inLink = false;
        }
        if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {
          this.lexer.state.inRawBlock = true;
        } else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {
          this.lexer.state.inRawBlock = false;
        }
        return {
          type: "html",
          raw: cap[0],
          inLink: this.lexer.state.inLink,
          inRawBlock: this.lexer.state.inRawBlock,
          block: false,
          text: cap[0]
        };
      }
    }
    link(src) {
      const cap = this.rules.inline.link.exec(src);
      if (cap) {
        const trimmedUrl = cap[2].trim();
        if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {
          if (!this.rules.other.endAngleBracket.test(trimmedUrl)) {
            return;
          }
          const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
            return;
          }
        } else {
          const lastParenIndex = findClosingBracket(cap[2], "()");
          if (lastParenIndex === -2) {
            return;
          }
          if (lastParenIndex > -1) {
            const start = cap[0].indexOf("!") === 0 ? 5 : 4;
            const linkLen = start + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = "";
          }
        }
        let href = cap[2];
        let title = "";
        if (this.options.pedantic) {
          const link2 = this.rules.other.pedanticHrefTitle.exec(href);
          if (link2) {
            href = link2[1];
            title = link2[3];
          }
        } else {
          title = cap[3] ? cap[3].slice(1, -1) : "";
        }
        href = href.trim();
        if (this.rules.other.startAngleBracket.test(href)) {
          if (this.options.pedantic && !this.rules.other.endAngleBracket.test(trimmedUrl)) {
            href = href.slice(1);
          } else {
            href = href.slice(1, -1);
          }
        }
        return outputLink(cap, {
          href: href ? href.replace(this.rules.inline.anyPunctuation, "$1") : href,
          title: title ? title.replace(this.rules.inline.anyPunctuation, "$1") : title
        }, cap[0], this.lexer, this.rules);
      }
    }
    reflink(src, links) {
      let cap;
      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
        const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, " ");
        const link2 = links[linkString.toLowerCase()];
        if (!link2) {
          const text = cap[0].charAt(0);
          return {
            type: "text",
            raw: text,
            text
          };
        }
        return outputLink(cap, link2, cap[0], this.lexer, this.rules);
      }
    }
    emStrong(src, maskedSrc, prevChar = "") {
      let match = this.rules.inline.emStrongLDelim.exec(src);
      if (!match) return;
      if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric)) return;
      const nextChar = match[1] || match[2] || "";
      if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
        const lLength = [...match[0]].length - 1;
        let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
        const endReg = match[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
        endReg.lastIndex = 0;
        maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
        while ((match = endReg.exec(maskedSrc)) != null) {
          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
          if (!rDelim) continue;
          rLength = [...rDelim].length;
          if (match[3] || match[4]) {
            delimTotal += rLength;
            continue;
          } else if (match[5] || match[6]) {
            if (lLength % 3 && !((lLength + rLength) % 3)) {
              midDelimTotal += rLength;
              continue;
            }
          }
          delimTotal -= rLength;
          if (delimTotal > 0) continue;
          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
          const lastCharLength = [...match[0]][0].length;
          const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
          if (Math.min(lLength, rLength) % 2) {
            const text2 = raw.slice(1, -1);
            return {
              type: "em",
              raw,
              text: text2,
              tokens: this.lexer.inlineTokens(text2)
            };
          }
          const text = raw.slice(2, -2);
          return {
            type: "strong",
            raw,
            text,
            tokens: this.lexer.inlineTokens(text)
          };
        }
      }
    }
    codespan(src) {
      const cap = this.rules.inline.code.exec(src);
      if (cap) {
        let text = cap[2].replace(this.rules.other.newLineCharGlobal, " ");
        const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);
        const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);
        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
          text = text.substring(1, text.length - 1);
        }
        return {
          type: "codespan",
          raw: cap[0],
          text
        };
      }
    }
    br(src) {
      const cap = this.rules.inline.br.exec(src);
      if (cap) {
        return {
          type: "br",
          raw: cap[0]
        };
      }
    }
    del(src) {
      const cap = this.rules.inline.del.exec(src);
      if (cap) {
        return {
          type: "del",
          raw: cap[0],
          text: cap[2],
          tokens: this.lexer.inlineTokens(cap[2])
        };
      }
    }
    autolink(src) {
      const cap = this.rules.inline.autolink.exec(src);
      if (cap) {
        let text, href;
        if (cap[2] === "@") {
          text = cap[1];
          href = "mailto:" + text;
        } else {
          text = cap[1];
          href = text;
        }
        return {
          type: "link",
          raw: cap[0],
          text,
          href,
          tokens: [
            {
              type: "text",
              raw: text,
              text
            }
          ]
        };
      }
    }
    url(src) {
      var _a;
      let cap;
      if (cap = this.rules.inline.url.exec(src)) {
        let text, href;
        if (cap[2] === "@") {
          text = cap[0];
          href = "mailto:" + text;
        } else {
          let prevCapZero;
          do {
            prevCapZero = cap[0];
            cap[0] = ((_a = this.rules.inline._backpedal.exec(cap[0])) == null ? void 0 : _a[0]) ?? "";
          } while (prevCapZero !== cap[0]);
          text = cap[0];
          if (cap[1] === "www.") {
            href = "http://" + cap[0];
          } else {
            href = cap[0];
          }
        }
        return {
          type: "link",
          raw: cap[0],
          text,
          href,
          tokens: [
            {
              type: "text",
              raw: text,
              text
            }
          ]
        };
      }
    }
    inlineText(src) {
      const cap = this.rules.inline.text.exec(src);
      if (cap) {
        const escaped = this.lexer.state.inRawBlock;
        return {
          type: "text",
          raw: cap[0],
          text: cap[0],
          escaped
        };
      }
    }
  };
  var _Lexer = class __Lexer {
    tokens;
    options;
    state;
    tokenizer;
    inlineQueue;
    constructor(options22) {
      this.tokens = [];
      this.tokens.links = /* @__PURE__ */ Object.create(null);
      this.options = options22 || _defaults;
      this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      this.tokenizer.lexer = this;
      this.inlineQueue = [];
      this.state = {
        inLink: false,
        inRawBlock: false,
        top: true
      };
      const rules = {
        other,
        block: block.normal,
        inline: inline.normal
      };
      if (this.options.pedantic) {
        rules.block = block.pedantic;
        rules.inline = inline.pedantic;
      } else if (this.options.gfm) {
        rules.block = block.gfm;
        if (this.options.breaks) {
          rules.inline = inline.breaks;
        } else {
          rules.inline = inline.gfm;
        }
      }
      this.tokenizer.rules = rules;
    }
    /**
     * Expose Rules
     */
    static get rules() {
      return {
        block,
        inline
      };
    }
    /**
     * Static Lex Method
     */
    static lex(src, options22) {
      const lexer2 = new __Lexer(options22);
      return lexer2.lex(src);
    }
    /**
     * Static Lex Inline Method
     */
    static lexInline(src, options22) {
      const lexer2 = new __Lexer(options22);
      return lexer2.inlineTokens(src);
    }
    /**
     * Preprocessing
     */
    lex(src) {
      src = src.replace(other.carriageReturn, "\n");
      this.blockTokens(src, this.tokens);
      for (let i = 0; i < this.inlineQueue.length; i++) {
        const next = this.inlineQueue[i];
        this.inlineTokens(next.src, next.tokens);
      }
      this.inlineQueue = [];
      return this.tokens;
    }
    blockTokens(src, tokens = [], lastParagraphClipped = false) {
      var _a, _b, _c;
      if (this.options.pedantic) {
        src = src.replace(other.tabCharGlobal, "    ").replace(other.spaceLine, "");
      }
      while (src) {
        let token;
        if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.block) == null ? void 0 : _b.some((extTokenizer) => {
          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.space(src)) {
          src = src.substring(token.raw.length);
          const lastToken = tokens.at(-1);
          if (token.raw.length === 1 && lastToken !== void 0) {
            lastToken.raw += "\n";
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.code(src)) {
          src = src.substring(token.raw.length);
          const lastToken = tokens.at(-1);
          if ((lastToken == null ? void 0 : lastToken.type) === "paragraph" || (lastToken == null ? void 0 : lastToken.type) === "text") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.at(-1).src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.fences(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.heading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.hr(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.blockquote(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.list(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.html(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.def(src)) {
          src = src.substring(token.raw.length);
          const lastToken = tokens.at(-1);
          if ((lastToken == null ? void 0 : lastToken.type) === "paragraph" || (lastToken == null ? void 0 : lastToken.type) === "text") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.raw;
            this.inlineQueue.at(-1).src = lastToken.text;
          } else if (!this.tokens.links[token.tag]) {
            this.tokens.links[token.tag] = {
              href: token.href,
              title: token.title
            };
          }
          continue;
        }
        if (token = this.tokenizer.table(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.lheading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        let cutSrc = src;
        if ((_c = this.options.extensions) == null ? void 0 : _c.startBlock) {
          let startIndex = Infinity;
          const tempSrc = src.slice(1);
          let tempStart;
          this.options.extensions.startBlock.forEach((getStartIndex) => {
            tempStart = getStartIndex.call({ lexer: this }, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        }
        if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
          const lastToken = tokens.at(-1);
          if (lastParagraphClipped && (lastToken == null ? void 0 : lastToken.type) === "paragraph") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue.at(-1).src = lastToken.text;
          } else {
            tokens.push(token);
          }
          lastParagraphClipped = cutSrc.length !== src.length;
          src = src.substring(token.raw.length);
          continue;
        }
        if (token = this.tokenizer.text(src)) {
          src = src.substring(token.raw.length);
          const lastToken = tokens.at(-1);
          if ((lastToken == null ? void 0 : lastToken.type) === "text") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue.at(-1).src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      this.state.top = true;
      return tokens;
    }
    inline(src, tokens = []) {
      this.inlineQueue.push({ src, tokens });
      return tokens;
    }
    /**
     * Lexing/Compiling
     */
    inlineTokens(src, tokens = []) {
      var _a, _b, _c;
      let maskedSrc = src;
      let match = null;
      if (this.tokens.links) {
        const links = Object.keys(this.tokens.links);
        if (links.length > 0) {
          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
            if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
              maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
            }
          }
        }
      }
      while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
      }
      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      }
      let keepPrevChar = false;
      let prevChar = "";
      while (src) {
        if (!keepPrevChar) {
          prevChar = "";
        }
        keepPrevChar = false;
        let token;
        if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.inline) == null ? void 0 : _b.some((extTokenizer) => {
          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.escape(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.tag(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.link(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.reflink(src, this.tokens.links)) {
          src = src.substring(token.raw.length);
          const lastToken = tokens.at(-1);
          if (token.type === "text" && (lastToken == null ? void 0 : lastToken.type) === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.codespan(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.br(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.del(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.autolink(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (!this.state.inLink && (token = this.tokenizer.url(src))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        let cutSrc = src;
        if ((_c = this.options.extensions) == null ? void 0 : _c.startInline) {
          let startIndex = Infinity;
          const tempSrc = src.slice(1);
          let tempStart;
          this.options.extensions.startInline.forEach((getStartIndex) => {
            tempStart = getStartIndex.call({ lexer: this }, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        }
        if (token = this.tokenizer.inlineText(cutSrc)) {
          src = src.substring(token.raw.length);
          if (token.raw.slice(-1) !== "_") {
            prevChar = token.raw.slice(-1);
          }
          keepPrevChar = true;
          const lastToken = tokens.at(-1);
          if ((lastToken == null ? void 0 : lastToken.type) === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      return tokens;
    }
  };
  var _Renderer = class {
    options;
    parser;
    // set by the parser
    constructor(options22) {
      this.options = options22 || _defaults;
    }
    space(token) {
      return "";
    }
    code({ text, lang, escaped }) {
      var _a;
      const langString = (_a = (lang || "").match(other.notSpaceStart)) == null ? void 0 : _a[0];
      const code = text.replace(other.endingNewline, "") + "\n";
      if (!langString) {
        return "<pre><code>" + (escaped ? code : escape22(code, true)) + "</code></pre>\n";
      }
      return '<pre><code class="language-' + escape22(langString) + '">' + (escaped ? code : escape22(code, true)) + "</code></pre>\n";
    }
    blockquote({ tokens }) {
      const body = this.parser.parse(tokens);
      return `<blockquote>
${body}</blockquote>
`;
    }
    html({ text }) {
      return text;
    }
    heading({ tokens, depth }) {
      return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>
`;
    }
    hr(token) {
      return "<hr>\n";
    }
    list(token) {
      const ordered = token.ordered;
      const start = token.start;
      let body = "";
      for (let j = 0; j < token.items.length; j++) {
        const item = token.items[j];
        body += this.listitem(item);
      }
      const type = ordered ? "ol" : "ul";
      const startAttr = ordered && start !== 1 ? ' start="' + start + '"' : "";
      return "<" + type + startAttr + ">\n" + body + "</" + type + ">\n";
    }
    listitem(item) {
      var _a;
      let itemBody = "";
      if (item.task) {
        const checkbox = this.checkbox({ checked: !!item.checked });
        if (item.loose) {
          if (((_a = item.tokens[0]) == null ? void 0 : _a.type) === "paragraph") {
            item.tokens[0].text = checkbox + " " + item.tokens[0].text;
            if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
              item.tokens[0].tokens[0].text = checkbox + " " + escape22(item.tokens[0].tokens[0].text);
              item.tokens[0].tokens[0].escaped = true;
            }
          } else {
            item.tokens.unshift({
              type: "text",
              raw: checkbox + " ",
              text: checkbox + " ",
              escaped: true
            });
          }
        } else {
          itemBody += checkbox + " ";
        }
      }
      itemBody += this.parser.parse(item.tokens, !!item.loose);
      return `<li>${itemBody}</li>
`;
    }
    checkbox({ checked }) {
      return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
    }
    paragraph({ tokens }) {
      return `<p>${this.parser.parseInline(tokens)}</p>
`;
    }
    table(token) {
      let header = "";
      let cell = "";
      for (let j = 0; j < token.header.length; j++) {
        cell += this.tablecell(token.header[j]);
      }
      header += this.tablerow({ text: cell });
      let body = "";
      for (let j = 0; j < token.rows.length; j++) {
        const row = token.rows[j];
        cell = "";
        for (let k = 0; k < row.length; k++) {
          cell += this.tablecell(row[k]);
        }
        body += this.tablerow({ text: cell });
      }
      if (body) body = `<tbody>${body}</tbody>`;
      return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
    }
    tablerow({ text }) {
      return `<tr>
${text}</tr>
`;
    }
    tablecell(token) {
      const content = this.parser.parseInline(token.tokens);
      const type = token.header ? "th" : "td";
      const tag2 = token.align ? `<${type} align="${token.align}">` : `<${type}>`;
      return tag2 + content + `</${type}>
`;
    }
    /**
     * span level renderer
     */
    strong({ tokens }) {
      return `<strong>${this.parser.parseInline(tokens)}</strong>`;
    }
    em({ tokens }) {
      return `<em>${this.parser.parseInline(tokens)}</em>`;
    }
    codespan({ text }) {
      return `<code>${escape22(text, true)}</code>`;
    }
    br(token) {
      return "<br>";
    }
    del({ tokens }) {
      return `<del>${this.parser.parseInline(tokens)}</del>`;
    }
    link({ href, title, tokens }) {
      const text = this.parser.parseInline(tokens);
      const cleanHref = cleanUrl(href);
      if (cleanHref === null) {
        return text;
      }
      href = cleanHref;
      let out = '<a href="' + href + '"';
      if (title) {
        out += ' title="' + escape22(title) + '"';
      }
      out += ">" + text + "</a>";
      return out;
    }
    image({ href, title, text, tokens }) {
      if (tokens) {
        text = this.parser.parseInline(tokens, this.parser.textRenderer);
      }
      const cleanHref = cleanUrl(href);
      if (cleanHref === null) {
        return escape22(text);
      }
      href = cleanHref;
      let out = `<img src="${href}" alt="${text}"`;
      if (title) {
        out += ` title="${escape22(title)}"`;
      }
      out += ">";
      return out;
    }
    text(token) {
      return "tokens" in token && token.tokens ? this.parser.parseInline(token.tokens) : "escaped" in token && token.escaped ? token.text : escape22(token.text);
    }
  };
  var _TextRenderer = class {
    // no need for block level renderers
    strong({ text }) {
      return text;
    }
    em({ text }) {
      return text;
    }
    codespan({ text }) {
      return text;
    }
    del({ text }) {
      return text;
    }
    html({ text }) {
      return text;
    }
    text({ text }) {
      return text;
    }
    link({ text }) {
      return "" + text;
    }
    image({ text }) {
      return "" + text;
    }
    br() {
      return "";
    }
  };
  var _Parser = class __Parser {
    options;
    renderer;
    textRenderer;
    constructor(options22) {
      this.options = options22 || _defaults;
      this.options.renderer = this.options.renderer || new _Renderer();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.renderer.parser = this;
      this.textRenderer = new _TextRenderer();
    }
    /**
     * Static Parse Method
     */
    static parse(tokens, options22) {
      const parser2 = new __Parser(options22);
      return parser2.parse(tokens);
    }
    /**
     * Static Parse Inline Method
     */
    static parseInline(tokens, options22) {
      const parser2 = new __Parser(options22);
      return parser2.parseInline(tokens);
    }
    /**
     * Parse Loop
     */
    parse(tokens, top = true) {
      var _a, _b;
      let out = "";
      for (let i = 0; i < tokens.length; i++) {
        const anyToken = tokens[i];
        if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.renderers) == null ? void 0 : _b[anyToken.type]) {
          const genericToken = anyToken;
          const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
          if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
            out += ret || "";
            continue;
          }
        }
        const token = anyToken;
        switch (token.type) {
          case "space": {
            out += this.renderer.space(token);
            continue;
          }
          case "hr": {
            out += this.renderer.hr(token);
            continue;
          }
          case "heading": {
            out += this.renderer.heading(token);
            continue;
          }
          case "code": {
            out += this.renderer.code(token);
            continue;
          }
          case "table": {
            out += this.renderer.table(token);
            continue;
          }
          case "blockquote": {
            out += this.renderer.blockquote(token);
            continue;
          }
          case "list": {
            out += this.renderer.list(token);
            continue;
          }
          case "html": {
            out += this.renderer.html(token);
            continue;
          }
          case "paragraph": {
            out += this.renderer.paragraph(token);
            continue;
          }
          case "text": {
            let textToken = token;
            let body = this.renderer.text(textToken);
            while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
              textToken = tokens[++i];
              body += "\n" + this.renderer.text(textToken);
            }
            if (top) {
              out += this.renderer.paragraph({
                type: "paragraph",
                raw: body,
                text: body,
                tokens: [{ type: "text", raw: body, text: body, escaped: true }]
              });
            } else {
              out += body;
            }
            continue;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return "";
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
    /**
     * Parse Inline Tokens
     */
    parseInline(tokens, renderer = this.renderer) {
      var _a, _b;
      let out = "";
      for (let i = 0; i < tokens.length; i++) {
        const anyToken = tokens[i];
        if ((_b = (_a = this.options.extensions) == null ? void 0 : _a.renderers) == null ? void 0 : _b[anyToken.type]) {
          const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);
          if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(anyToken.type)) {
            out += ret || "";
            continue;
          }
        }
        const token = anyToken;
        switch (token.type) {
          case "escape": {
            out += renderer.text(token);
            break;
          }
          case "html": {
            out += renderer.html(token);
            break;
          }
          case "link": {
            out += renderer.link(token);
            break;
          }
          case "image": {
            out += renderer.image(token);
            break;
          }
          case "strong": {
            out += renderer.strong(token);
            break;
          }
          case "em": {
            out += renderer.em(token);
            break;
          }
          case "codespan": {
            out += renderer.codespan(token);
            break;
          }
          case "br": {
            out += renderer.br(token);
            break;
          }
          case "del": {
            out += renderer.del(token);
            break;
          }
          case "text": {
            out += renderer.text(token);
            break;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return "";
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
  };
  var _Hooks = class {
    options;
    block;
    constructor(options22) {
      this.options = options22 || _defaults;
    }
    static passThroughHooks = /* @__PURE__ */ new Set([
      "preprocess",
      "postprocess",
      "processAllTokens"
    ]);
    /**
     * Process markdown before marked
     */
    preprocess(markdown) {
      return markdown;
    }
    /**
     * Process HTML after marked is finished
     */
    postprocess(html2) {
      return html2;
    }
    /**
     * Process all tokens before walk tokens
     */
    processAllTokens(tokens) {
      return tokens;
    }
    /**
     * Provide function to tokenize markdown
     */
    provideLexer() {
      return this.block ? _Lexer.lex : _Lexer.lexInline;
    }
    /**
     * Provide function to parse tokens
     */
    provideParser() {
      return this.block ? _Parser.parse : _Parser.parseInline;
    }
  };
  var Marked = class {
    defaults = _getDefaults();
    options = this.setOptions;
    parse = this.parseMarkdown(true);
    parseInline = this.parseMarkdown(false);
    Parser = _Parser;
    Renderer = _Renderer;
    TextRenderer = _TextRenderer;
    Lexer = _Lexer;
    Tokenizer = _Tokenizer;
    Hooks = _Hooks;
    constructor(...args) {
      this.use(...args);
    }
    /**
     * Run callback for every token
     */
    walkTokens(tokens, callback) {
      var _a, _b;
      let values = [];
      for (const token of tokens) {
        values = values.concat(callback.call(this, token));
        switch (token.type) {
          case "table": {
            const tableToken = token;
            for (const cell of tableToken.header) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
            for (const row of tableToken.rows) {
              for (const cell of row) {
                values = values.concat(this.walkTokens(cell.tokens, callback));
              }
            }
            break;
          }
          case "list": {
            const listToken = token;
            values = values.concat(this.walkTokens(listToken.items, callback));
            break;
          }
          default: {
            const genericToken = token;
            if ((_b = (_a = this.defaults.extensions) == null ? void 0 : _a.childTokens) == null ? void 0 : _b[genericToken.type]) {
              this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
                const tokens2 = genericToken[childTokens].flat(Infinity);
                values = values.concat(this.walkTokens(tokens2, callback));
              });
            } else if (genericToken.tokens) {
              values = values.concat(this.walkTokens(genericToken.tokens, callback));
            }
          }
        }
      }
      return values;
    }
    use(...args) {
      const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
      args.forEach((pack) => {
        const opts = { ...pack };
        opts.async = this.defaults.async || opts.async || false;
        if (pack.extensions) {
          pack.extensions.forEach((ext) => {
            if (!ext.name) {
              throw new Error("extension name required");
            }
            if ("renderer" in ext) {
              const prevRenderer = extensions.renderers[ext.name];
              if (prevRenderer) {
                extensions.renderers[ext.name] = function(...args2) {
                  let ret = ext.renderer.apply(this, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args2);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if ("tokenizer" in ext) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              const extLevel = extensions[ext.level];
              if (extLevel) {
                extLevel.unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) {
                if (ext.level === "block") {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === "inline") {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if ("childTokens" in ext && ext.childTokens) {
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
          opts.extensions = extensions;
        }
        if (pack.renderer) {
          const renderer = this.defaults.renderer || new _Renderer(this.defaults);
          for (const prop in pack.renderer) {
            if (!(prop in renderer)) {
              throw new Error(`renderer '${prop}' does not exist`);
            }
            if (["options", "parser"].includes(prop)) {
              continue;
            }
            const rendererProp = prop;
            const rendererFunc = pack.renderer[rendererProp];
            const prevRenderer = renderer[rendererProp];
            renderer[rendererProp] = (...args2) => {
              let ret = rendererFunc.apply(renderer, args2);
              if (ret === false) {
                ret = prevRenderer.apply(renderer, args2);
              }
              return ret || "";
            };
          }
          opts.renderer = renderer;
        }
        if (pack.tokenizer) {
          const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
          for (const prop in pack.tokenizer) {
            if (!(prop in tokenizer)) {
              throw new Error(`tokenizer '${prop}' does not exist`);
            }
            if (["options", "rules", "lexer"].includes(prop)) {
              continue;
            }
            const tokenizerProp = prop;
            const tokenizerFunc = pack.tokenizer[tokenizerProp];
            const prevTokenizer = tokenizer[tokenizerProp];
            tokenizer[tokenizerProp] = (...args2) => {
              let ret = tokenizerFunc.apply(tokenizer, args2);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args2);
              }
              return ret;
            };
          }
          opts.tokenizer = tokenizer;
        }
        if (pack.hooks) {
          const hooks = this.defaults.hooks || new _Hooks();
          for (const prop in pack.hooks) {
            if (!(prop in hooks)) {
              throw new Error(`hook '${prop}' does not exist`);
            }
            if (["options", "block"].includes(prop)) {
              continue;
            }
            const hooksProp = prop;
            const hooksFunc = pack.hooks[hooksProp];
            const prevHook = hooks[hooksProp];
            if (_Hooks.passThroughHooks.has(prop)) {
              hooks[hooksProp] = (arg) => {
                if (this.defaults.async) {
                  return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                    return prevHook.call(hooks, ret2);
                  });
                }
                const ret = hooksFunc.call(hooks, arg);
                return prevHook.call(hooks, ret);
              };
            } else {
              hooks[hooksProp] = (...args2) => {
                let ret = hooksFunc.apply(hooks, args2);
                if (ret === false) {
                  ret = prevHook.apply(hooks, args2);
                }
                return ret;
              };
            }
          }
          opts.hooks = hooks;
        }
        if (pack.walkTokens) {
          const walkTokens2 = this.defaults.walkTokens;
          const packWalktokens = pack.walkTokens;
          opts.walkTokens = function(token) {
            let values = [];
            values.push(packWalktokens.call(this, token));
            if (walkTokens2) {
              values = values.concat(walkTokens2.call(this, token));
            }
            return values;
          };
        }
        this.defaults = { ...this.defaults, ...opts };
      });
      return this;
    }
    setOptions(opt) {
      this.defaults = { ...this.defaults, ...opt };
      return this;
    }
    lexer(src, options22) {
      return _Lexer.lex(src, options22 ?? this.defaults);
    }
    parser(tokens, options22) {
      return _Parser.parse(tokens, options22 ?? this.defaults);
    }
    parseMarkdown(blockType) {
      const parse2 = (src, options22) => {
        const origOpt = { ...options22 };
        const opt = { ...this.defaults, ...origOpt };
        const throwError = this.onError(!!opt.silent, !!opt.async);
        if (this.defaults.async === true && origOpt.async === false) {
          return throwError(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
        }
        if (typeof src === "undefined" || src === null) {
          return throwError(new Error("marked(): input parameter is undefined or null"));
        }
        if (typeof src !== "string") {
          return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
        }
        if (opt.hooks) {
          opt.hooks.options = opt;
          opt.hooks.block = blockType;
        }
        const lexer2 = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline;
        const parser2 = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;
        if (opt.async) {
          return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
        }
        try {
          if (opt.hooks) {
            src = opt.hooks.preprocess(src);
          }
          let tokens = lexer2(src, opt);
          if (opt.hooks) {
            tokens = opt.hooks.processAllTokens(tokens);
          }
          if (opt.walkTokens) {
            this.walkTokens(tokens, opt.walkTokens);
          }
          let html2 = parser2(tokens, opt);
          if (opt.hooks) {
            html2 = opt.hooks.postprocess(html2);
          }
          return html2;
        } catch (e) {
          return throwError(e);
        }
      };
      return parse2;
    }
    onError(silent, async) {
      return (e) => {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (silent) {
          const msg = "<p>An error occurred:</p><pre>" + escape22(e.message + "", true) + "</pre>";
          if (async) {
            return Promise.resolve(msg);
          }
          return msg;
        }
        if (async) {
          return Promise.reject(e);
        }
        throw e;
      };
    }
  };
  var markedInstance = new Marked();
  function marked(src, opt) {
    return markedInstance.parse(src, opt);
  }
  marked.options = marked.setOptions = function(options22) {
    markedInstance.setOptions(options22);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
  };
  marked.getDefaults = _getDefaults;
  marked.defaults = _defaults;
  marked.use = function(...args) {
    markedInstance.use(...args);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
  };
  marked.walkTokens = function(tokens, callback) {
    return markedInstance.walkTokens(tokens, callback);
  };
  marked.parseInline = markedInstance.parseInline;
  marked.Parser = _Parser;
  marked.parser = _Parser.parse;
  marked.Renderer = _Renderer;
  marked.TextRenderer = _TextRenderer;
  marked.Lexer = _Lexer;
  marked.lexer = _Lexer.lex;
  marked.Tokenizer = _Tokenizer;
  marked.Hooks = _Hooks;
  marked.parse = marked;
  var options2 = marked.options;
  var setOptions = marked.setOptions;
  var use = marked.use;
  var walkTokens = marked.walkTokens;
  var parseInline = marked.parseInline;
  var parser = _Parser.parse;
  var lexer = _Lexer.lex;

  // node_modules/lupine.press/src/services/markdown.ts
  var import_gray_matter = __toESM(require_gray_matter());

  // node_modules/lupine.press/src/services/press-load.ts
  init_src2();
  var pressLoad = (url) => {
    const sidemenu = document.querySelector(".press-frame-sidemenu");
    if (sidemenu) {
      setSidebarScroll(sidemenu.scrollTop);
    }
    initializePage2(pressProcessUrl(url));
  };
  var pressProcessUrl = (url) => {
    const langs = getPressLangs();
    const subDir = getPressSubDir();
    let target = url;
    if (subDir && !target.startsWith(subDir + "/") && !target.includes("//")) {
      target = `${subDir}${target}`;
    }
    return target || "/";
  };

  // node_modules/lupine.press/src/components/lang-switcher.tsx
  init_jsx_runtime();
  var LangSwitcher = (props) => {
    var _a;
    const langs = props.langs || [];
    const currentLabel = ((_a = langs.find((l) => l.id === props.currentLang)) == null ? void 0 : _a.text) || "Language";
    const handleSelected = (text) => {
      const lang = langs.find((l) => l.text === text);
      if (lang && lang.id !== props.currentLang) {
        let newPath = window.location.pathname;
        const subDir = getPressSubDir();
        if (subDir && newPath.startsWith(subDir)) {
          newPath = newPath.substring(subDir.length);
        }
        const langIds = langs.map((l) => l.id).join("|");
        const langRegex = new RegExp(`^/(${langIds})(\\/|$)`);
        if (langRegex.test(newPath)) {
          newPath = newPath.replace(langRegex, `/${lang.id}$2`);
        } else {
          newPath = `/${lang.id}${newPath === "/" ? "/" : newPath}`;
        }
        newPath = `${subDir}${newPath}`;
        initializePage2(newPath);
      }
    };
    return /* @__PURE__ */ jsx("div", { class: ["lang-switcher", props.className].join(" "), children: /* @__PURE__ */ jsx(
      PopupMenu,
      {
        list: langs.map((l) => l.text),
        defaultValue: currentLabel,
        icon: /* @__PURE__ */ jsx(Svg, { children: lang_default }),
        handleSelected,
        align: "right"
      }
    ) });
  };

  // node_modules/lupine.press/src/components/press-header.tsx
  init_src2();

  // node_modules/lupine.press/src/styles/github.svg
  var github_default = "<svg viewBox='0 0 24 24' width='20' height='20' fill='currentColor'>\r\n    <path d='M12 2C6.477 2 2 6.477 2 12c0 4.42 2.865 8.164 6.839 9.49.5.092.682-.217.682-.482 0-.237-.008-.866-.013-1.7-2.782.604-3.369-1.34-3.369-1.34-.454-1.156-1.11-1.463-1.11-1.463-.908-.62.069-.608.069-.608 1.003.07 1.531 1.03 1.531 1.03.892 1.529 2.341 1.087 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.11-4.555-4.943 0-1.091.39-1.984 1.029-2.683-.103-.253-.446-1.27.098-2.647 0 0 .84-.269 2.75 1.025A9.578 9.578 0 0112 6.836c.85.004 1.705.115 2.504.337 1.909-1.294 2.747-1.025 2.747-1.025.546 1.377.203 2.394.1 2.647.64.699 1.028 1.592 1.028 2.683 0 3.842-2.339 4.687-4.566 4.935.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12c0-5.523-4.477-10-10-10z' />\r\n</svg>";

  // node_modules/lupine.press/src/styles/theme.svg
  var theme_default = `<svg viewBox='0 0 24 24' width='20' height='20' fill='currentColor'>\r
    <!-- Sun (Top-Left): Unchanged -->\r
    <path d="M7 3a4 4 0 1 0 0 8 4 4 0 0 0 0-8zM7 0h1v2.5H7zM7 11.5h1V14H7zM0 7h2.5v1H0zM11.5 7H14v1h-2.5zM2.05 2.05l1.768 1.768.707-.707L2.757 1.343zM10.243 10.243l1.768 1.768.707-.707-1.768-1.768zM2.05 12.95L1.343 12.243l1.768-1.768.707.707zM12.95 2.05l-1.768 1.768-.707-.707 1.768-1.768z" />\r
    \r
    <!-- Moon (Bottom-Right): Rotated ~30 degrees CCW to 'hug' the sun -->\r
    <g transform="rotate(-30, 16, 16)">\r
        <path d="M23 16c0 3.866-3.134 7-7 7-3.866 0-7-3.134-7-7 0-.46.04-.92.1-1.36 1.1 3.2 4.1 5.5 7.4 5.5 1.9 0 3.6-.6 5-1.7 1-.9 1.5-2.1 1.5-3.44 0-1.8-1.1-3.3-2.6-3.9 1.6 1.5 2.6 3.6 2.6 5.9z" />\r
    </g>\r
</svg>\r
`;

  // node_modules/lupine.press/src/components/press-header.tsx
  init_jsx_runtime();
  var PageHeader = (props) => {
    const css2 = {
      width: "100%",
      display: "flex",
      alignItems: "center",
      padding: "0.75rem 2rem",
      justifyContent: "space-between",
      ".press-navbar-left": {
        display: "flex",
        alignItems: "center",
        ".title": {
          fontWeight: "bold",
          fontSize: "1.2rem",
          marginRight: "1rem"
        },
        ".nav": {
          display: "flex",
          gap: "1rem"
        }
      },
      ".press-navbar-right": {
        display: "flex",
        alignItems: "center",
        gap: "1.25rem",
        ".navbar-item": {
          display: "flex",
          alignItems: "center",
          textDecoration: "none",
          transition: "color 0.2s",
          "&:hover": { color: "var(--press-brand-color)" }
        }
      }
    };
    return /* @__PURE__ */ jsx("header", { css: css2, class: "press-navbar", children: [
      /* @__PURE__ */ jsx("div", { class: "press-navbar-left", children: [
        /* @__PURE__ */ jsx("div", { class: "title", children: /* @__PURE__ */ jsx("a", { href: pressProcessUrl("/" + props.currentLang), children: props.title }) }),
        /* @__PURE__ */ jsx("nav", { class: "nav", children: props.nav.map((item) => /* @__PURE__ */ jsx("a", { href: pressProcessUrl(item.link), target: item.target, children: item.text })) })
      ] }),
      /* @__PURE__ */ jsx("div", { class: "press-navbar-right", children: [
        props.langs.length > 1 && /* @__PURE__ */ jsx(LangSwitcher, { className: "navbar-item", currentLang: props.currentLang, langs: props.langs || [] }),
        /* @__PURE__ */ jsx(ThemeSelector, { className: "navbar-item", icon: /* @__PURE__ */ jsx(Svg, { children: theme_default }), noUpdateLabel: true }),
        props.github && props.github.url && /* @__PURE__ */ jsx(
          "a",
          {
            href: props.github.url,
            target: "_blank",
            rel: "noopener noreferrer",
            class: "navbar-item",
            title: props.github.title,
            children: /* @__PURE__ */ jsx(Svg, { children: github_default })
          }
        )
      ] })
    ] });
  };

  // node_modules/lupine.press/src/components/press-heading.tsx
  init_jsx_runtime();
  var PageHeading = (props) => {
    if (props.headings.length === 0) return null;
    const css2 = {
      ".&-title": {
        fontWeight: "bold",
        fontSize: "0.8rem",
        textTransform: "uppercase",
        letterSpacing: "0.05em",
        color: "var(--primary-color)",
        marginBottom: "0.8rem"
      },
      ".&-list": {
        listStyle: "none",
        padding: 0,
        margin: 0,
        borderLeft: "1px solid var(--press-border-color)"
      },
      ".&-item": {
        padding: "0.2rem 0 0.2rem 1rem",
        fontSize: "0.85rem",
        "&.level-3": { paddingLeft: "2rem" },
        a: {
          display: "block",
          transition: "color 0.2s",
          whiteSpace: "nowrap",
          overflow: "hidden",
          textOverflow: "ellipsis"
        }
      }
    };
    return /* @__PURE__ */ jsx("div", { css: css2, children: [
      /* @__PURE__ */ jsx("div", { class: "&-title", children: "On this page" }),
      /* @__PURE__ */ jsx("ul", { class: "&-list", children: props.headings.map((h) => /* @__PURE__ */ jsx("li", { class: `&-item level-${h.level}`, children: /* @__PURE__ */ jsx("a", { href: `#${h.id}`, children: h.text }) })) })
    ] });
  };

  // node_modules/lupine.press/src/components/press-home.tsx
  init_jsx_runtime();
  var LayoutHome = (props) => {
    var _a;
    const { hero, features } = props.data || {};
    const css2 = {
      ".&-hero": {
        padding: "64px 32px",
        textAlign: "center",
        display: "flex",
        flexDirection: "column",
        alignItems: "center"
      },
      ".&-hero-name": {
        fontSize: "56px",
        lineHeight: "64px",
        fontWeight: "bold",
        background: "linear-gradient(135deg, var(--press-brand-color) 30%, #4facfe 100%)",
        "-webkit-background-clip": "text",
        "-webkit-text-fill-color": "transparent"
      },
      ".&-hero-text": {
        fontSize: "56px",
        lineHeight: "64px",
        fontWeight: "bold",
        marginTop: "8px"
      },
      ".&-hero-tagline": {
        fontSize: "24px",
        lineHeight: "36px",
        color: "var(--secondary-color)",
        marginTop: "24px",
        maxWidth: "576px"
      },
      ".&-hero-actions": {
        display: "flex",
        gap: "12px",
        marginTop: "48px"
      },
      ".&-button": {
        display: "inline-block",
        padding: "0 20px",
        lineHeight: "38px",
        borderRadius: "20px",
        fontWeight: "600",
        textDecoration: "none",
        fontSize: "14px"
      },
      ".&-button.brand": {
        backgroundColor: "var(--press-brand-color)",
        color: "#fff"
      },
      ".&-button.alt": {
        backgroundColor: "var(--secondary-bg-color)",
        color: "var(--primary-color)",
        border: "1px solid var(--press-border-color)"
      },
      ".&-features": {
        display: "grid",
        gridTemplateColumns: "repeat(auto-fit, minmax(256px, 1fr))",
        gap: "24px",
        padding: "48px 32px",
        maxWidth: "1152px",
        margin: "0 auto"
      },
      ".&-feature-card": {
        backgroundColor: "var(--secondary-bg-color)",
        padding: "24px",
        borderRadius: "12px",
        border: "1px solid var(--press-border-color)"
      },
      ".&-feature-title": {
        fontSize: "20px",
        fontWeight: "bold",
        marginBottom: "8px"
      },
      ".&-feature-details": {
        fontSize: "14px",
        color: "var(--secondary-color)",
        lineHeight: "22px"
      }
    };
    return /* @__PURE__ */ jsx("div", { css: css2, children: [
      /* @__PURE__ */ jsx("section", { class: "&-hero", children: [
        /* @__PURE__ */ jsx("h1", { class: "&-hero-name", children: hero.name }),
        /* @__PURE__ */ jsx("p", { class: "&-hero-text", children: hero.text }),
        /* @__PURE__ */ jsx("p", { class: "&-hero-tagline", children: hero.tagline }),
        /* @__PURE__ */ jsx("div", { class: "&-hero-actions", children: (_a = hero.actions) == null ? void 0 : _a.map((action) => /* @__PURE__ */ jsx("a", { href: pressProcessUrl(action.link), class: `&-button ${action.theme}`, children: action.text })) })
      ] }),
      features && /* @__PURE__ */ jsx("section", { class: "&-features", children: features.map((feature) => /* @__PURE__ */ jsx("div", { class: "&-feature-card", children: [
        /* @__PURE__ */ jsx("h2", { class: "&-feature-title", children: feature.title }),
        /* @__PURE__ */ jsx("p", { class: "&-feature-details", children: feature.details })
      ] })) })
    ] });
  };

  // node_modules/lupine.press/src/components/press-layout.tsx
  init_src();

  // node_modules/lupine.press/src/frames/press-frame.tsx
  init_src2();
  init_jsx_runtime();
  var PressFrame = (props) => {
    if (isFrontEnd2()) {
      window.lpPressLoad = pressLoad;
    }
    const cssMarkdown = {
      // used in built markdown htmls, put under some element to override global.css
      h1: {
        fontSize: "1.7rem"
      },
      h2: {
        fontSize: "1.4rem"
      },
      h3: {
        fontSize: "1.2rem"
      },
      "h1, h2, h3": {
        borderBottom: "1px solid var(--press-border-color)",
        paddingBottom: "0.3em",
        marginTop: "1.5em",
        position: "relative",
        scrollMarginTop: "80px",
        fontWeight: "bold",
        "&:first-child": { marginTop: 0 },
        "&:hover .header-anchor": { opacity: 1 }
      },
      ".header-anchor": {
        position: "absolute",
        left: "-1.5rem",
        width: "1rem",
        opacity: 0,
        textDecoration: "none",
        color: "var(--press-brand-color)",
        fontSize: "0.8em",
        transition: "opacity 0.2s"
      },
      ol: {
        listStyleType: "disc"
      },
      "li, p": {
        margin: "0.5em 0"
      },
      pre: {
        backgroundColor: "var(--secondary-bg-color)",
        padding: "1rem",
        borderRadius: "8px",
        overflowX: "auto"
      },
      code: {
        fontFamily: "var(--font-family-mono, monospace)"
      },
      img: {
        maxWidth: "100%",
        boxShadow: "var(--cover-box-shadow)"
      }
    };
    const cssContainer = {
      display: "flex",
      flexDirection: "column",
      width: "100%",
      height: "100%",
      minHeight: "100%",
      position: "relative",
      ...cssMarkdown,
      ...props.css,
      ".press-frame-box": {
        display: "flex",
        flex: "1",
        flexDirection: "column",
        height: "100%",
        width: "100%",
        maxWidth: MediaQueryMaxWidth.DesktopMax,
        margin: "auto",
        // trick: to put two padding-top properties
        "padding-top ": "constant(safe-area-inset-top)",
        "padding-top": "env(safe-area-inset-top)"
      },
      ".press-frame-header": {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        padding: "4px 16px 4px 0px",
        width: "100%"
      },
      ".press-frame-main": {
        display: "flex",
        flex: "1",
        flexDirection: "row",
        overflowY: "auto",
        scrollbarWidth: "none",
        borderTop: "1px solid var(--press-border-color)",
        minHeight: "0",
        scrollBehavior: "smooth",
        "&::-webkit-scrollbar": {
          display: "none"
        }
      },
      ".press-frame-main .padding-block": {
        padding: "0 16px"
      },
      ".press-frame-content": {
        display: "flex",
        flex: "1",
        flexDirection: "column",
        overflowY: "auto",
        scrollbarWidth: "none"
      },
      ".press-frame-sidemenu": {
        width: props.sidemenuWidth || "260px",
        display: "flex",
        borderRight: "1px solid var(--press-border-color)",
        overflowX: "hidden",
        overflowY: "auto",
        color: "var(--sidebar-color)",
        scrollbarWidth: "none",
        "&::-webkit-scrollbar": {
          display: "none"
        }
        // '&::-webkit-scrollbar': { width: '4px' },
        // '&::-webkit-scrollbar-thumb': { backgroundColor: 'var(--press-border-color)' },
        // backgroundColor: 'var(--sidebar-bg-color)',
      },
      [MediaQueryRange.TabletBelow]: {
        ".press-frame-sidemenu": {
          display: "none"
        }
      }
    };
    const ref = {
      onLoad: async (el) => {
        bindLinks(el);
        const sidemenu = el.querySelector(".press-frame-sidemenu");
        if (sidemenu) {
          sidemenu.scrollTop = getSidebarScroll();
          sidemenu.addEventListener("scroll", () => {
            setSidebarScroll(sidemenu.scrollTop);
          });
        }
      }
    };
    return /* @__PURE__ */ jsx("div", { ref, css: cssContainer, class: "press-frame", children: /* @__PURE__ */ jsx("div", { class: "press-frame-box", children: [
      /* @__PURE__ */ jsx("div", { class: "press-frame-header", children: props.header }),
      /* @__PURE__ */ jsx("div", { class: "press-frame-main", children: [
        !props.hideSidemenu && /* @__PURE__ */ jsx("div", { class: "press-frame-sidemenu", children: props.sidemenu }),
        /* @__PURE__ */ jsx("div", { class: "press-frame-content", children: props.content })
      ] })
    ] }) });
  };

  // node_modules/lupine.press/src/components/press-sidemenu.tsx
  init_jsx_runtime();
  var PressSidemenu = (props) => {
    const ref = {};
    const css2 = {
      width: "100%",
      padding: "0 8px 8px",
      height: "max-content",
      // overflowY: 'auto',
      ".&-item": {
        marginBottom: "0.5rem",
        display: "block",
        color: "var(--text-color)",
        textDecoration: "none",
        "&:hover": {
          color: "var(--primary-accent-color)"
        },
        transition: "color 0.2s"
      },
      ".&-item.active": {
        color: "var(--primary-accent-color)",
        fontWeight: "bold"
      },
      ".&-group-title": {
        fontWeight: "bold",
        marginTop: "0.5rem",
        marginBottom: "0.5rem",
        fontSize: "15px",
        // color: 'var(--secondary-color)',
        "&.group-level-0": {
          marginTop: "1.5rem",
          fontSize: "19px"
        },
        "&.group-level-1": {
          marginTop: "0.75rem",
          fontSize: "17px"
        }
      }
    };
    const highlight = (targetLink) => {
      const link2 = targetLink || window.location.href;
      const items = ref.$all("&-item");
      if (items) {
        items.forEach((el) => {
          el.classList.remove("active");
          const dataLink = el.getAttribute("data-link");
          if (dataLink && link2.endsWith(dataLink)) {
            el.classList.add("active");
            el.scrollIntoView({ behavior: "smooth", block: "nearest" });
          }
        });
      }
    };
    ref.onLoad = async () => {
      highlight();
    };
    const flatList = props.sidebar || [];
    const basePadding = 1;
    return /* @__PURE__ */ jsx("aside", { css: css2, ref, children: flatList.map((item, index) => {
      const style = { paddingLeft: `${item.level * basePadding}rem` };
      if (item.type === "group") {
        return /* @__PURE__ */ jsx("div", { class: "&-group-title" + (" group-level-" + item.level), style, children: item.text }, index);
      } else {
        const target = pressProcessUrl(item.link);
        return /* @__PURE__ */ jsx(
          "a",
          {
            class: "&-item",
            style,
            href: "javascript:void(0)",
            "data-link": target,
            onClick: () => {
              highlight(target);
              pressLoad(target);
              return false;
            },
            children: item.text
          },
          index
        );
      }
    }) });
  };

  // node_modules/lupine.press/src/components/press-content.tsx
  init_src2();

  // node_modules/lupine.press/src/styles/menu.svg
  var menu_default = `<svg viewBox='0 0 24 24' width='20' height='20' fill='currentColor'>\r
    <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" />\r
</svg>\r
`;

  // node_modules/lupine.press/src/components/press-content.tsx
  init_jsx_runtime();
  var PressContent = (props) => {
    const css2 = {
      display: "flex",
      flex: 1,
      maxWidth: "100vw",
      margin: "0 auto",
      width: "100%",
      ".press-content": {
        flex: 1,
        padding: props.isHome ? "0" : "2rem 4rem",
        width: "100%",
        // maxWidth: isHome ? '100%' : '800px',
        margin: props.isHome ? "0" : "0 auto",
        minWidth: 0,
        a: {
          textDecoration: "underline"
        }
      },
      ".page-heading-container": {
        width: "240px",
        minWidth: "240px",
        padding: "2rem 1rem",
        position: "sticky",
        top: "64px",
        maxHeight: "calc(100vh - 64px)",
        overflowY: "auto",
        alignSelf: "flex-start",
        // Prevent stretching to full height
        display: props.isHome || props.headings.length === 0 ? "none" : "block"
      },
      ".markdown-body": {
        lineHeight: 1.6
      },
      ".press-mobile-toc": {
        display: "none",
        // border: '1px solid var(--press-border-color)',
        borderRadius: "6px",
        alignItems: "center",
        padding: "4px",
        position: "fixed",
        top: "74px",
        right: "7px",
        zIndex: 90,
        fontSize: "0.9rem",
        cursor: "pointer",
        textTransform: "uppercase",
        backgroundColor: "var(--primary-bg-color)"
      },
      ".press-mobile-sidebar": {
        display: "none",
        borderRadius: "6px",
        alignItems: "center",
        padding: "4px",
        position: "fixed",
        top: "74px",
        left: "7px",
        zIndex: 90,
        fontSize: "0.9rem",
        cursor: "pointer",
        // can't put up level, otherwise it will override parent's same level selector
        [MediaQueryRange.TabletBelow]: {
          display: "flex"
        }
      },
      [MediaQueryRange.MobileBelow]: {
        ".page-heading-container": {
          display: "none"
        },
        ".press-mobile-toc": { display: "flex" },
        ".press-content": {
          padding: props.isHome ? "0" : "2rem 1rem"
        }
      }
    };
    return /* @__PURE__ */ jsx("main", { css: css2, children: [
      !props.isHome && props.sidebar.length > 0 && /* @__PURE__ */ jsx("div", { class: "press-mobile-sidebar", children: /* @__PURE__ */ jsx(
        PopupMenu,
        {
          list: props.sidebar.map(
            (item) => ({
              text: item.text,
              id: item.link || "",
              url: item.link || "",
              indent: item.level,
              visible: item.type ? true : false,
              // Validating it's processed item
              disabled: item.type === "group",
              bold: item.type === "group"
            })
          ),
          defaultValue: "Menu",
          tips: "",
          width: "max-content",
          maxHeight: "400px",
          align: "left",
          handleSelected: (text, item) => {
            if (item && item.url) pressLoad(item.url);
          },
          noUpdateLabel: true,
          icon: /* @__PURE__ */ jsx(Svg, { children: menu_default })
        }
      ) }),
      /* @__PURE__ */ jsx("main", { class: "press-content", children: props.isHome ? /* @__PURE__ */ jsx(LayoutHome, { data: props.data }) : /* @__PURE__ */ jsx("article", { class: "markdown-body", children: props.children }) }),
      /* @__PURE__ */ jsx("aside", { class: "page-heading-container", children: /* @__PURE__ */ jsx(PageHeading, { headings: props.headings }) }),
      !props.isHome && props.headings.length > 0 && /* @__PURE__ */ jsx("div", { class: "press-mobile-toc", children: /* @__PURE__ */ jsx(
        PopupMenu,
        {
          list: props.headings.map(
            (h) => ({
              text: h.text,
              id: h.id,
              indent: h.level - 2
            })
          ),
          defaultValue: "On this page",
          tips: "",
          width: "max-content",
          maxHeight: "300px",
          align: "right",
          handleSelected: (text) => {
            var _a;
            const cleanText = text.trim();
            const heading2 = props.headings.find((h) => h.text === cleanText);
            if (heading2) {
              (_a = document.getElementById(heading2.id)) == null ? void 0 : _a.scrollIntoView(true);
            }
          },
          noUpdateLabel: true
        }
      ) })
    ] });
  };

  // node_modules/lupine.press/src/components/press-layout.tsx
  init_jsx_runtime();
  var PressLayout = (props) => {
    var _a;
    const isHome = ((_a = props.data) == null ? void 0 : _a.layout) === "home";
    const headings = props.headings || [];
    const currentLang = props.lang || getCurrentLang().langName;
    const sidebar = props.sidebar || [];
    const content = /* @__PURE__ */ jsx(PressContent, { sidebar, isHome, headings, data: props.data, children: props.children });
    return /* @__PURE__ */ jsx(
      PressFrame,
      {
        header: /* @__PURE__ */ jsx(
          PageHeader,
          {
            title: props.title,
            nav: props.nav,
            langs: props.langs || [],
            currentLang,
            github: props.github
          }
        ),
        sidemenu: /* @__PURE__ */ jsx(PressSidemenu, { sidebar }),
        content,
        hideSidemenu: isHome,
        sidemenuWidth: props.sidemenuWidth
      }
    );
  };

  // node_modules/lupine.press/src/page/press-page.tsx
  init_src2();
  init_jsx_runtime();
  var PressPage = async (props) => {
    var _a, _b;
    if (!isFrontEnd2()) {
      return /* @__PURE__ */ jsx("div", {});
    }
    const subDir = getPressSubDir();
    const markdownConfig2 = getPressData();
    let p = window.location.pathname;
    if (subDir && p.startsWith(subDir)) {
      p = p.substring(subDir.length);
    }
    const pathParts = p.split("/");
    const pathLang = pathParts[1];
    const globalConfig = ((_a = markdownConfig2["/"]) == null ? void 0 : _a.data) || {};
    const langObj = Array.isArray(globalConfig.lang) ? globalConfig.lang : [
      { title: "English", id: "en" },
      { title: "Chinese", id: "zh" }
    ];
    setPressLangs(langObj);
    const supportedLangs = langObj.map((l) => l.id);
    const langName = supportedLangs.includes(pathLang) ? pathLang : supportedLangs[0] || "en";
    Promise.resolve().then(() => (init_src2(), src_exports)).then((m) => {
      if (m.getCurrentLang().langName !== langName) {
        m.updateLang(langName);
      }
    });
    let currentPath = p;
    if (currentPath === "" || currentPath === "/") {
      currentPath = `/${langName}/index`;
    } else {
      if (currentPath.endsWith("/") && currentPath.length > 1)
        currentPath = currentPath.substring(0, currentPath.length - 1);
      if (currentPath === `/${langName}`) currentPath = `/${langName}/index`;
    }
    const config = markdownConfig2[currentPath];
    if (!config) {
      if (window.location.pathname[0] === "/" && !window.location.pathname.startsWith(subDir + "/")) {
        window.location.href = window.location.href;
        return;
      }
    }
    const content = config ? config.html : `<h1>404 - Page Not Found</h1><p>Path: ${currentPath}</p>`;
    const rootIndex = ((_b = markdownConfig2[`/${langName}/index`]) == null ? void 0 : _b.data) || {};
    const rootNav = rootIndex.nav || [];
    const rootSidebar = rootIndex.sidebar || [];
    const siteTitle = rootIndex.title || "Lupine.js";
    const siteStyles = rootIndex.styles || {};
    bindGlobalStyle("customer-css", siteStyles, false, true);
    const langs = langObj.map((l) => {
      var _a2;
      const data = ((_a2 = markdownConfig2[`${l.id}/index`]) == null ? void 0 : _a2.data) || {};
      const langData = Array.isArray(data.lang) ? data.lang[0] : data.lang || {};
      return {
        text: langData.text || langData.title || langData.label || l.title,
        id: l.id
      };
    });
    return /* @__PURE__ */ jsx(
      PressLayout,
      {
        title: siteTitle,
        nav: rootNav,
        sidebar: rootSidebar,
        lang: langName,
        langs,
        data: config == null ? void 0 : config.data,
        headings: config == null ? void 0 : config.headings,
        sidemenuWidth: rootIndex["sidemenu-width"],
        github: { url: rootIndex["github-link"], title: rootIndex["github-title"] },
        children: content
      }
    );
  };

  // node_modules/lupine.press/src/styles/press-themes.ts
  init_src2();
  var pressThemes = {
    light: {
      ...baseThemes.light,
      "--press-border-color": "#e2e2e3",
      "--press-brand-color": "#3eaf7c"
    },
    dark: {
      ...baseThemes.dark,
      "--press-border-color": "#2e2e32",
      "--press-brand-color": "#3eaf7c"
    }
  };

  // apps/my-cv/web/src/styles/base-css.ts
  var baseCss = {
    a: {
      textDecoration: "none",
      color: "inherit",
      "&:hover": { color: "var(--press-brand-color)" }
    },
    body: {
      backgroundColor: "var(--primary-bg-color)",
      color: "var(--primary-color)",
      fontSize: "var(--font-size-base)",
      lineHeight: "var(--line-height-base)",
      fontFamily: "var(--font-family-base)",
      fontWeight: "var(--font-weight-base)"
    }
  };

  // apps/my-cv/web/src/markdown-built/index.html
  var markdown_built_default = "";

  // apps/my-cv/web/src/markdown-built/en/01-experience/index.html
  var experience_default = '<h1 id="experience"><a class="header-anchor" href="#experience">#</a>Experience</h1><h2 id="senior-frontend-engineer-techsolutions-nz-ltd"><a class="header-anchor" href="#senior-frontend-engineer-techsolutions-nz-ltd">#</a>Senior Frontend Engineer | TechSolutions NZ Ltd.</h2><p><strong>Auckland, NZ | June 2021 - Present</strong></p>\n<ul>\n<li><strong>Core Architecture</strong>: Spearheaded the architectural design and refactoring of the company&#39;s flagship product, successfully reducing First Contentful Paint (FCP) from 2.5s to 1.2s.</li>\n<li><strong>Design System</strong>: Led the development and maintenance of the internal UI library <code>abc-ui</code>, boosting team development efficiency by over 30%.</li>\n<li><strong>Performance Optimisation</strong>: Optimised rendering performance for large-scale data visualisation dashboards, enabling smooth handling of 100k+ data points.</li>\n<li><strong>Mentorship</strong>: Mentored three junior developers, established coding standards, and conducted regular code reviews to ensure high code quality.</li>\n</ul>\n<h2 id="full-stack-developer-creative-web-agency"><a class="header-anchor" href="#full-stack-developer-creative-web-agency">#</a>Full Stack Developer | Creative Web Agency</h2><p><strong>Auckland, NZ | June 2018 - May 2021</strong></p>\n<ul>\n<li><strong>System Development</strong>: Took full ownership of the full-stack development for an e-commerce admin portal (Vue.js + Node.js), implementing key modules including order management and role-based access control (RBAC).</li>\n<li><strong>API Design</strong>: Designed and implemented RESTful APIs, documenting them with Swagger to facilitate seamless frontend-backend integration.</li>\n<li><strong>CI/CD</strong>: Implemented an automated build and deployment pipeline using Jenkins, cutting release times by 50%.</li>\n<li><strong>Mobile Responsiveness</strong>: ensured all marketing H5 pages were fully responsive and cross-browser compatible across major devices.</li>\n</ul>\n<h2 id="frontend-intern-digital-innovation-studio"><a class="header-anchor" href="#frontend-intern-digital-innovation-studio">#</a>Frontend Intern | Digital Innovation Studio</h2><p><strong>Wellington, NZ | July 2017 - May 2018</strong></p>\n<ul>\n<li><strong>UI Implementation</strong>: Collaborated closely with UI/UX designers to deliver pixel-perfect web pages with semantic HTML and clean CSS.</li>\n<li><strong>Interactivity</strong>: Implemented complex page interactions using Vanilla JS and jQuery.</li>\n<li><strong>Maintenance</strong>: Assisted with daily bug fixes and feature maintenance tasks.</li>\n</ul>\n';

  // apps/my-cv/web/src/markdown-built/en/02-projects/index.html
  var projects_default = '<h1 id="projects"><a class="header-anchor" href="#projects">#</a>Projects</h1><h2 id="lupine-js-https-github-com-uuware-lupine-js-open-source"><a class="header-anchor" href="#lupine-js-https-github-com-uuware-lupine-js-open-source">#</a><a href="https://github.com/uuware/lupine.js">Lupine.js</a> (Open Source)</h2><p><strong>Stack</strong>: TypeScript, React, Node.js</p>\n<ul>\n<li><strong>Overview</strong>: A high-performance, modular full-stack development framework designed to streamline modern web application builds.</li>\n<li><strong>Key Contributions</strong>:<ul>\n<li>Architected and implemented the core runtime environment.</li>\n<li>Designed a robust plugin system, enabling dynamic extension loading.</li>\n<li>Authored comprehensive official documentation and example projects.</li>\n</ul>\n</li>\n<li><strong>Impact</strong>: Garnered 1k+ Stars on GitHub; recognised as a core contributor.</li>\n</ul>\n<h2 id="personal-blog-generator"><a class="header-anchor" href="#personal-blog-generator">#</a>Personal Blog Generator</h2><p><strong>Stack</strong>: Next.js, Tailwind CSS, Markdown</p>\n<ul>\n<li><strong>Overview</strong>: A static site generator for personal blogs built with Next.js, featuring MDX rendering and customisable themes.</li>\n<li><strong>Features</strong>:<ul>\n<li>High-performance Static Site Generation (SSG) for optimal SEO.</li>\n<li>Integrated commenting system and full-text search capability.</li>\n<li>Native Dark Mode support.</li>\n</ul>\n</li>\n<li><strong>Outcome</strong>: Actively maintained personal project with 500+ daily unique visitors.</li>\n</ul>\n<h2 id="real-time-collaborative-editor"><a class="header-anchor" href="#real-time-collaborative-editor">#</a>Real-time Collaborative Editor</h2><p><strong>Stack</strong>: Vue 3, Socket.io, Node.js, MongoDB</p>\n<ul>\n<li><strong>Overview</strong>: A collaborative online document editing tool similar to Google Docs.</li>\n<li><strong>Challenge</strong>: Implemented Operational Transformation (OT) algorithms to handle conflict resolution during simultaneous multi-user editing.</li>\n<li><strong>Outcome</strong>: Successfully supported 20+ concurrent users editing a single document with latency under 100ms.</li>\n</ul>\n';

  // apps/my-cv/web/src/markdown-built/en/03-skills/index.html
  var skills_default = '<h1 id="technical-skills"><a class="header-anchor" href="#technical-skills">#</a>Technical Skills</h1><h2 id="frontend-core"><a class="header-anchor" href="#frontend-core">#</a>Frontend &amp; Core</h2><ul>\n<li><strong>JavaScript (ES6+) / TypeScript</strong>: Expert level; capable of writing strict, type-safe, and scalable code.</li>\n<li><strong>HTML5 / CSS3</strong>: Proficient with semantic markup, Flexbox, Grid, and modern responsive design principles.</li>\n<li><strong>React / Vue</strong>: Deep understanding of React Hooks and Vue 3 Composition API/Reactivity system.</li>\n</ul>\n<h2 id="backend-database"><a class="header-anchor" href="#backend-database">#</a>Backend &amp; Database</h2><ul>\n<li><strong>Node.js</strong>: Experienced with Express, Koa, and NestJS frameworks for building robust server-side applications.</li>\n<li><strong>Databases</strong>: Competent with MySQL, MongoDB, and Redis, including schema design and basic performance tuning.</li>\n</ul>\n<h2 id="devops-tools"><a class="header-anchor" href="#devops-tools">#</a>DevOps &amp; Tools</h2><ul>\n<li><strong>Build Tools</strong>: Skilled locally with Webpack, Vite, and Rollup.</li>\n<li><strong>Version Control</strong>: Proficient with Git and Git Flow workflows.</li>\n<li><strong>CI/CD</strong>: Experienced in setting up pipelines with GitHub Actions, Jenkins, and Docker.</li>\n</ul>\n<h2 id="general"><a class="header-anchor" href="#general">#</a>General</h2><ul>\n<li><strong>Languages</strong>: English (Professional working proficiency).</li>\n<li><strong>Design</strong>: Comfortable using Figma/Sketch for inspecting designs; solid understanding of UI/UX principles.</li>\n</ul>\n';

  // apps/my-cv/web/src/markdown-built/en/04-education/index.html
  var education_default = '<h1 id="education"><a class="header-anchor" href="#education">#</a>Education</h1><h2 id="university-of-auckland"><a class="header-anchor" href="#university-of-auckland">#</a>University of Auckland</h2><p><strong>Bachelor of Science in Computer Science</strong>\n<strong>Feb 2014 - Nov 2017</strong></p>\n<ul>\n<li><strong>Key Coursework</strong>: Data Structures &amp; Algorithms, Operating Systems, Computer Networks, Database Systems, Software Engineering.</li>\n<li><strong>Achievements</strong>:<ul>\n<li>Dean&#39;s Honours List (2016).</li>\n<li>First Class Honours.</li>\n</ul>\n</li>\n</ul>\n';

  // apps/my-cv/web/src/markdown-built/en/index.html
  var en_default = `<h1 id="alex-freeman"><a class="header-anchor" href="#alex-freeman">#</a>Alex Freeman</h1><blockquote>
<p>Full Stack Engineer | Open Source Enthusiast | Lifelong Learner</p>
</blockquote>
<ul>
<li>\u{1F4E7} Email: <a href="javascript:lpPressLoad('/en/mailto:your.email@example.com')">your.email@example.com</a></li>
<li>\u{1F4F1} Mobile: +64 21 123 4567</li>
<li>\u{1F517} GitHub: <a href="https://github.com/yourusername">github.com/yourusername</a></li>
<li>\u{1F310} Blog: <a href="https://yourblog.com">yourblog.com</a></li>
<li>\u{1F4CD} Location: Auckland, New Zealand</li>
</ul>
<h2 id="personal-statement"><a class="header-anchor" href="#personal-statement">#</a>Personal Statement</h2><p>A seasoned Full Stack Engineer with over 5 years of experience in designing and building high-performance, scalable web applications. Proficient in the modern JavaScript ecosystem, including React, Node.js, and TypeScript. Passionate about open source software and actively maintaining several popular repositories on GitHub.</p>
<p>A problem-solver at heart with strong collaborative and communication skills. Committed to writing clean, maintainable code and delivering exceptional user experiences.</p>
<h2 id="career-objectives"><a class="header-anchor" href="#career-objectives">#</a>Career Objectives</h2><ul>
<li><strong>Role</strong>: Senior Frontend Engineer / Full Stack Engineer</li>
<li><strong>Location</strong>: Auckland / Remote</li>
<li><strong>Availability</strong>: 4 weeks notice</li>
<li><strong>Visa Status</strong>: NZ Resident / Work Visa</li>
</ul>
<hr>
<p>Powered by <a href="https://github.com/uuware/lupine.js">Lupine.js</a>. If you find this template helpful, a star on GitHub is always appreciated \u2B50\uFE0F</p>
`;

  // apps/my-cv/web/src/markdown-built/zh/index.html
  var zh_default = `<h1 id="\u6B66\u6587\u9753-img-src-assets-photo-png-alt-\u4E2A\u4EBA\u7167\u7247-width-150-height-200-style-float-right-margin-left-20px"><a class="header-anchor" href="#\u6B66\u6587\u9753-img-src-assets-photo-png-alt-\u4E2A\u4EBA\u7167\u7247-width-150-height-200-style-float-right-margin-left-20px">#</a>\u6B66\u6587\u9753 <img src="/assets/photo.png" alt="\u4E2A\u4EBA\u7167\u7247" width="150" height="200" style="float: right; margin-left: 20px;"></h1><blockquote>
<p>\u524D\u7AEF\u5F00\u53D1 | \u8F6F\u4EF6\u5DE5\u7A0B\u4E13\u4E1A | 2026\u5C4A\u6BD5\u4E1A\u751F</p>
</blockquote>
<p><strong>\u8054\u7CFB\u65B9\u5F0F\uFF1A</strong> 18660278715 | <strong>\u90AE\u7BB1\uFF1A</strong> <a href="javascript:lpPressLoad('/zh/mailto:wuwenliang0924@gmail.com')">wuwenliang0924@gmail.com</a><br><strong>GitHub\uFF1A</strong> <a href="https://github.com/WWL0924">https://github.com/WWL0924</a><br><strong>CSDN\uFF1A</strong> <a href="https://blog.csdn.net/W2902798451">https://blog.csdn.net/W2902798451</a><br><strong>\u6C42\u804C\u610F\u5411\uFF1A</strong> \u524D\u7AEF\u5F00\u53D1</p>
<hr>
<h2 id="\u6559\u80B2\u80CC\u666F"><a class="header-anchor" href="#\u6559\u80B2\u80CC\u666F">#</a>\u6559\u80B2\u80CC\u666F</h2><p>  \u4E1C\u5317\u77F3\u6CB9\u5927\u5B66\uFF08\u4E00\u672C\uFF09  \u8F6F\u4EF6\u5DE5\u7A0B  \u672C\u79D1   2022-09 - 2026-06 </p>
<hr>
<h2 id="\u5B9E\u4E60\u7ECF\u5386"><a class="header-anchor" href="#\u5B9E\u4E60\u7ECF\u5386">#</a>\u5B9E\u4E60\u7ECF\u5386</h2><h3 id="\u9752\u5C9B\u6167\u5FD7\u4FE1\u606F\u6280\u672F\u6709\u9650\u516C\u53F8-\u524D\u7AEF\u5F00\u53D1\u5B9E\u4E60\u751F-\u9752\u5C9B-2025-01-2025-04"><a class="header-anchor" href="#\u9752\u5C9B\u6167\u5FD7\u4FE1\u606F\u6280\u672F\u6709\u9650\u516C\u53F8-\u524D\u7AEF\u5F00\u53D1\u5B9E\u4E60\u751F-\u9752\u5C9B-2025-01-2025-04">#</a>\u9752\u5C9B\u6167\u5FD7\u4FE1\u606F\u6280\u672F\u6709\u9650\u516C\u53F8 \xB7 \u524D\u7AEF\u5F00\u53D1\u5B9E\u4E60\u751F \xB7 \u9752\u5C9B \xB7 2025-01 - 2025-04</h3><ul>
<li>\u57FA\u4E8E <strong>React 19</strong>\u3001<strong>TypeScript</strong>\u3001<strong>Vite</strong>\u3001<strong>Redux</strong> \u548C <strong>Ant Design</strong> \u5F00\u53D1\u516C\u53F8\u5185\u90E8\u7BA1\u7406\u7CFB\u7EDF\uFF0C\u5B9E\u73B0\u7BA1\u7406\u5458/\u666E\u901A\u7528\u6237\u53CC\u89D2\u8272\u6743\u9650\u7BA1\u7406\uFF0C\u5305\u542B\u7528\u6237\u7BA1\u7406\u3001\u6570\u636E\u7EDF\u8BA1\u3001\u4E1A\u52A1\u5904\u7406\u7B49\u6838\u5FC3\u529F\u80FD\u6A21\u5757</li>
<li>\u8BBE\u8BA1\u7EDF\u4E00<strong>Layout\u7EC4\u4EF6</strong>\u67B6\u6784\uFF0C\u5B9E\u73B0\u7BA1\u7406\u5458/\u7528\u6237\u53CC\u7AEF\u754C\u9762\u590D\u7528\uFF0C\u63D0\u5347\u5F00\u53D1\u6548\u7387</li>
<li>\u8D1F\u8D23\u4E1A\u52A1\u6A21\u5757\u9875\u9762\u5F00\u53D1\uFF0C\u5B8C\u6210\u7528\u6237\u7BA1\u7406\u3001\u4E1A\u52A1\u5904\u7406\u7B49\u6838\u5FC3\u529F\u80FD\u7684\u6570\u636E\u6E32\u67D3\u4E0E\u4EA4\u4E92\u5B9E\u73B0</li>
<li>\u53C2\u4E0E\u8868\u5355\u9875\u9762\u5F00\u53D1\uFF0C\u8FD0\u7528<strong>Ant Design</strong>\u7EC4\u4EF6\u5E93\u5B9E\u73B0\u8868\u5355\u9A8C\u8BC1\u4E0E\u7528\u6237\u4EA4\u4E92\u903B\u8F91</li>
<li>\u91C7\u7528<strong>\u6A21\u5757\u5316\u67B6\u6784</strong>\u8BBE\u8BA1\uFF0C\u652F\u6301\u7CFB\u7EDF\u529F\u80FD\u6269\u5C55\u4E0E\u7EF4\u62A4</li>
</ul>
<hr>
<h2 id="\u9879\u76EE\u7ECF\u5386"><a class="header-anchor" href="#\u9879\u76EE\u7ECF\u5386">#</a>\u9879\u76EE\u7ECF\u5386</h2><h3 id="\u793E\u533A\u5BA0\u7269\u72D7\u7BA1\u7406\u7CFB\u7EDF"><a class="header-anchor" href="#\u793E\u533A\u5BA0\u7269\u72D7\u7BA1\u7406\u7CFB\u7EDF">#</a>\u793E\u533A\u5BA0\u7269\u72D7\u7BA1\u7406\u7CFB\u7EDF</h3><p>\u57FA\u4E8E <strong>React 18</strong> + <strong>TypeScript</strong> + <strong>Vite</strong> \u6784\u5EFA\uFF0C\u7ED3\u5408 <strong>Redux</strong>\u3001<strong>React Router 6</strong> \u4E0E <strong>Ant Design</strong> \u5B9E\u73B0\u7684\u793E\u533A\u5BA0\u7269\u7BA1\u7406\u5E73\u53F0\uFF0C\u5B9E\u73B0\u7BA1\u7406\u5458/\u5C45\u6C11\u53CC\u7AEF <strong>RBAC</strong> \u6743\u9650\u9694\u79BB\u4E0E\u5728\u7EBF\u5BA1\u6279\u6D41\u7A0B\u3002</p>
<ul>
<li>\u8BBE\u8BA1 <strong>Redux</strong> \u72B6\u6001\u67B6\u6784\uFF0C\u62C6\u5206\u6A21\u5757\u5E76\u96C6\u6210 <strong>Thunk</strong>\u3001<strong>Persist</strong>\uFF0C\u5B9E\u73B0\u5F02\u6B65\u7BA1\u7406\u4E0E\u767B\u5F55\u6001\u6301\u4E45\u5316</li>
<li>\u57FA\u4E8E\u540E\u7AEF\u6743\u9650\u5B9E\u73B0<strong>\u52A8\u6001\u8DEF\u7531</strong>\u4E0E\u7EDF\u4E00\u9274\u6743\uFF0C\u89E3\u51B3\u6743\u9650\u521D\u59CB\u5316\u95EA\u70C1\u95EE\u9898</li>
<li>\u5C01\u88C5<strong>\u914D\u7F6E\u5316\u8868\u5355\u7EC4\u4EF6</strong>\uFF0C\u51CF\u5C11\u91CD\u590D\u5F00\u53D1\u7EA6 40%</li>
<li>\u5B9E\u73B0<strong>\u8DEF\u7531\u61D2\u52A0\u8F7D</strong>\u4E0E\u591A\u6761\u4EF6\u7B5B\u9009\u4F18\u5316\uFF0C\u63D0\u5347\u9996\u5C4F\u52A0\u8F7D\u4E0E\u6E32\u67D3\u6027\u80FD</li>
</ul>
<h3 id="2048\u6E38\u620F-\u539F\u751Fjs\u5B9E\u73B0-https-wwl0924-github-io-2048-https-wwl0924-github-io-2048"><a class="header-anchor" href="#2048\u6E38\u620F-\u539F\u751Fjs\u5B9E\u73B0-https-wwl0924-github-io-2048-https-wwl0924-github-io-2048">#</a>2048\u6E38\u620F\uFF08\u539F\u751FJS\u5B9E\u73B0) <a href="https://wwl0924.github.io/2048/">https://wwl0924.github.io/2048/</a></h3><p>\u57FA\u4E8E <strong>HTML5</strong> + <strong>CSS3</strong> + <strong>JavaScript\uFF08ES6\uFF09</strong> \u72EC\u7ACB\u5F00\u53D1\u7684 2048 \u5C0F\u6E38\u620F\uFF0C\u4F7F\u7528 <strong>CSS Grid</strong> \u6784\u5EFA\u68CB\u76D8\u5E03\u5C40\uFF0C\u57FA\u4E8E\u539F\u751F <strong>DOM</strong> \u64CD\u4F5C\u4E0E\u4E8B\u4EF6\u76D1\u542C\u5B9E\u73B0\u4EA4\u4E92\uFF0C\u901A\u8FC7<strong>\u4E8C\u7EF4\u6570\u7EC4</strong>\u7BA1\u7406\u68CB\u76D8\u72B6\u6001\u5E76\u9A71\u52A8\u89C6\u56FE\u66F4\u65B0\uFF0C\u5B8C\u6574\u5B9E\u73B0\u65B9\u5757\u968F\u673A\u751F\u6210\u3001\u65B9\u5411\u79FB\u52A8\u3001\u5408\u5E76\u89C4\u5219\u63A7\u5236\u3001\u6700\u5927\u503C\u8BA1\u5206\u3001\u6B7B\u4EA1\u68C0\u6D4B\u53CA\u906E\u7F69\u91CD\u5F00\u7B49\u6838\u5FC3\u529F\u80FD\u3002</p>
<ul>
<li>\u4F7F\u7528<strong>\u4E8C\u7EF4\u6570\u7EC4</strong>\u7EF4\u62A4\u68CB\u76D8\u6570\u636E\u7ED3\u6784\uFF0C\u7EDF\u4E00\u7BA1\u7406\u6BCF\u4E2A\u683C\u5B50\u7684\u6570\u503C\u53D8\u5316</li>
<li>\u901A\u8FC7<strong>\u6570\u7EC4\u65CB\u8F6C</strong>\u5C06\u4E0A\u4E0B\u5DE6\u53F3\u79FB\u52A8\u7EDF\u4E00\u8F6C\u5316\u4E3A\u5DE6\u79FB\u903B\u8F91\uFF0C\u964D\u4F4E\u91CD\u590D\u5224\u65AD\uFF0C\u63D0\u9AD8\u4EE3\u7801\u590D\u7528\u6027</li>
<li>\u5B9E\u73B0\u5408\u5E76\u540E\u518D\u6B21\u79FB\u52A8\u673A\u5236\uFF0C\u4FDD\u8BC1\u5355\u6B21\u79FB\u52A8\u4E2D\u65B9\u5757\u53EA\u5408\u5E76\u4E00\u6B21\uFF0C\u7B26\u5408 2048 \u89C4\u5219</li>
<li>\u7F16\u5199<strong>\u6B7B\u4EA1\u5224\u65AD\u7B97\u6CD5</strong>\uFF08\u65E0\u7A7A\u4F4D\u4E14\u65E0\u53EF\u5408\u5E76\u76F8\u90BB\u5757\uFF09\uFF0C\u63A7\u5236\u6E38\u620F\u7ED3\u675F\u906E\u7F69\u5C55\u793A</li>
<li>\u4F7F\u7528 <strong>keydown \u4E8B\u4EF6</strong>\u9A71\u52A8\u79FB\u52A8\u903B\u8F91\uFF0C\u7ED3\u5408<strong>\u6A21\u677F\u5B57\u7B26\u4E32</strong>\u8FDB\u884C\u52A8\u6001\u6E32\u67D3\uFF0C\u5B9E\u73B0\u6570\u636E\u4E0E\u89C6\u56FE\u540C\u6B65\u66F4\u65B0</li>
</ul>
<h3 id="\u8D2A\u5403\u86C7\u6E38\u620F-\u539F\u751Fjs\u5B9E\u73B0-https-wwl0924-github-io-snake-https-wwl0924-github-io-snake"><a class="header-anchor" href="#\u8D2A\u5403\u86C7\u6E38\u620F-\u539F\u751Fjs\u5B9E\u73B0-https-wwl0924-github-io-snake-https-wwl0924-github-io-snake">#</a>\u8D2A\u5403\u86C7\u6E38\u620F\uFF08\u539F\u751FJS\u5B9E\u73B0\uFF09<a href="https://wwl0924.github.io/snake/">https://wwl0924.github.io/snake/</a></h3><p>\u57FA\u4E8E <strong>HTML5</strong>\u3001<strong>CSS3</strong>\uFF08<strong>Grid \u5E03\u5C40</strong>\uFF09\u4E0E\u539F\u751F <strong>JavaScript\uFF08ES6\uFF09</strong> \u5F00\u53D1\u7684\u6D4F\u89C8\u5668\u7AEF\u8D2A\u5403\u86C7\u6E38\u620F\uFF0C\u5B9E\u73B0\u86C7\u4F53\u79FB\u52A8\u3001\u968F\u673A\u679C\u5B9E\u751F\u6210\u3001\u78B0\u649E\u68C0\u6D4B\u3001\u6682\u505C\u4E0E\u91CD\u5F00\u7B49\u529F\u80FD\uFF0C\u91C7\u7528<strong>\u5B9A\u65F6\u5668</strong>\u9A71\u52A8\u6570\u636E\u66F4\u65B0\u5E76\u901A\u8FC7 <strong>DOM</strong> \u5B8C\u6210\u89C6\u56FE\u6E32\u67D3\u3002</p>
<ul>
<li>\u4F7F\u7528<strong>\u4E8C\u7EF4\u6570\u7EC4</strong>\u7EF4\u62A4\u86C7\u8EAB\u5750\u6807\uFF0C<strong>unshift / pop</strong> \u5B9E\u73B0\u4F4D\u79FB\u4E0E\u589E\u957F\u903B\u8F91</li>
<li>\u57FA\u4E8E <strong>setInterval</strong> \u6784\u5EFA\u6E38\u620F\u4E3B\u5FAA\u73AF\uFF0C\u5B9E\u73B0\u65B9\u5411\u63A7\u5236\u4E0E\u5B9E\u65F6\u66F4\u65B0</li>
<li>\u5B9E\u73B0<strong>\u8FB9\u754C\u4E0E\u81EA\u8EAB\u78B0\u649E\u68C0\u6D4B</strong>\uFF0C\u5B8C\u6210\u6E38\u620F\u7ED3\u675F\u5224\u5B9A</li>
<li>\u5C01\u88C5<strong>\u6682\u505C\u4E0E\u91CD\u7F6E\u903B\u8F91</strong>\uFF0C\u4FDD\u8BC1\u72B6\u6001\u53EF\u6062\u590D\u4E0E\u53EF\u91CD\u7F6E</li>
</ul>
<h3 id="\u4FC4\u7F57\u65AF\u65B9\u5757-\u539F\u751Fjs\u5B9E\u73B0-https-wwl0924-github-io-tetris-https-wwl0924-github-io-tetris"><a class="header-anchor" href="#\u4FC4\u7F57\u65AF\u65B9\u5757-\u539F\u751Fjs\u5B9E\u73B0-https-wwl0924-github-io-tetris-https-wwl0924-github-io-tetris">#</a>\u4FC4\u7F57\u65AF\u65B9\u5757\uFF08\u539F\u751FJS\u5B9E\u73B0) <a href="https://wwl0924.github.io/Tetris/">https://wwl0924.github.io/Tetris/</a></h3><p>\u57FA\u4E8E <strong>HTML5</strong>\u3001<strong>CSS3</strong>\uFF08<strong>Flex \u5E03\u5C40</strong>\uFF09\u4E0E\u539F\u751F <strong>JavaScript\uFF08ES6\uFF09</strong> \u5F00\u53D1\u7684\u6D4F\u89C8\u5668\u7AEF\u4FC4\u7F57\u65AF\u65B9\u5757\u6E38\u620F\uFF0C\u5B9E\u73B0\u65B9\u5757\u4E0B\u843D\u3001\u65CB\u8F6C\u3001\u5DE6\u53F3\u79FB\u52A8\u53CA\u884C\u6D88\u9664\u7B49\u529F\u80FD\uFF0C\u901A\u8FC7<strong>\u5B9A\u65F6\u5668</strong>\u9A71\u52A8\u6E38\u620F\u4E3B\u5FAA\u73AF\u5E76\u4F7F\u7528 <strong>DOM</strong> \u6E32\u67D3\u89C6\u56FE\u3002</p>
<ul>
<li>\u4F7F\u7528<strong>\u4E8C\u7EF4\u6570\u7EC4</strong>\u7EF4\u62A4\u65B9\u5757\u56FA\u5B9A\u72B6\u6001\uFF0C<strong>\u6570\u7EC4\u64CD\u4F5C</strong>\u5B9E\u73B0\u65B9\u5757\u89E6\u5E95\u56FA\u5B9A\u4E0E\u884C\u6D88\u9664\u903B\u8F91</li>
<li>\u57FA\u4E8E <strong>setInterval</strong> \u6784\u5EFA\u6E38\u620F\u4E3B\u5FAA\u73AF\uFF0C\u5B9E\u73B0\u65B9\u5411\u63A7\u5236\u3001\u65CB\u8F6C\u5904\u7406\u4E0E\u5B9E\u65F6\u4E0B\u843D</li>
<li>\u5B9E\u73B0<strong>\u8FB9\u754C\u4E0E\u65B9\u5757\u78B0\u649E\u68C0\u6D4B</strong>\uFF0C\u5B8C\u6210\u6E38\u620F\u7ED3\u675F\u5224\u5B9A</li>
<li>\u5C01\u88C5<strong>\u89E6\u5E95\u3001\u6D88\u9664\u4E0E\u91CD\u7F6E\u903B\u8F91</strong>\uFF0C\u4FDD\u8BC1\u6E38\u620F\u72B6\u6001\u53EF\u66F4\u65B0\u4E0E\u53EF\u91CD\u7F6E</li>
</ul>
<h3 id="\u8C46\u74E3\u7535\u5F71top10\u6570\u636E\u53EF\u89C6\u5316-https-wwl0924-github-io-web-crawler-https-wwl0924-github-io-web-crawler"><a class="header-anchor" href="#\u8C46\u74E3\u7535\u5F71top10\u6570\u636E\u53EF\u89C6\u5316-https-wwl0924-github-io-web-crawler-https-wwl0924-github-io-web-crawler">#</a>\u8C46\u74E3\u7535\u5F71Top10\u6570\u636E\u53EF\u89C6\u5316 <a href="https://wwl0924.github.io/Web-crawler/">https://wwl0924.github.io/Web-crawler/</a></h3><p>\u57FA\u4E8E <strong>HTML5</strong>\u3001<strong>CSS3</strong> \u4E0E\u539F\u751F <strong>JavaScript</strong> \u5F00\u53D1\u7684\u6D4F\u89C8\u5668\u7AEF\u6570\u636E\u53EF\u89C6\u5316\u9879\u76EE\uFF0C\u5B9E\u73B0\u7535\u5F71\u6570\u636E\u5C55\u793A\u3001<strong>ECharts</strong>\u56FE\u8868\u6E32\u67D3\u3001\u54CD\u5E94\u5F0F\u5E03\u5C40\u7B49\u529F\u80FD\uFF0C\u901A\u8FC7 <strong>Fetch API</strong> \u83B7\u53D6\u6570\u636E\u5E76\u5B8C\u6210\u52A8\u6001\u89C6\u56FE\u66F4\u65B0\u3002</p>
<ul>
<li>\u4F7F\u7528 <strong>ECharts</strong> \u5B9E\u73B0\u7535\u5F71\u8BC4\u5206\u5206\u5E03\u4E0E\u6392\u540D\u5360\u6BD4\u53EF\u89C6\u5316\uFF0C\u652F\u6301\u56FE\u8868\u4EA4\u4E92\u4E0E\u6570\u636E\u7B5B\u9009</li>
<li>\u57FA\u4E8E <strong>CSS Grid</strong> \u4E0E <strong>Flexbox</strong> \u6784\u5EFA\u54CD\u5E94\u5F0F\u5E03\u5C40\uFF0C\u9002\u914D\u79FB\u52A8\u7AEF\u4E0E\u684C\u9762\u7AEF\u8BBE\u5907</li>
<li>\u901A\u8FC7 <strong>Fetch API</strong> \u5F02\u6B65\u83B7\u53D6 <strong>JSON</strong> \u6570\u636E\uFF0C\u5B9E\u73B0\u52A8\u6001\u5185\u5BB9\u52A0\u8F7D\u4E0E\u72B6\u6001\u7BA1\u7406</li>
<li>\u5C01\u88C5<strong>\u56FE\u8868\u7EC4\u4EF6</strong>\u4E0E<strong>\u6570\u636E\u5904\u7406\u903B\u8F91</strong>\uFF0C\u63D0\u5347\u4EE3\u7801\u53EF\u7EF4\u62A4\u6027\u4E0E\u590D\u7528\u6027</li>
</ul>
<hr>
<h2 id="\u4E13\u4E1A\u6280\u80FD"><a class="header-anchor" href="#\u4E13\u4E1A\u6280\u80FD">#</a>\u4E13\u4E1A\u6280\u80FD</h2><ul>
<li><strong>\u524D\u7AEF\u57FA\u7840</strong>\uFF1A\u719F\u7EC3\u638C\u63E1 <strong>HTML</strong>\u3001<strong>CSS</strong>\u3001<strong>JavaScript\uFF08ES6+\uFF09</strong>\uFF0C\u7406\u89E3<strong>\u4F5C\u7528\u57DF</strong>\u3001<strong>\u539F\u578B\u94FE</strong>\u3001<strong>\u95ED\u5305</strong>\u3001<strong>\u4E8B\u4EF6\u5FAA\u73AF</strong>\u7B49\u6838\u5FC3\u673A\u5236</li>
<li><strong>\u524D\u7AEF\u6846\u67B6</strong>\uFF1A\u719F\u7EC3\u4F7F\u7528 <strong>React + Hooks</strong> \u5F00\u53D1\u4E2D\u540E\u53F0\u9879\u76EE\uFF0C\u7406\u89E3<strong>\u7EC4\u4EF6\u5316</strong>\u4E0E<strong>\u6570\u636E\u9A71\u52A8</strong>\u601D\u60F3</li>
<li><strong>\u72B6\u6001\u7BA1\u7406</strong>\uFF1A\u719F\u6089 <strong>Redux</strong> \u7B49\u72B6\u6001\u7BA1\u7406\u65B9\u6848\uFF0C\u80FD\u591F\u6784\u5EFA\u6E05\u6670\u7684\u6570\u636E\u6D41\u4F53\u7CFB</li>
<li><strong>\u6784\u5EFA\u5DE5\u5177</strong>\uFF1A\u719F\u6089 <strong>Vite / Webpack</strong> \u7B49\u5DE5\u7A0B\u5316\u5DE5\u5177\uFF0C\u5177\u5907<strong>\u6A21\u5757\u5316\u62C6\u5206</strong>\u4E0E<strong>\u6784\u5EFA\u4F18\u5316</strong>\u80FD\u529B</li>
<li><strong>\u6027\u80FD\u4F18\u5316</strong>\uFF1A\u5177\u5907<strong>\u6027\u80FD\u4F18\u5316</strong>\u610F\u8BC6\uFF0C\u80FD\u591F\u8FDB\u884C<strong>\u9996\u5C4F\u4F18\u5316</strong>\u3001<strong>\u61D2\u52A0\u8F7D</strong>\u53CA<strong>\u6253\u5305\u4F53\u79EF\u4F18\u5316</strong></li>
<li><strong>\u7248\u672C\u63A7\u5236</strong>\uFF1A\u719F\u7EC3\u4F7F\u7528 <strong>Git</strong> \u8FDB\u884C\u7248\u672C\u7BA1\u7406\uFF0C\u5177\u5907\u56E2\u961F\u534F\u4F5C\u7ECF\u9A8C</li>
<li><strong>\u7C7B\u578B\u7CFB\u7EDF</strong>\uFF1A\u4E86\u89E3 <strong>TypeScript</strong> \u57FA\u7840\u7C7B\u578B\u3001\u63A5\u53E3\u4E0E\u6CDB\u578B\u7684\u4F7F\u7528\uFF0C\u80FD\u591F\u5728\u9879\u76EE\u4E2D\u8FDB\u884C\u7C7B\u578B\u7EA6\u675F</li>
<li><strong>\u7B97\u6CD5\u57FA\u7840</strong>\uFF1A\u4E86\u89E3\u5E38\u89C1<strong>\u6570\u636E\u7ED3\u6784</strong>\u4E0E\u57FA\u7840<strong>\u7B97\u6CD5</strong>\uFF0C\u5177\u5907\u4E00\u5B9A\u624B\u5199\u80FD\u529B</li>
<li><strong>\u540E\u7AEF\u57FA\u7840</strong>\uFF1A\u4E86\u89E3 <strong>Node.js</strong> \u57FA\u7840\uFF0C\u80FD\u591F\u8FDB\u884C\u63A5\u53E3\u6A21\u62DF\u6216\u7B80\u5355\u811A\u672C\u5F00\u53D1</li>
<li><strong>UI\u7EC4\u4EF6\u5E93</strong>\uFF1A\u719F\u6089 <strong>Ant Design</strong> \u7B49 UI \u7EC4\u4EF6\u5E93\u5E76\u5177\u5907<strong>\u4E8C\u6B21\u5C01\u88C5</strong>\u80FD\u529B</li>
</ul>
`;

  // apps/my-cv/web/src/markdown-built/markdown-config.ts
  var markdownConfig = {
    "/": { html: markdown_built_default, data: { "lang": [{ "title": "English", "id": "en" }, { "title": "\u7B80\u4F53\u4E2D\u6587", "id": "zh" }] }, headings: [] },
    "/en/01-experience/index": { html: experience_default, data: { "title": "Experience", "order": 1 }, headings: [{ "level": 2, "text": "Senior Frontend Engineer | TechSolutions NZ Ltd.", "id": "senior-frontend-engineer-techsolutions-nz-ltd" }, { "level": 2, "text": "Full Stack Developer | Creative Web Agency", "id": "full-stack-developer-creative-web-agency" }, { "level": 2, "text": "Frontend Intern | Digital Innovation Studio", "id": "frontend-intern-digital-innovation-studio" }] },
    "/en/02-projects/index": { html: projects_default, data: { "title": "Projects", "order": 2 }, headings: [{ "level": 2, "text": "Lupine.js (Open Source)", "id": "lupine-js-https-github-com-uuware-lupine-js-open-source" }, { "level": 2, "text": "Personal Blog Generator", "id": "personal-blog-generator" }, { "level": 2, "text": "Real-time Collaborative Editor", "id": "real-time-collaborative-editor" }] },
    "/en/03-skills/index": { html: skills_default, data: { "title": "Skills", "order": 3 }, headings: [{ "level": 2, "text": "Frontend & Core", "id": "frontend-core" }, { "level": 2, "text": "Backend & Database", "id": "backend-database" }, { "level": 2, "text": "DevOps & Tools", "id": "devops-tools" }, { "level": 2, "text": "General", "id": "general" }] },
    "/en/04-education/index": { html: education_default, data: { "title": "Education", "order": 4 }, headings: [{ "level": 2, "text": "University of Auckland", "id": "university-of-auckland" }] },
    "/en/index": { html: en_default, data: { "title": "CV", "order": 0, "github-title": "View on GitHub", "github-link": "https://github.com/uuware/lupine.js", "sidebar": [{ "type": "group", "text": "Details", "level": 0 }, { "type": "link", "text": "Experience", "link": "/en/01-experience/index", "level": 1 }, { "type": "link", "text": "Projects", "link": "/en/02-projects/index", "level": 1 }, { "type": "link", "text": "Skills", "link": "/en/03-skills/index", "level": 1 }, { "type": "link", "text": "Education", "link": "/en/04-education/index", "level": 1 }] }, headings: [{ "level": 2, "text": "Personal Statement", "id": "personal-statement" }, { "level": 2, "text": "Career Objectives", "id": "career-objectives" }] },
    "/zh/index": { html: zh_default, data: {}, headings: [{ "level": 2, "text": "\u6559\u80B2\u80CC\u666F", "id": "\u6559\u80B2\u80CC\u666F" }, { "level": 2, "text": "\u5B9E\u4E60\u7ECF\u5386", "id": "\u5B9E\u4E60\u7ECF\u5386" }, { "level": 3, "text": "\u9752\u5C9B\u6167\u5FD7\u4FE1\u606F\u6280\u672F\u6709\u9650\u516C\u53F8 \xB7 \u524D\u7AEF\u5F00\u53D1\u5B9E\u4E60\u751F \xB7 \u9752\u5C9B \xB7 2025-01 - 2025-04", "id": "\u9752\u5C9B\u6167\u5FD7\u4FE1\u606F\u6280\u672F\u6709\u9650\u516C\u53F8-\u524D\u7AEF\u5F00\u53D1\u5B9E\u4E60\u751F-\u9752\u5C9B-2025-01-2025-04" }, { "level": 2, "text": "\u9879\u76EE\u7ECF\u5386", "id": "\u9879\u76EE\u7ECF\u5386" }, { "level": 3, "text": "\u793E\u533A\u5BA0\u7269\u72D7\u7BA1\u7406\u7CFB\u7EDF", "id": "\u793E\u533A\u5BA0\u7269\u72D7\u7BA1\u7406\u7CFB\u7EDF" }, { "level": 3, "text": "2048\u6E38\u620F\uFF08\u539F\u751FJS\u5B9E\u73B0) https://wwl0924.github.io/2048/", "id": "2048\u6E38\u620F-\u539F\u751Fjs\u5B9E\u73B0-https-wwl0924-github-io-2048-https-wwl0924-github-io-2048" }, { "level": 3, "text": "\u8D2A\u5403\u86C7\u6E38\u620F\uFF08\u539F\u751FJS\u5B9E\u73B0\uFF09https://wwl0924.github.io/snake/", "id": "\u8D2A\u5403\u86C7\u6E38\u620F-\u539F\u751Fjs\u5B9E\u73B0-https-wwl0924-github-io-snake-https-wwl0924-github-io-snake" }, { "level": 3, "text": "\u4FC4\u7F57\u65AF\u65B9\u5757\uFF08\u539F\u751FJS\u5B9E\u73B0) https://wwl0924.github.io/Tetris/", "id": "\u4FC4\u7F57\u65AF\u65B9\u5757-\u539F\u751Fjs\u5B9E\u73B0-https-wwl0924-github-io-tetris-https-wwl0924-github-io-tetris" }, { "level": 3, "text": "\u8C46\u74E3\u7535\u5F71Top10\u6570\u636E\u53EF\u89C6\u5316 https://wwl0924.github.io/Web-crawler/", "id": "\u8C46\u74E3\u7535\u5F71top10\u6570\u636E\u53EF\u89C6\u5316-https-wwl0924-github-io-web-crawler-https-wwl0924-github-io-web-crawler" }, { "level": 2, "text": "\u4E13\u4E1A\u6280\u80FD", "id": "\u4E13\u4E1A\u6280\u80FD" }] }
  };

  // apps/my-cv/web/resume/index.tsx
  if (isFrontEnd2() && webEnv("NODE_ENV" /* NODE_ENV */, "") === "development") {
    debugWatch(webEnv("API_PORT" /* API_PORT */, 0));
  }
  bindLang("en", {});
  bindTheme("light", pressThemes);
  bindAppGlobalStyle("comm-css", baseCss, false, true);
  setDefaultPageTitle("Doc Starter");
  bindPressData(markdownConfig);
  setPressSubDir("/resume");
  var pageRouter = new PageRouter();
  pageRouter.setSubDir("/resume");
  pageRouter.use("*", PressPage);
  bindRouter(pageRouter);
})();
/*! Bundled license information:

is-extendable/index.js:
  (*!
   * is-extendable <https://github.com/jonschlinkert/is-extendable>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

strip-bom-string/index.js:
  (*!
   * strip-bom-string <https://github.com/jonschlinkert/strip-bom-string>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=/resume/index.js.map
